{
	"git": [
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-git-version",
			"title": "Git. Get git version",
			"description": "<p>Before you install git, it's a good idea to check if you already have it installed by using the following command, which will return the version number installed on your computer. If not, follow the steps described in this <a href='https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git' target='_blank'>link</a> depending on your operating system.</p>",
			"code": "git --version"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-git-repository",
			"title": "Git. Initialize git repository",
			"description": "<p>A git repository is a virtual storage for your project. It allows you to save versions of the code that you can access whenever you need to. The following command, used only once during the initial setup of a new repository, will create a new <code>.git</code> subdirectory in your current working directory and a new <code>MASTER</code> branch.</p><p><a href='https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init' target='_blank'>Know more</a></p>",
			"code": "git init"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-configuration",
			"title": "Git. Show the set configuration",
			"description": "<p>To visualize our current configuration. We must know that all the configuration is saved in the file <code>.gitconfig</code>, found in the user <code>HOME</code> if you are Linux or in <code>C:Users</code> if you are on Windows or typing on the console <code>git config --list --show-origin</code> if you are  Mac.</p>",
			"code": [
				["git config -l"],
				["git config --list"],
				["git config --global --list"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "config-user-name-email",
			"title": "Git. Configure the name and email of user",
			"description": "<p>Git is a <strong>distributed version control system</strong> that’s being used by most software teams today. The first thing you should do after installing Git on your system is to configure your git username and email address. Git associate your identity with every commit you make.</p><p>Git allows you to set a global and per-project username and email address. You can set or change your git identity using the next command. Changes only affect future commits. The name and email associated with the commits you made prior to the change are not affected.</p>",
			"code": [
				["git config --global user.name <USER_NAME>"],
				["git config --global user.email <USER_EMAIL>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "config-code-editor",
			"title": "Git. Add or edit the default editor",
			"description": "<p>When you create a Git commit with <code>git commit –a</code>, the default editor that will be opened is <strong>Vim</strong>. This can be very confusing for people, as Vim is not an easy editor if you have never worked with it previously.</p><p>There are many ways in which this can be done: via the terminal with the next command, edting the <code>.gitconfig</code> file...</p><p>On <strong>OSX</strong> for set <strong>Visual Studio Code</strong> as global Git editor, you need to do the next steps: <ul><li>Open the editor and press at the same time the keys <code>Shift + Command + P</code>.</li><li>Type the word <code>Code</code> on the emergent window and click on <code>Shell Command: Install 'code' command in PATH</code> to do the installation.</li><li>And then use the second block of commands of this description, for run the 2 lines in your terminal. This defines it in your settings as the global editor of Git and opens this same settings file with it.</li></ul></p><p><a href='https://stackoverflow.com/questions/34746045/set-visual-studio-code-to-be-global-git-editor-on-osx' target='_blank'>Know more</a></p>",
			"code": [
				["git config --global core.editor <PATH/TO/EDITOR_CODE>"],
				[
					"git config --global core.editor 'code --wait'",
					"git config --global -e"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "open-file-with-editor",
			"title": "Git. Open a project or file with the editor",
			"description": "<p>Through the terminal you can open a file with your preferred code editor. These commands open a file with the SublimeText, Atom and Visual Studio Code editors.</p>",
			"code": [
				["subl <PATH/TO/FOLDER/FILE>"],
				["atom <PATH/TO/FOLDER/FILE>"],
				["code <PATH/TO/FOLDER/FILE>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "change-autor-email-last-commits",
			"title": "Git. Change the name and email of the author of the last commit",
			"description": "<p>If you have made a mistake and made your commit with another name or email you can overwrite the author information of only the last commit with this command.</p>",
			"code": "git commit --amend --author='<USER_NAME> <USER_EMAIL>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "change-autor-email-commits",
			"title": "Git. Change the name and email of the author after make a commit",
			"description": "<p>If you have made a mistake and made several commits with another name or user email you can overwrite the author information of all commits with the following command.</p><p>Be very careful if these commits have been previously uploaded to the remote repository and if more people are collaborating in the repository. If this is the case, it is important to communicate it before making this command, because you'll also have to overwrite changes in the remote repository with <code>git push -f</code> and the other contributors will have to update their local repository with <code>git pull -f</code>. This type of changes is best made without having any changes saved in the staging area or the working directory.</p>",
			"code": [
				"#!/bin/sh",
				"",
				"git filter-branch --env-filter '",
				"WRONG_EMAIL=\"<USER_EMAIL>\"",
				"CORRECT_NAME=\"<USER_NAME>\"",
				"CORRECT_EMAIL=\"<USER_EMAIL>\"",
				"if [\"$GIT_COMMITTER_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"",
				"    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"if [\"$GIT_AUTHOR_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"",
				"    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"' --tag-name-filter cat -- --branches --tags"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits",
			"title": "Git. Get all commits made",
			"description": "<p>After you have made several commits, or if you have cloned a repository that already had a commit history, you will probably want to look back to see what modifications have been made.<br>This command shows a list of all the commits made, in reverse chronological order, i.e. the most recent ones are shown at the beginning. Each commit contains information about the identification number (<em>Secure Hash Algorithm</em>, <code>SHA-1</code>), the author's name and e-mail address, the date and the commit message.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones' target='_blank'>Know more</a></p>",
			"code": "git log"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-oneline",
			"title": "Git. Get all commits made in a single line",
			"description": "<p>The <code>git log</code> command has many optional parameters for formatting the output of the commit information. The <code>--oneline</code> option shows the information of each commit in a single line with the first 6 characters of the <code>SHA-1</code> number, the branches, the tags and the message.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones#rlog_options' target='_blank'>Know more</a></p>",
			"code": "git log --oneline"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-oneline-graph",
			"title": "Git. Get all commits made in a graph",
			"description": "<p>This command condenses the information of each commit into a single line, showing only the commit ID and the first line of the commit message, highlighting all references (branches, tags...).<br> It draws a graphical <em>ASCII</em> representation of the commit history structure. Prints additional lines between commits, so that the history chart is drawn correctly, and it use asterisks to show which branch the commit was on.</p><p><a href='https://www.atlassian.com/git/tutorials/git-log' target='_blank'>Know more</a></p>",
			"code": "git log --oneline --graph --decorate"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commit-without-merges",
			"title": "Git. Get all commits made, hiding the merge commits",
			"description": "<p>A merge is the result of merging 2 or more branches. The merge commits that are created by merging branches do not usually give me information and we can show the list of commits without them with this command.</p>",
			"code": "git log --oneline --no-merges"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-range",
			"title": "Git. Get commits between ranges",
			"description": "<p>Identify ranges from commit x to y</p>",
			"code": "git log master~<POSITION_NUMBER>..master~<POSITION_NUMBER>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commit-by-date",
			"title": "Git. Search the commits by date",
			"description": "<p>Search the commits by date (YYYY-MM-DD):</p><p><ul><li>Shows the commits from the given date.</li><li>Shows commits before the date.</li><li>Shows the commits after the given date.</li></ul></p>",
			"code": [
				["git log --since={<DATE>}"],
				["git log --before={<DATE>}"],
				["git log --after={<DATE>}"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-commits-of-file",
			"title": "Git. Show only the commits in which a file is involved",
			"description": "<p>It shows all the commits in which the indicated file has been modified.</p>",
			"code": "git log --oneline -- <FILE_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-regex",
			"title": "Git. Commit filter using a regular expression.",
			"description": "<p>We can look for a commit according to the message (regular expression that is repeated).</p>",
			"code": "git log --grep='<REGEX>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-info-commit",
			"title": "Git. Show the information of a commit",
			"description": "<p>This is a command-line tool that you use to view expanded details in git objects such as blobs, trees, tags, and commits.<br>In this case it shows the complete information for a commit (id or <code>SHA-1</code>, author, date and message).</p><p>There are many ways to access a commit's information:<br><ul><li>In an absolute way, referring to the code that identifies it.</li><li>Relatively, referring to the name of the branch of the last commit.</li><li>Through <code>HEAD</code>, accessing the last commit that has been made.</li><li>By his position in the git tree. See all the commits backwards from the moment we tell you, with the sign <code>^</code> we can go 1 or 3 commits backwards and with the sign <code>-</code> or <code>~</code> we can specify the number of commits backwards we want to go until we find the one we want to see.</li></ul></p>",
			"code": [
				["git show <COMMIT_ID>"],
				["git show <BRANCH_NAME>"],
				["git show HEAD"],
				["git show HEAD^"],
				["git show HEAD^^^"],
				["git show HEAD~<POSITION_NUMBER>"],
				["git show -<POSITION_NUMBER>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-with-relative-references",
			"title": "Git. Get a number of commits with their relative references",
			"description": "<p>Show branches and their commits. <br>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go <n> more common commits beyond that. When <n> is negative, display only the <reference>s given, without showing the commit ancestry tree.</p>",
			"code": "git show-branch --more=<NUMBER_COMMITS>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-date-commit",
			"title": "Git. Show date commit",
			"description": "<p>Formats the output information of a commit, showing the format of the committer date (2020-12-03 19:28:49 +0100).</p><p><ul><li><code>%ai</code>: author date, <em>ISO 8601-like</em> format</li><li><code>%ci</code>: committer date, <em>ISO 8601-like</em> format</li></ul></p>",
			"code": "git show -s --format=%ci <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "overwrite-date-commit",
			"title": "Git. Overwrite date commit",
			"description": "<p>This command change the author and committer date of the commit already created (2020-12-03 19:28:49 +0100).<br>Why change two dates? The <strong>author</strong> is the person who originally wrote the work, whereas the <strong>committer</strong> is the person who last applied the work.If we are working alone on the project, the date should be the same in both cases.</p><p>We have 2 ways to overwrite the date of a commit:</p><ul><li>We can modify the date of the <strong>last commit</strong> made with this first command.<br><a href='https://garysferrao.github.io/git/commit/date/2015/12/01/change-git-commit-date.html' target='_blank'>Know more</a></li><li>Or we can modify the date of a particular commit by filtering the list of commits <strong>by the id of the commit</strong> to be searched. The date of the first commit made to a repository can be modified using this second command.<br><a href='https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git' target='_blank'>Know more</a></li></ul><p>The second time we run any of these commands we we won't be able to create a new backup. We must delete the previous backup that already exists in <code>.git/refs/original/</code> folder or force overwriting the backup with <code>-f</code>.</p>",
			"code": [
				[
					"GIT_COMMITTER_DATE='<YYYY-MM-DDThh:mm:ss±hh:mm>' git commit --amend --date='<YYYY-MM-DDThh:mm:ss±hh:mm>' -C <COMMIT_ID>"
				],
				[
					"git filter-branch --env-filter \\",
					"'if [ $GIT_COMMIT = <COMMIT_ID> ]",
					"then",
					"    export GIT_AUTHOR_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"    export GIT_COMMITTER_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"fi'"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "git-add",
			"title": "Git. Add folders and files to staging area",
			"description": "<p>There are different areas in a git repository: the working tree, working directory or workspace, the staging area or index, the stash, the local repository and remote repository.<ul><li>The <strong>workspace</strong> contains the files you're currently working on, git will notice the changes (if you haven't previously excluded them), but it won't save them until you explicitly tell it to track them.</li><li>The <strong>staging area</strong> contains a snapshot of the content tracking the work tree. This snapshot represents the contents of the next commit.</li></ul></p><p>We use the <code>git add</code> command to add the changes in the working directory to the staging area.<br>You can add them all at the same time (3 first commands) or by indicating the file paths (last command):</p>",
			"code": [
				["git add --all"],
				["git add -A"],
				["git add ."],
				["git add <PATH/TO/FOLDER/FILE>"],
				["git add <PATH/TO/FOLDER/FILE_1> <PATH/TO/FOLDER/FILE_2>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-status-files",
			"title": "Git. Show the status of files in a git directory",
			"description": "<p>Executing this command we can see the branch in which we are and the files contained in the stage along with its state (new/modified/deleted). It also warns us of files that are untracked by git (untracked) or files with conflicts.</p>",
			"code": "git status"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-file-track",
			"title": "Git. Delete and tracking file",
			"description": "<p>The <code>git rm</code> command is used to remove individual files or a set of files from a Git repository. Git won't delete files that have unsaved changes. Its main function is to remove the tracked files from the Git index. You can think of it as the opposite of what the <code>git add</code> command does.<br>It only acts on the current branch and the removal only affects the working directory areas and the staging area. The file deletion is not stored in the repository history until a new commit is created.</p><p><strong>Why use <code>git rm</code> instead of <code>rm</code></strong><br>With the <code>rm</code> command, a Git repository will recognize when it has run over a file that is being tracked, update the working directory to reflect the removal but not the staging area. You need to run an additional <code>git add</code> command in the deleted file paths to add the changes to the staging area. The <code>git rm</code> command acts as a shortcut as it will update the working directory and the test index with the removal.</p><p>The next commands do:<ul><li><code>rm</code>: Delete the selected file and git doesn't notice this change.</li><li><code>git rm </code>: It only works if the file was already being tracked, i.e. if a <code>git add</code> and a <code>git commit</code> were executed. Delete the selected file, and add the changes to the staging area.</li><li><code>git rm --cached</code>: Removes the trace of the selected file from version control, without deleting the file, this is called an <strong>untracking file</strong>.</li></ul></p><p><a href='https://www.atlassian.com/es/git/tutorials/undoing-changes/git-rm' target='_blank'>Know more</a></p>",
			"code": [
				["rm <PATH/TO/FOLDER/FILE>"],
				["git rm <PATH/TO/FOLDER/FILE>"],
				["git rm --cached <PATH/TO/FOLDER/FILE>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-file-track",
			"title": "Git. Rename and tracking file",
			"description": "<p>This command works the same as <code>git rm</code> command.</p><p>The next commands do:<ul><li><code>mv</code>: Modify the name of a file without the git adding it to the staging area.</li><li><code>git mv</code>: Change the name of a file and have git track this change. After this, if we do a <code>git status</code> it will appear as renamed.</li></ul></p>",
			"code": [
				["mv <OLD_FILE_NAME> <NEW_FILE_NAME>"],
				["git mv <OLD_FILE_NAME> <NEW_FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-commit",
			"title": "Git. Create a commit with a message",
			"description": "<p>Commits are created to capture the status of one or more project files at a particular time. They are a <strong>changeset</strong>, snapshots or milestones in the history of a git project. Each commit contains the date it was made, the changes of each file, the author information, a message describing the content of the commit, and a unique identifier (<code>SHA-1</code>) to reference this commit.</p><p>This command only includes modifications to tracked files (those that have been added with git add at some point in their history).</p>",
			"code": "git commit -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "add-and-create-commit",
			"title": "Git. Add folders and files to staging area and create a commit",
			"description": "<p>If we've already done the first <code>git add</code> and <code>git commit</code> of a file, that is, git already knows about it, the next times we can use another command that includes both steps in a single command.</p><p>This combination immediately creates a confirmation of all prepared changes and applies an online confirmation message.<br>It is a shortcut command for advanced users that combines the options <code>-a</code> or <code>--all</code> (adds the modified or deleted files to the stage, but not the newly created ones, since they have not been reported to git for tracking) and <code>-m</code> or <code>--message</code> (with the specified message).</p><p><a href='https://www.atlassian.com/es/git/tutorials/saving-changes/git-commit' target='_blank'>Know more</a></p>",
			"code": "git commit -am '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "commit-particular-file-on-index",
			"title": "Git. Make a confirmation of only one file in the staging area",
			"description": "<p>If you have several files added to the index zone and you regret it, because you only want to commit one particular file, you can select the file and commit only the changes to it.</p>",
			"code": ["git <FILE_NAME>", "git commit -am <COMMIT_MESSAGE>"]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "overwrite-last-commit",
			"title": "Git. Overwrite the last commit",
			"description": "<p>If a commit message or file contains unclear, incorrect, sensitive, or missing information, you can correct it locally and send a new commit with a new message to GitHub. <br>Executing this command will open a text editor and ask you to edit the message and save the commit. This process will change the commit ID, creating a new commit that replaces the previous one.</p><p><a href='https://blog.kirei.io/buenas-pr%C3%A1cticas-para-los-mensajes-de-commit-en-git-a9fc43a83821' target='_blank'>Know more</a></p>",
			"code": [
				["git commit --amend"],
				["git commit --amend", "git push -f"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-commit",
			"title": "Git. Remove a commit",
			"description": "<p>The <code>git reset</code> command is a tool for undoing changes. If you run it without indicating a commit SHA, it will only remove the changes added to the staging area.</p><p>It has 3 arguments that correspond to the 3 internal mechanisms of Git state management, the confirmation tree (HEAD), the staging area, and the working directory.</p><p>When we specify the type of reset we want with one of these arguments, we indicate the previous SHA commit to all those we want to delete<ul><li><code>--mixed</code>: It is the default option, it causes the same effect as executing<code>git reset</code>. Removes the commits after the selected commit. Remove the changes from the stage area, but keep the ones from the working directory.</li><li><code>--soft</code>: Removes the commits after the selected commit, but keeps the changes added to the stage area and keeps the changes made in the working directory.</li><li><code>--hard</code>: It is the most dangerous option because you lose all the changes made. Remove the commits after the selected commit, which also removes the changes from the stage area and the working directory.</li></ul></p>",
			"code": [
				["git reset --soft <idCommit>"],
				["git reset --mixed <idCommit>"],
				["git reset --hard <idCommit>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "squashing-commits",
			"title": "Git. Squashing or merging of commits",
			"description": "<p>Delete <em>N</em> commits with the argument <code>--soft</code> and then making a commit is usually called doing <strong>squashing</strong>, as it is like compacting n commits into one.</p>",
			"code": [
				"git reset --soft master~<NUMBER_LAST_COMMITS>",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "revert-commit",
			"title": "Git. Reverses changes to a commit and creates a new one",
			"description": "<p>It allows us to create a commit that reverses the changes of the indicated reference. In other words, if we indicate a commit that added one line and deleted two, we are now creating another commit that deletes the added line and adds the two deleted ones.<br>After running this command in the console it will ask us for the message and create a new commit</p>",
			"code": "git revert <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "add-stash",
			"title": "Git. Save changes on the stash area",
			"description": "<p>Git has an area called the <strong>stash</strong> where you can temporarily store a snapshot of your changes without committing them to the repository. It’s separate from the working directory, the staging area, or the repository.<br> This functionality is useful when you’ve made changes to a branch that you aren’t ready to commit, but you need to switch to another branch. This saves your changes, that will be available from any branch in that repository and reverts the working directory to what it looked like for the latest commit.<br>Note that changes you want to stash need to be on tracked files. If you created a new file and try to stash your changes, you may get the error <em>'No local changes to save'</em>.</p><p>Snapshots are saved in the format <code>stash@{0}: BRANCH: SHA MESSAGE</code>. They will be saved with an identifier of type <code>stash@{0}</code>, where stash indicates that it is a snapshot and the number between the keys is the index of that stash. The number of the index grows as you create new snapshots and are ordered inversely, ie the smaller number will always be the last snapshot made. The branch in which the changes were made is indicated, and the identifier and message will be the same as the last commit we have in the repository.</p><p>By default, send all the files we have in the working directory and the staging area, except the untracked ones to the Stash zone. And it generates the message automatically. But there are several options that we can add to the command:<ul><li><code>--include-untracked</code> or <code>-u</code>: Add also the untracked files.</li><li><code>--all</code> or <code>-a</code>: Add also the untracked and ignored files (.gitignore).</li><li><code>--patch</code>: Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory.</li><li><code>push -m</code>: Allows us to specify a message for the commit we are sending to the stash.</li><li><code>save</code>: It is deprecated in favour of <code>push -m</code>.</li></ul></p><p><a href='https://www.freecodecamp.org/news/git-stash-explained/' target='_blank'>Know more</a></p>",
			"code": [
				["git stash"],
				["git stash -u"],
				["git stash -a"],
				["git stash --patch"],
				["git stash push -m '<STASH_MESSAGE>'"],
				["git stash save '<STASH_MESSAGE>'"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-stash-list",
			"title": "Git. Get a list of saved stash",
			"description": "<p>When you have a lot of snapshots saved, you'll want to see a list of all of them so you can select them. The message and id, which by default come from the confirmation before those changes, will help you differentiate them.<br>It is advisable to clean the stash or delete those snapshots that we do not need so as not to accumulate them.</p>",
			"code": "git stash list"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-stash",
			"title": "Git. Re-applying your stashed changes",
			"description": "<p>There are two different ways to recover the changes saved in the stash area: <code>apply</code> and <code>pop</code>.</p><p>By default, executing any of these 2 commands we can recover the top stashed element saved (the last stash: <code>stash@{0}</code>). The difference is that the option <code>apply</code>, keeps the change in the list for a possible later reuse, and <code>pop</code> after apply the change removes it from the stash stack. If during this process there are conflicts, it will not delete it, leaving it to behave exactly like <code>apply</code> option. Another way to do the same as with the <code>pop</code> option is to do it in 2 steps: <code>git stash apply</code> && <code>git stash drop</code>.</p><p>Or also, we can obtain the changes of a specific stash from out stack, indicating their index number.</p><p><a href='https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning#_git_clean' target='_blank'>Know more</a></p>",
			"code": [
				["git stash apply"],
				["git stash pop"],
				["git stash apply", "git stash drop"],
				["git stash apply stash@{<STASH_NUMBER>}"],
				["git stash apply <STASH_NUMBER>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-stash-branch",
			"title": "Git. Create a branch from a stash",
			"description": "<p>This is a nice shortcut to recover stashed work easily and work on it in a new branch. This command creates a new branch with the latest stash (<code>stash@{0}</code>), and then deletes the latest stash (like <code>git stash pop</code>). If you need a particular stash you can specify the stash id. This will be useful when you run into conflicts after you’ve applied the stash to the latest version of your branch.</p><p><a href='https://www.freecodecamp.org/news/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a/' target='_blank'>Know more</a></p>",
			"code": [
				["git stash branch <BRANCH_NAME>"],
				["git stash branch <BRANCH_NAME> stash@{<STASH_NUMBER>}"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-stash",
			"title": "Git. Show the stash diffs",
			"description": "<p>The <code>show</code> option of the stash command gives a very brief summary of the changes made to the files. It shows in one line the path and name of the file and the number of deleted lines.</p><p>Default, shows the information of the last stash (<code>stash@{0}</code>), but we can indicate an index number to see some other.</p><p>If we want to go deeper and see all the changes of each line of the file in the terminal editor we can use the option <code>-p</code>.</p><p><a href='https://howto.lintel.in/how-to-see-stashed-changes-using-git-stash/' target='_blank'>Know more</a></p>",
			"code": [
				["git stash show"],
				["git stash show stash@{<STASH_NUMBER>}"],
				["git stash show -p"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-stash",
			"title": "Git. Remove stash",
			"description": "<p>There are two different ways to remove the changes saved in the stash area: <code>drop</code> and <code> clear</code>.</p><p>We can remove the top stashed element saved (the last stash: <code>stash@{0}</code>) with <code>drop</code> or if you no longer need a particular stash, select it by their index number.</p><p>But, if what we want is to clean the storage area completely, the <code>clear</code> option deletes all the stashes list. <strong>IMPORTANT WARNING</strong>: With <code>clear</code>option those states will then be subject to pruning, and may be impossible to recover. Use both of them with caution, it maybe is difficult to revert the once deleted stashes.</p><p>To confirm if all cleared, obtain again the stashes list with <code>git stash list</code> command.</p><p><a href='https://kolosek.com/git-stash/' target='_blank'>Know more</a></p>",
			"code": [
				["git stash drop"],
				["git stash drop stash@{<STASH_NUMBER>}"],
				["git stash drop <STASH_NUMBER>"],
				["git stash clear"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "exit-without-save",
			"title": "Git. Exit without save from the text window",
			"description": "<p>If you're inside the <strong>Vi</strong> editor (text editor created for UNIX, whose improved version is called <strong>Vim</strong>) and you want to just come out from the text window without save the changes, typing the command and press <em>'enter'</em>.</p>",
			"code": ":q!"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "exit-and-save",
			"title": "Git. Exit and save from the text window",
			"description": "<p>If you're inside the <strong>Vi</strong> editor (text editor created for UNIX, whose improved version is called <strong>Vim</strong>) and you want come out from the text window and save the changes, typing the command and press <em>'enter'</em>.</p>",
			"code": ":wq"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "reflog",
			"title": "Git. View reference log (reflog)",
			"description": "<p>Before talking about the reference journal, it should be remembered that <code>HEAD</code> is a reference (that is, a pointer) that points to the most recent commit of the current branch. There is a record of all the references taken by the <code>HEAD</code> pointer in git called reflog (reference record shortcut). It is a record that will store all commits where the pointer passes, for example, it will be able to save branch changes or the addition of a commit.</p>",
			"code": "git reflog"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "reflog-remove",
			"title": "Git. Prune all references with garbage collection and reclaim space",
			"description": "<p>The <code>expire</code> subcommand cleans up old or unreachable reflog entries. It has potential for data loss and is not typically used by end users, but used by git internally. By default, the reflog expiration date is set to 90 days. An expire time can be specified by passing a command line argument or by setting a git configuration name.</p>",
			"code": [
				"rm -rf .git/refs/original/",
				"git reflog expire --expire=now --all",
				"git gc --aggressive --prune=now"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches",
			"title": "Git. Get all branches",
			"description": "<p>Sometimes it is necessary to know what branches exist in a remote repository in order to determine the names of the available branches.<br> With this command you can list both types of branches: remote and local. The current branch will be highlighted in color and marked an asterisk <em>'*'</em>.</p>",
			"code": [["git branch --all"], ["git branch -a"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches-local",
			"title": "Git. Get all local branches",
			"description": "<p>A local branch is one whose full name starts with <code>refs/heads/</code>, the <code>git branch</code> command strips off this part to make it easier.</p><p>It seems that with git there is always more than one way to do the same thing:</p>",
			"code": [["git branch"], ["git branch --list"], ["git branch -l"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches-remotes",
			"title": "Git. Get all remote branches",
			"description": "<p>A remote-tracking branch is one whose full name starts with <code>refs/remotes/</code>, this command remove this part to make it easier.</p>",
			"code": [["git branch --remotes"], ["git branch -r"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "summary-branches",
			"title": "Git. Summary branches",
			"description": "<p>It shows us a summary of all the branches that are in a project together with their last modifications or commits.</p>",
			"code": "git show-branch"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-branch",
			"title": "Git. Create a new branch",
			"description": "<p>You can create a new branch while in another and move to it later.</p>",
			"code": "git branch <NEW_BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "checkout-branch-path",
			"title": "Git. Checkout branch/path",
			"description": "<p>With <code>--</code> is a way to tell Git to treat what follows <code>checkout</code> as a file and not as a branch. Suppose that you had both a file and a branch called <em>stuff</em>. Then the following command would seem ambiguous <code>git checkout stuff</code>,  because it is not clear whether you are asking to checkout a file or a branch. When you use it, it explicitly tell Git to checkout a file by that name/path</p><p>Note that in <code>git checkout &lt;NAME&gt;</code> is really meant for branches, but Git syntax is relaxed, and if Git can't find a branch, then it will look for a file.<br>This command made: <ul><li>If it's local branch or remote branch tracked, switch to it.</li><li>If it's a tracked path of a file, reset it, i.e. delete the unsaved changes from the working directory.</li><li>If it's a remote branch, create a tracking branch and switch to it.</li></ul></p><p>So in this case the following commands allow you to move a local branch or download it from the remote and reset a file:</p>",
			"code": [
				["git checkout <BRANCH_NAME>"],
				["git checkout -- <FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "move-to-branch",
			"title": "Git. Move to the branch",
			"description": "<p>When you try move to a local branch that does not exist, this command will search to see if there is a remote-tracking branch with a similar name. If so, it will create the local branch and set it up to track the remote-tracking branch.</p>",
			"code": "git checkout <BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-and-move-to-branch",
			"title": "Git. Create and move to branch",
			"description": "<p>You must use a separate branch for each function or issue you work on. With this command you make 2 steps at the same time create and move to the branch so that all changes you make are applied to it. The <code>-b</code> flag tells git to create it if it doesn't already exist, otherwise, it is reset. That is to say, the branch is not reset/created unless <code>git checkout</code> is successful.</p>",
			"code": [
				["git checkout -B <NEW_BRANCH_NAME>"],
				["git checkout -b <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "extract-files-from-staging-area",
			"title": "Git. Extract files from the staging area",
			"description": "<p>If I have already added the file with a <code>git add</code> to the index zone but don't want to commit it yet, and want to remove it from this zone, these are some ways to solve it:<ul><li><code>git reset <FILE_NAME></code>: If changes have been made and added to the staging area</li><li><code>git rm --cached <FILE_NAME></code>: If I have not launched a commit yet, and therefore the HEAD pointer has not been created</li><li><code>git reset HEAD <FILE_NAME></code>: If I've already launched my first commit, i.e. there's a HEAD pointer. Git moves between the commits always pointing to the last one created.</li></ul></p>",
			"code": [
				["git reset <FILE_NAME>"],
				["git rm --cached <FILE_NAME>"],
				["git reset HEAD <FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-current-branch",
			"title": "Git. Rename current branch",
			"description": "<p>It is possible that at some time, as with the commit messages, you may want to rename a branch.<br>With this command you can rename the local branch you are working on.</p><p>It has  optional parametters: <ul><li><code>--move</code> or <code>-m</code>: Move/rename a branch and the corresponding reflog.</li><li><code>-M</code>: It is a shortcut of <code>--delete --force</code></li></ul></p><p><a href='https://git-scm.com/docs/git-branch' target='_blank'>Know more</a></p>",
			"code": [
				["git branch -m <NEW_BRANCH_NAME>"],
				["git branch -M <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-local-branch",
			"title": "Git. Rename a local branch",
			"description": "<p>If you want to rename a local branch while pointed to any branch.</p>",
			"code": [["git branch -m <OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-remote-branch",
			"title": "Git. Rename a remote branch",
			"description": "<p>You are collaborating on a project with a group of people, and you have defined a naming convention for git branches. You created a new branch , pushed the changes to the remote repository, and realized that your branch name was incorrect. Luckily, git allows you to rename the branch very easily using the next command.</p><p><a href='https://linuxize.com/post/how-to-rename-local-and-remote-git-branch/' target='_blank'>Know more</a></p>",
			"code": [
				[
					"git checkout <OLD_BRANCH_NAME>",
					"git branch -m <NEW_BRANCH_NAME>",
					"git push origin -u <NEW_BRANCH_NAME>",
					"git push origin --delete <OLD_BRANCH_NAME>"
				],
				["git push origin :<OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "upload-local-branch",
			"title": "Git. Send the local branch to remote repository",
			"description": "<p>It is recommended to send the new branch to the remote repository (<code>ORIGIN</code>), since this acts as backup and, when collaborating with other developers, it allows them access to see the commits made in the new branch. The <code>-u</code> flag adds it as a remote tracking branch.</p>",
			"code": [
				["git branch --set-upstream-to origin/<OTHER_BRANCH_NAME>"],
				["git push origin -u <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-branch",
			"title": "Git. Remove a branch",
			"description": "<p>To delete a branch from git repository you must not be positioned in it.</p>",
			"code": [
				["git branch -D <BRANCH_NAME>"],
				["git branch -d <BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "merge",
			"title": "Git. Merge branch",
			"description": "<p>The fusion is Git's way of putting a forked history back together again. The <code>git merge</code> command lets you take the independent lines of development created by <code>git branch</code> command and integrate them into a single branch.<br>It takes two confirmation pointers from the ends of each branch and combines them into the current branch, generating a new merge commit. However, if git find data that has been changed in both histories, it will be unable to automatically combine them. In that case, a version control conflict is created and Git will ask for user intervention to continue.</p><p>Before performing a merge there are a couple of preparation steps to take to ensure the merge goes smoothly: <ul><li><strong>Confirm the receiving branch:</strong> Make sure<code>HEAD</code> points to the correct branch with the <code>git status</code> command. If needed, execute <code>git checkout</code> to switch to the receiving branch.</li><li><strong>Fetch latest remote commits: </strong> Make sure the receiving branch and the merging branch are updated with the latest remote changes. Execute <code>git fetch</code> to pull the latest remote commits. Once the fetch is completed ensure the master branch has the latest updates by executing <code>git pull</code>.</li></ul></p><p>This means that <code>git merge</code> is often used in conjunction with <code>git checkout</code> for selecting the current branch and <code>git branch -d</code> for deleting the obsolete target branch.</p><p>If the two branches you're trying to merge both changed the same part of the same file, Git won't be able to figure out which version to use. When such a situation occurs, it stops right before the merge commit so that you can resolve the conflicts manually. When Git encounters a conflict during a merge, It will edit the content of the affected files with visual indicators that mark both sides of the conflicted content <code><<<<<<<</code> <code> =======</code> <code>>>>>>>></code>. The content before the <code>=======</code> marker is the receiving branch and the part after is the merging branch.Once you've identified conflicting sections, you can go in and fix up the merge to your liking. When you're ready to finish the merge, all you have to do is run <code>git add</code> on the conflicted file(s) to tell Git they're resolved. Then, you run a normal <code>git commit</code> to generate the merge commit.</p><p><a href='https://www.atlassian.com/es/git/tutorials/using-branches/git-merge' target='_blank'>Know more</a></p>",
			"code": [
				["git merge <BRANCH_NAME>"],
				["git merge --continue"],
				["git merge --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rebase",
			"title": "Git. Rebase",
			"description": "<p>At Git we have two ways of integrating changes from one branch to another: the fusion (merge) and the reorganization (rebase).</p>Git <code>rebase</code> allows us to modify the history of Git using a reference point. It captures all confirmed changes from the branch we're in and applies them to the one we're indicating you about, that is, it is able to recognize that commits are not on the timeline for that reference point and apply them on top of the reference point, this is what we call in Git <strong>rebasing</strong>.<br>In contrast to the merge, this generates a perfectly linear project history, being able to go from the end of the branch to the start of the project without finding any bifurcation.</p><p>It's very important to understand that, even though the branch looks the same, it is made up of entirely new commits, which changes the history of Git. This implies that these commits are being recreated with the same message and content, which can lead to <strong>conflicts</strong> when applying them to the new branch if it has new changes.<br>If this happens, they have to be resolved as they occur and are considered modifications of the commit itself. This allows us to delete, reorder, merge or change the commit message before applying them. When you have the changes fixed, you will have to ask the command to continue with the <code>--continue</code> option to apply the next commit.<br>At any time during <code>rebase</code> if you change your mind you can reject the whole process with the <code>--abort</code> option.</p>",
			"code": [
				["git rebase <BRANCH_NAME>"],
				["git rebase --continue"],
				["git rebase --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "cherry-pick",
			"title": "Git. Cherry-pick: Copy and paste commits",
			"description": "<p>It may happen that, at some point, we want to apply some of the changes we have made in another branch without having to make a full merge. The cherry-pick command allows  allows you to <em>'copy'</em> one or more commits from one branch and <em>'paste'</em> them into another branch. Before using, you must have a clean <strong>working directory</strong> and <strong>staging area</strong>. </p><p>By default cherry-pick keeps the original commit message, so the <code>-x</code> option may be useful to modify the message to add a reference to the original commit, so that you know where you've got this commit from. Other interesting options are <code>-e</code>, which allows you to edit the commit message instead of using the original one and the <code>-n</code> option which will apply the changes but not make any commits.</p><p>As with the <code>merge</code> and <code>rebase</code> commands, after resolving the conflicts, we can indicate to continue applying the changes with the option <code>--continue</code> or reject the process completely with the option <code>--abort</code>.</p><p><a href='https://www.runroom.com/realworld/seleccionando-commits-cherry-pick' target='_blank'>Know more</a></p>",
			"code": [
				["git cherry-pick"],
				["git cherry-pick <COMMIT_ID>"],
				["git cherry-pick -x"],
				["git cherry-pick -e"],
				["git cherry-pick -n"],
				["git cherry-pick --continue"],
				["git cherry-pick --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "diff",
			"title": "Git. Comparing changes with git diff",
			"description": "<p>See what changes have been made to the code (- is what has been deleted and + is what has been added)</p><p>The next tool online can help you. DiffMerge is an application to visually compare and merge files on Windows, OS X and Linux: <a href='http://sourcegear.com/diffmerge/' target='_blank'>http://sourcegear.com/diffmerge/</a></p><p>Compare the changes that have been made to the code of each commit</p><p><a href='https://www.atlassian.com/git/tutorials/saving-changes/git-diff' target='_blank'>Know more</a></p>",
			"code": [["git diff"], ["git diff <idCommit1> <idCommit2>"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "mark-conflicts-resolved",
			"title": "Git. Mark that the conflict is resolved",
			"description": "<p>Steps to follow after resolving a conflict in the files: <ul><li>Add all files to the index zone</li><li>View the status of the files (modified/deleted/added)</li><li>Make a commitment to change</li></ul></p>",
			"code": [
				"git add .",
				"git status",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-tags",
			"title": "Git. Get all tags made",
			"description": "<p>Get a simple list of the tags, if you want to make sure they exist and what their version numbers are.</p>",
			"code": [["git tag --list"], ["git tag -l"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-tag",
			"title": "Git. Create a new tag",
			"description": "<p>In software development, git tags represent a version of our code at a given moment in time. Unlike branches, tags are not mutable y always point to the same commit, them so people generally use them to mark important points in git history (as the release points v1.0, v2.0 and so on).</p><p>The <strong>Semantic Versioning</strong> use a version format based on 3 integers separated by points: <em>X.Y.Z</em> (<em>Major.Minor.Patch</em>). This would be translated to gitflow branch structure as <em>release.feature.bug</em>.<br>The developer is the responsible for communicating the status of their software publishing this number.</p><p><a href='https://semver.org/' target='_blank'>Know more</a></p>",
			"code": "git tag -a '<TAG_VERSION>' -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-local-tag",
			"title": "Git. Remove a local tag",
			"description": "",
			"code": "git tag -d <TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-tag-remote",
			"title": "Git. Remove a remote tag",
			"description": "",
			"code": "git push --delete origin <TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-and-upload-tag",
			"title": "Git. Remove local and remote tag",
			"description": "<p>When you want rename or remove a tag and you have already pushed it to a remote repository (eg. GitHub) then you’ll also need to update the remote references right after renaming or deleting the tag from your local repo.</p><p>Here are two alternatives for remove a tag on the local and remote repository:<ul><li>Delete the local tag and overwrite this change by referring to the name of the deleted tag in the remote repository.</li><li>Or do the process in reverse, delete it first the tag in the remote repository and then in the local repository.</li></ul></p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Know more</a></p>",
			"code": [
				[
					"git tag -d <TAG_VERSION>",
					"git push origin :refs/tags/<TAG_VERSION>"
				],
				[
					"git push --delete origin <TAG_VERSION>",
					"git tag -d <TAG_VERSION>"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-local-tag",
			"title": "Git. Rename a local tag",
			"description": "<p>If you use tags in your projects, you probably have encountered some issue that forced you to remove the tag: <ul><li>There was a change that had to be shipped with this release and you forgot all about it.</li><li>There’s some debugging code that wasn’t supposed to be included with this release.</li><li>There’s a really obvious typo that everyone will notice right away.</li></ul></p><p>If you have not yet uploaded the tag to the remote repository, you can rename the tag with the following command:</p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Know more</a></p>",
			"code": "git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-and-upload-tag",
			"title": "Git. Rename a tag and push it",
			"description": "<p>If you have made a mistake and need to rename a tag and update it in the remote repository, you should follow these steps:<ol><li>Rename the local tag.</li><li>Remove the old tag so that git knows about the change.</li><li>Tell the remote git repository that you've removed the old tag.</li><li>Update remote repository tags to upload new tag.</li></ol></p>",
			"code": [
				"git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>",
				"git tag -d <OLD_TAG_VERSION>",
				"git push origin :refs/tags/<OLD_TAG_VERSION>",
				"git push --tags"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "update-remote-repository",
			"title": "Git. Update remote repository",
			"description": "<p>This is highly desirable when working in a team workflow where remote branches are removed after merging with master or are left with obsolete tags.<br>In this case, you will want to remove references to branches or tags that no longer exist on the remote control by connecting to the remote control and getting the last remote status before pruning. It's essentially a combination of commands:</p>",
			"code": "git fetch --all && git remote prune"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "update-local-tags",
			"title": "Git. Update local tags",
			"description": "<p>If your project is open source, you will probably have to update the status of your local repository from time to time, since other people may have removed or renamed some tags while you were working and you now have obsolete local tags.<br> This command prunes the tags that no longer exist in the remote repository but in your local repository.</p>",
			"code": "git pull --prune --tags"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "",
			"title": "Git. ",
			"description": "",
			"code": ""
		}
	],
	"gitFlow": [
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "create-gitflow-repository",
			"title": "Git Flow. Initialize repository",
			"description": "<p>Git-flow is a <strong>workflow</strong> applied to a Git repository.<br> Every project usually has at least 2 infinite branches: <code>develop</code> containing the code under development and <code>master</code> containing each of the stable versions to include in production.<br>  This branching model, designed around project releases, also has a set of support branches, which are time-limited and eventually removed. These branches allow teamwork, for the creation of new features (<code>feature</code>), bug resolution in development (<code>bugfix</code>), urgent bug resolution in production (<code>hotfix</code>) and the release of different versions (<code>release</code>). </p><p>Start using it by initializing it inside an existing git repository with <code>git flow init</code>. At first, Git-flow needs to be initialized to customize the project configuration, you will have to answer some questions about the naming conventions of your branches, at this point you can rename the branches if you wish, although it is recommended to use the default values (<code>feature</code>, <code>release</code>, <code>hotfix</code> and <code>support</code>).</p>",
			"code": [
				["git flow init"],
				[
					"git flow init",
					"",
					"Initialized empty Git repository in ~/project/.git/",
					"No branches exist yet. Base branches must be created now.",
					"Branch name for production releases: [master]",
					"Branch name for \"next release\" development: [develop]",
					"",
					"How to name your supporting branch prefixes?",
					"Feature branches? [feature/]",
					"Release branches? [release/]",
					"Hotfix branches? [hotfix/]",
					"Support branches? [support/]",
					"",
					"git branch",
					"* develop",
					"master"
				]
			]
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-start",
			"title": "Git Flow. Start a new feature",
			"description": "<p>When a new functionality or feature of the project is to be developed, a new branch called <code>feature</code> is created. This type of branches are born from the <code>develop</code> branch and once development is finished, they are incorporated back to it. </p><p>The following command is a shortcut, which includes the execution of several commands: <ul><li><code>git checkout develop</code></li><li><code>git branch feature/&lt;BRANCH_NAME&gt;</code></li><li><code>git checkout feature/&lt;BRANCH_NAME&gt;</code></li></ul></p>",
			"code": [["git flow feature start <FEATURE_NAME>"],["git checkout -b feature/<FEATURE_NAME> develop"]]
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-list",
			"title": "Git Flow. Get a feature list",
			"description": "<p>You can view a list of the <code>feature</code> branches already created in the local repository using the following command.</p>",
			"code": "git flow feature list"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-publish",
			"title": "Git Flow. Publish a feature",
			"description": "<p>Normally the <code>feature</code> exists only in the local repositories of the developers and not in the source repository. If you want to share this branch with some members of your team in order to do collaborative development, you would have to publish the <code>feature</code> on the remote server so that it can be used by other users.</p>",
			"code": "git flow feature publish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-pull",
			"title": "Git Flow. Getting a published feature",
			"description": "<p>When more than one person works on a <code>feature</code> at the same time, it will be published by your teammates, and you will be able to develop on the same branch with them.</p><p>If this is the first time you participate in the project, you will first have to clone repository using <code>git clone &lt;URL&gt;</code> to have a copy on your computer (local repository), then initialize Gitflow with <code>git flow init</code> and download the <code>master</code> and <code>develop</code> branches with the commands <code>git checkout master</code> and <code>git checkout develop</code>.</p><p>If you are already participating in the project you can skip the above steps and use the following command to download a <code>feature</code> and to make sure that the local repository is synchronized with the remote one.</p>",
			"code": "git flow feature pull origin <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-track",
			"title": "Git Flow. Track a published feature",
			"description": "<p>Say you have created a new feature with <code>git flow feature start &lt;FEATURE_NAME&gt;</code>, and published it to the remote repository with <code>git flow feature publish &lt;FEATURE_NAME&gt;</code> so that other members of your team can collaborate with you using <code>git flow feature pull &lt;FEATURE_NAME&gt;</code> to download it. This creates a new branch in your local repository, based on the remote branch, however this does not set it up so that changes made to it, are tracked by the remote branch, so it now has to be tracked manually.</p><p>With the following command <code>git flow feature track &lt;FEATURE_NAME&gt;</code>, your co-worker, can download the <code>feature</code> and also track changes others make to the one published in the source repository. </p><p>To illustrate the collaborative aspect with a branch of a new feature, using the pull request aspect of GitHub that facilitates the code review and discussion part, we put ourselves in the following situation:<ul><li>Several people work on the same feature and as changes are committed, they are submitted to GitHub (or once at the end of development if preferred). </li><li>When the feature is complete, a pull request is opened on GitHub comparing <code>develop</code> and with the branch.</li><li>The team reviews the pull request and makes comments.</li><li>Any changes to the pull request are made to the feature branch. </li><li>Once all changes are incorporated into the feature branch it is terminated:<code>git flow feature finish &lt;FEATURE_NAME&gt;</code>.</li><li><li>The <code>develop</code> branch is sent to GitHub (GitHub will automatically mark the pull request as closed/merged when this happens).</li></ul><p>However, that leaves the problem of closing that branch, whoever runs first <code>git flow feature finish &lt;FEATURE_NAME&gt;</code> will have the luxury of deleting your local branch, but anyone else who has checked out the branch will have to do it manually if they wish. You can use <code>git fetch --prune</code> or a simple <code>git fetch</code> to remove your branch if it has already been removed on the remote. </p><p>If you have already downloaded the branch and now you need to track it, all you have to do would be for your existing branch to trace back to the previous branch with <code>git branch -u origin feature/&lt;FEATURE_NAME&gt;</code> or <code>git branch --set-upstream-to origin feature/&lt;FEATURE_NAME&gt;</code></code></p><p>In general, it would be best to start using <code>git flow feature track &lt;FEATURE_NAME&gt;</code> and then keep your branch updated with <code>git flow feature pull origin &lt;FEATURE_NAME&gt;</code>.</p><p><a href='https://stackoverflow.com/questions/18412750/why-doesnt-git-flow-feature-pull-track' target='_blank'>Know more</a></p>",
			"code": "git flow feature track <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-finish",
			"title": "Git Flow. Finish up a feature",
			"description": "<p>When development of the new feature is complete, it should be merged with <code>develop</code> and removed from the local repository and the remote repository if it was uploaded.</p><p>The following command performs the following commands: <ul><li><code>git checkout develop</code></li><li><code>git merge feature/&lt;FEATURE_NAME&gt;</code></li><li><code>git branch -D &lt;FEATURE_NAME&gt;</code></li></li><li><code>git push origin :&lt;FEATURE_NAME&gt;</code></li></ul></p>",
			"code": "git flow feature finish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-bugfix-start",
			"title": "Git Flow. Start a bugfix",
			"description": "<p>During the development of the project you may encounter errors in one of the branches of the repository. To fix them we have 2 different types of branches depending on the place these errors occupy in the git workflow: <code>bugfix</code> and <code>hotfix</code>.</p><p>The term <code>bugfix</code> or <strong>bug fixes</strong> are used when a problem is found during the development phase, to fix bugs from a previous feature or development omissions.<br> These types of branches are created from <code>develop</code> and merged back into <code>develop</code> upon completion. </p><p>The following command is the same as running: <ul><li><code>git checkout develop</code></li><li><code>git branch bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git checkout bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>",
			"code": "git flow bugfix start <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-bugfix-finish",
			"title": "Git Flow. Finish a bugfix",
			"description": "<p>The <code>bugfix</code> branches are temporary branches, which once the bugs are resolved,are removed after merging with the <code>develop</code> branch..</p><p>The following command is the same as running: <ul><li><code>git checkout develop</code></li><li><code>git merge bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git branch -D bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p></p>",
			"code": "git flow bugfix finish <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-start",
			"title": "Git Flow. Start a release",
			"description": "<p>To prepare our application for production there are some branches called <code>release</code>. In some teams, these branches are the ones that are dumped on the pre-production servers to do the final testing: minor bugs are corrected, the interface is polished, the layout is adjusted...the final tuning of the application is done before releasing the final version. </p><p>The name of the <code>release</code> is a figure of 3 integers separated by dots that increase numerically in increments of 1. This number follows the nomenclature of the <a href='https://semver.org/' target='_blank'>semantic versioning</a>, <code>X. Y.Z</code>, where <code>X</code> is the 'major' version (incorporation of multiple changes that are no longer compatible with the public API), <code>Y</code> is the 'minor' version (incorporation of a feature), and <code>Z</code> is the 'patch' version (bug fixes compatible with the previous version). </br> Therefore, the <code>release</code> number would be the first one, <code>X</code>.</p><p>The following command creates a release branch from the <code>develop</code> branch.<br>Optionally, you can supply the id of a commit located in <code>develop</code> to start the release from the commit.</p><p><a href='https://aprendegit.com/git-flow-release-branches/' target='_blank'>Know more</a></p>",
			"code": "git flow release start <VERSION_NUMBER> <[BASE]>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-list",
			"title": "Git Flow. Get a release list",
			"description": "<p>You can see a lists all the current release branches created on the local repository.</p>",
			"code": "git flow release list"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-publish",
			"title": "Git Flow. Publish a release",
			"description": "<p>If you are working in a team and another of your colleagues must review the code before the release of a new version, it is advisable to publish the release branch after creating it to allow other developers to make release commits.</p>",
			"code": "git flow release publish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-track",
			"title": "Git Flow. Track a release",
			"description": "<p>You can track the changes a release published on remote repository.</p>",
			"code": "git flow release track <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-finish",
			"title": "Git Flow. Finish up a release",
			"description": "<p>Once the <code>release</code> branch is created, we start the fix and debug process, the necessary commits are performed and when we have finished fixing all the bugs, we are ready to move our project to production and remove the branch.</p><p>Terminating a release is one of the big steps in creating git branches. The following command performs several actions: it merges the version branch with <code>master</code>, tags the version with its name, merges the version back with <code>develop</code> and deletes the version branch.</p><p>When we run this command git-flow will ask us to enter 3 messages: <ol><li>The merge commit message as a result of incorporating the changes in <code>master</code>. </li><li>The message that git-flow will put to the tag it is going to create to identify this version.</li><li>And finally the merge commit message as a result of incorporating the branch to <code>develop</code>.</li></ol></p><p>The execution of this command which can be summarized in the following commands: <ul><li><code>git checkout master</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git tag v&lt;VERSION_NUMBER&gt;</code></li><li><code>git checkout develop</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git branch -d release/&lt;VERSION_NUMBER&gt;</code></li></ul></p>",
			"code": "git flow release finish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-tags-push-single",
			"title": "Git Flow. Push a single tag",
			"description": "<p>After finishing the release branch, don't forget to add the tags to the remote repository. This command will push a single tag to the remote repository.</p>",
			"code": "git push <REPO_NAME> <TAG_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-tags-push",
			"title": "Git Flow. Push all the tags",
			"description": "<p>You can add all tags to the remote repository with a single command. This way is not recommended because it is common for developers to have old or 'bad' tags in their local repositories that have no need to be in the remote one, so it is advised to only explicitly push one tag and not all its tags at once.</p>",
			"code": "git push <REPO_NAME> --tags"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-hotfix-start",
			"title": "Git Flow. Start a hotfix",
			"description": "<p>Just as there are branches to resolve bugs that we have encountered during the development process, there are other types of branches. These branches, called <code>hotfix</code>, are created to act immediately on an undesired state of a live production version, they are used to fix urgent bugs or omissions that cannot wait for the release of the next version. <br>The lifetime of this branch is temporary, it is created from <code>master</code>, merged back into <code>master</code> and removed after the merge.</p><p>The <code>hotfix</code> name is a figure of 3 whole numbers separated by dots that increment numerically in increments of 1. This number follows the <a href='https://semver.org/' target='_blank'>semantic versioning</a> nomenclature, <code>X.Y.Z</code>, where X is the 'major' version (incorporation of multiple changes that are no longer compatible with the public API), <code>Y</code> is the 'minor' version (incorporation of a feature), and <code>Z</code> is the 'patch' version (bug fixes compatible with the previous version). </br> Therefore, the <code>hotfix</code> number would be the third and last one, <code>Z</code>.</p><p></p><p>Optionally, you can specify a base name, the id of a commit, from which to create the branch.</p>",
			"code": "git flow hotfix start <VERSION_NUMBER> <[BASE_NAME]>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-hotfix-finish",
			"title": "Git Flow. Finish a hotfix",
			"description": "<p>When all fixes have been made to a <code>hotfix</code> branch, the following command must be performed to finalize the branch. This process merges the branch back to <code>develop</code> and <code>master</code>, creates a tag with the version number of the <code>hotfix</code> and deletes that branch, since its existence is temporary.</p>",
			"code": "git flow hotfix finish <VERSION_NUMBER>"
		}
	]
}
