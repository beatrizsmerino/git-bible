{
	"git": [
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-git-version",
			"title": "Git. Obtener la versión de Git",
			"description": "<p>Antes de instalar Git, es conveniente comprobar si ya lo tienes instalado mediante el siguiente comando, que te devolverá el número de versión instalado en tu ordenador. Si no es así, sigue los pasos descritos en este <a href='https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git' target='_blank'>enlace</a> en función de tu sistema operativo.</p>",
			"code": "git --version"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-git-repository",
			"title": "Git. Inicializar un repositorio Git",
			"description": "<p>Un repositorio Git es un almacén virtual, te permite guardar versiones del código de tu proyecto a las que puedes acceder siempre que lo necesites. El siguiente comando, utilizado solo una vez durante la configuración inicial de un nuevo repositorio, creará un nuevo subdirectorio <code>.git</code> en tu directorio de trabajo actual y una nueva rama <code>master</code>.</p><p><a href='https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init' target='_blank'>Saber más</a></p>",
			"code": "git init"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-configuration",
			"title": "Git. Mostrar la configuración",
			"description": "<p>Para visualizar nuestra configuración actual debemos saber que toda la configuración se guarda en el archivo <code>.gitconfig</code>, que se encuentra en: si eres <strong>Linux</strong> en el usuario <code>HOME</code> o si estás en <strong>Windows</strong> en <code>C:Users</code> o si eres <strong>Mac</strong> escribiendo en la <strong>consola</strong> <code>git config --list --show-origin</code>.</p>",
			"code": [
				[
					"git config -l"
				],
				[
					"git config --list"
				],
				[
					"git config --global --list"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "config-user-name-email",
			"title": "Git. Configurar el nombre y el correo electrónico del usuario",
			"description": "<p>Git es un <strong>sistema de control de versiones distribuido</strong> que está siendo utilizado por la mayoría de los equipos de software hoy en día. Lo primero que debes hacer después de instalar Git en tu sistema es configurar tu nombre de usuario y dirección de correo electrónico de Git. Git asocia tu identidad con cada 'commit' que haces.</p><p>Git te permite establecer un nombre de usuario y una dirección de correo electrónico globales y por proyecto. Si modificas el nombre y el correo durante el desarrollo del repositorio, los cambios solo afectan a futuros 'commits', el nombre y el correo electrónico asociados a los 'commits' que hiciste antes del cambio no se ven afectados.</p><p>Puedes establecer o cambiar tu identidad Git usando el siguiente comando.</p>",
			"code": [
				[
					"git config --global user.name <USER_NAME>"
				],
				[
					"git config --global user.email <USER_EMAIL>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "config-code-editor",
			"title": "Git. Añadir o editar el editor por defecto",
			"description": "<p>Cuando creas un 'commit' de Git con <code>git commit -a</code>, el editor por defecto que se abrirá es <strong>Vim</strong>. Esto puede ser muy confuso para la gente, ya que Vim no es un editor fácil si nunca has trabajado con él previamente.</p><p>Hay muchas formas de hacerlo: a través del terminal con el siguiente comando, abriendo y editando el archivo <code>.gitconfig</code>...</p><p>En <strong>OSX</strong> para establecer <strong>Visual Studio Code</strong> como editor global de Git, hay que hacer los siguientes pasos:<ul><li>Abrir el editor y pulsar a la vez las teclas <code>Shift + Command + P</code>.</li><li>Escribir la palabra <code>Code</code> en la ventana emergente y hacer clic en <code>Shell Command: Install 'code' command in PATH</code> para hacer la instalación.</li><li>Y luego usa el segundo bloque de comandos de esta descripción, para ejecutar las 2 líneas en tu terminal. Esto lo define en su configuración como el editor global de Git y abre este mismo archivo de configuración con él.</li></ul></p><p><a href='https://stackoverflow.com/questions/34746045/set-visual-studio-code-to-be-global-git-editor-on-osx' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git config --global core.editor <PATH/TO/EDITOR_CODE>"
				],
				[
					"git config --global core.editor 'code --wait'",
					"git config --global -e"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "open-file-with-editor",
			"title": "Git. Abrir un proyecto o archivo con el editor",
			"description": "<p>A través del terminal puedes abrir un archivo con tu editor de código preferido. Estos comandos abren un archivo con los editores Sublime Text, Atom y Visual Studio Code.</p>",
			"code": [
				[
					"subl <PATH/TO/FOLDER/FILE>"
				],
				[
					"atom <PATH/TO/FOLDER/FILE>"
				],
				[
					"code <PATH/TO/FOLDER/FILE>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "change-autor-email-last-commits",
			"title": "Git. Cambiar el nombre y el correo electrónico del autor del último 'commit'",
			"description": "<p>Si te has equivocado y has hecho tu 'commit' con otro nombre o correo electrónico, puedes sobrescribir la información del autor solo del último 'commit' con este comando.</p>",
			"code": "git commit --amend --author='<USER_NAME> <USER_EMAIL>'"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "change-autor-email-commits",
			"title": "Git. Cambiar el nombre y el correo electrónico del autor después de hacer un 'commit'",
			"description": "<p>Si te has equivocado y has hecho varios 'commits' con otro nombre o email de usuario, puedes sobrescribir la información de autor de todos los 'commits' con el siguiente comando.</p><p>Ten mucho cuidado si estos 'commits' han sido subidos previamente al repositorio remoto y si hay más gente colaborando en el repositorio. Si este es el caso, es importante comunicarlo antes de hacer este comando, ya que también tendrás que sobrescribir los cambios en el repositorio remoto con <code>git push -f</code> y los demás colaboradores tendrán que actualizar su repositorio local con <code>git pull -f</code>. Este tipo de cambios es mejor hacerlos sin tener ningún cambio guardado en el <strong>área de preparación</strong> o en el <strong>directorio de trabajo</strong>.</p><p><a href='https://stackoverflow.com/questions/750172/how-to-change-the-author-and-committer-name-and-e-mail-of-multiple-commits-in-gi' target='_target'>Saber más</p>",
			"code": [
				"#!/bin/sh",
				"",
				"git filter-branch --env-filter '",
				"WRONG_EMAIL=\"<USER_EMAIL>\"",
				"CORRECT_NAME=\"<USER_NAME>\"",
				"CORRECT_EMAIL=\"<USER_EMAIL>\"",
				"if [\"$GIT_COMMITTER_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"",
				"    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"if [\"$GIT_AUTHOR_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"",
				"    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"' --tag-name-filter cat -- --branches --tags"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commits",
			"title": "Git. Obtener todos los 'commits' realizados",
			"description": "<p>Después de haber realizado varios 'commits', o si ha clonado un repositorio que ya tenía un historial de 'commits', probablemente querrá mirar hacia atrás para ver qué modificaciones se han realizado.</p><p>Este comando muestra una lista de todos los 'commits' realizados, en orden cronológico inverso, es decir, los más recientes se muestran al principio. Cada 'commit' contiene información sobre el número de identificación (<em>Secure Hash Algorithm</em>, <code>SHA-1</code>), el nombre y la dirección de correo electrónico del autor, la fecha y el mensaje del 'commit'.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones' target='_blank'>Saber más</a></p>",
			"code": "git log"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commits-oneline",
			"title": "Git. Obtener todos los 'commits' realizados en una sola línea",
			"description": "<p>El comando <code>git log</code> tiene muchos parámetros opcionales para formatear la salida de la información del 'commit'. La opción <code>--oneline</code> muestra la información de cada 'commit' en una sola línea con los 6 primeros caracteres del número <code>SHA-1</code>, las ramas, las etiquetas y el mensaje.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones#rlog_options' target='_blank'>Saber más</a></p>",
			"code": "git log --oneline"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commits-oneline-graph",
			"title": "Git. Obtener todos los 'commits' realizados en un gráfico",
			"description": "<p>Este comando condensa la información de cada 'commit' en una sola línea, mostrando solo el ID del 'commit' y la primera línea del mensaje del 'commit', resaltando todas las referencias (ramas, etiquetas...).</p><p>Dibuja una representación gráfica <em>ASCII</em> de la estructura del historial de 'commit'. Imprime líneas adicionales entre los 'commits', para que el gráfico del historial se dibuje correctamente, y utiliza asteriscos para mostrar en qué rama estaba el 'commit'.</p><p><a href='https://www.atlassian.com/git/tutorials/git-log' target='_blank'>Saber más</a></p>",
			"code": "git log --oneline --graph --decorate"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commit-without-merges",
			"title": "Git. Obtener todos los 'commits' realizados, ocultando los 'commits' de fusión",
			"description": "<p>Un <code>merge</code> es el resultado de fusionar 2 o más ramas. En ocasiones, con esa fusión se genera un 'commit' extra llamado <code>merge commit</code>. La información de este 'commit' contiene una mezcla de todos los cambios realizados en ambas ramas, esto puede resultar confuso. Podemos mostrar la lista de 'commits' sin ellos con este comando.</p>",
			"code": "git log --oneline --no-merges"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commits-range",
			"title": "Git. Obtener 'commits' entre rangos",
			"description": "<p>La forma más común de especificar un rango de 'commits' es mediante la sintaxis de doble punto.</p><p>Esto, por ejemplo, suele usarse para obtener un rango concreto de 'commits' seleccionando la posición que ocupan en el histórico.</p><p>O, por otro lado, si seleccionamos 2 ramas mostrará todos los 'commits' de la primera rama que no aparecen en la segunda. Esto es útil para previsualizar lo que se está a punto de fusionar o para ver lo que se está a punto de publicar en el repositorio remoto.</p><p><a href='https://git-scm.com/book/es/v2/Herramientas-de-Git-Revisi%C3%B3n-por-selecci%C3%B3n#r_commit_ranges' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git log master~<POSITION_NUMBER>..master~<POSITION_NUMBER>"
				],
				[
					"git log master..develop"
				],
				[
					"git log origin/master..HEAD"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commit-by-date",
			"title": "Git. Buscar los 'commits' por fecha",
			"description": "<p>Con los siguientes comandos podemos obtener una lista de 'commits' según la fecha indicada (AAAA-MM-DD):<ul><li><code>--since</code> 'commits' desde la fecha.</li><li><code>--before</code> 'commits' anteriores a la fecha.</li><li><code>--after</code> 'commits' posteriores a la fecha.</li></ul></p>",
			"code": [
				[
					"git log --since={<DATE>}"
				],
				[
					"git log --before={<DATE>}"
				],
				[
					"git log --after={<DATE>}"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-commits-of-file",
			"title": "Git. Mostrar solo los 'commits' en los que está involucrado un archivo",
			"description": "<p>Muestra todos los 'commits' en los que se ha modificado el archivo indicado.</p>",
			"code": "git log --oneline -- <FILE_NAME>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-commits-regex",
			"title": "Git. Buscar en archivos y 'commits' de Git usando una expresión regular",
			"description": "<p>Por lo general, revisamos el historial del repositorio usando el comando <code>git log</code>, que nos muestra ver una lista de todos los 'commits'. Pero a medida que nuestro proyecto se vaya haciendo más grande, se complicará la búsqueda entre los múltiples archivos y confirmaciones. Por ello, en algún momento, querremos <strong>filtrar esta lista para encontrar los cambios que incluyan ciertas palabras en los archivos o en el mensaje de confirmación</strong>.</p><p>Git tiene un comando llamado <code>grep</code> que le permite buscar dentro del repositorio, a través de cualquier árbol o directorio de trabajo, los archivos que coincidan con una cadena de texto.</p><p>Por ejemplo:<ul><li><code>git grep -n 'word'</code> o <code>git grep --line-number 'word'</code>, muestra el archivo, el número de línea y el texto de la línea donde se ha encontrado la coincidencia.</li><li><code>git grep -c 'word'</code> o <code>git grep --count 'word'</code>, resume el resultado mostrando solo los archivos donde se ha encontrado la coincidencia y cuantas coincidencias hay en cada archivo.</li></ul></p><p>También con el comando <code>--grep</code> podemos buscar dentro de un repositorio Git, en cualquier rama, los 'commits' cuyo mensaje coincida con la cadena de texto o expresión regular que le indiquemos.</p><p>Por ejemplo:<ul><li><code>git log -S 'word'</code>, muestra los 'commits' que contiene la palabra a buscar, tanto en los mensajes de los 'commits' como en el contenido de los cambios.</li><li><code>git log --grep='word'</code>, muestra los 'commits' cuyo mensaje coincida con la expresión que le indiquemos.</li></ul> Una vez encontrado el 'commit', podríamos ejecutar el comando <code>git show &lt;COMMIT_ID&gt;</code>, usando el <code>HASH</code> (identificador del 'commit'), para verlo en profundidad.</p><p><a href='https://static.platzi.com/media/user_upload/38.gitgrep-91e4368f-580b-4d90-8d2f-628d0b76089a.jpg' target='_blank'>Ver imagen</a> | <a href='https://runebook.dev/es/docs/git/git-grep' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git grep --line-number '<REGEX>'"
				],
				[
					"git grep --count '<REGEX>'"
				],
				[
					"git log -S '<REGEX>'"
				],
				[
					"git log --oneline --grep='<REGEX>'"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-info-commit",
			"title": "Git. Mostrar la información de un 'commit'",
			"description": "<p>Se trata de una herramienta de línea de comandos que se utiliza para ver detalles ampliados en objetos Git como blobs, árboles, etiquetas y 'commits'.</p><p>En el caso de un 'commit', muestra su información completa: id o <code>SHA-1</code>, autor, fecha y mensaje.</p><p>Hay muchas formas de acceder a la información de un 'commit':</br><ul><li>De forma absoluta, refiriéndose al código que lo identifica.</li><li>De forma relativa, refiriéndose al nombre de la rama del último 'commit'.</li><li>A través de <code>HEAD</code>, accediendo al último 'commit' que se ha realizado.</li><li>Por su posición en el árbol de Git. Podemos ver todos los 'commits' hacia atrás desde el momento que le digamos, con el signo <code>^</code> podemos ir 1 o 3 'commits' hacia atrás y con el signo <code>-</code> o <code>~</code> podemos especificar el número de 'commits' hacia atrás que queremos ir hasta encontrar el que queremos ver.</li></ul></p>",
			"code": [
				[
					"git show <COMMIT_ID>"
				],
				[
					"git show <BRANCH_NAME>"
				],
				[
					"git show HEAD"
				],
				[
					"git show HEAD^"
				],
				[
					"git show HEAD^^^"
				],
				[
					"git show HEAD~<POSITION_NUMBER>"
				],
				[
					"git show -<POSITION_NUMBER>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "summary-branches",
			"title": "Git. Mostrar ramas y sus 'commits'",
			"description": "<p>Nos muestra un resumen de todas las ramas que hay en un proyecto junto con sus últimas modificaciones o 'commits'.</p><p><a href='https://git-scm.com/docs/git-show-branch' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git show-branch"
				],
				[
					"git show-branch --list"
				],
				[
					"git show-branch --more=-1"
				],
				[
					"git show-branch --more=<NUMBER_COMMITS>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-date-commit",
			"title": "Git. Mostrar fecha de 'commit'",
			"description": "<p>Un 'commit' tiene 2 tipos de fechas: la fecha del autor y la fecha del 'commit'.<ul><li>La <strong>fecha del autor</strong> indica cuándo se realizó originalmente esta confirmación, es decir, cuándo se realizó por primera vez el <code>git commit</code>.</li><li>La <strong>fecha de confirmación</strong> cambia cada vez que se modifica la confirmación, por ejemplo, cuando se sobreescribe el 'commit' con <code>git commit --amend</code></li></ul></p><p>Con el siguiente comando podemos formatear la información de salida de un 'commit' (2020-12-03 19:28:49 +0100).<ul><li><code>%ai</code>: <strong>fecha del autor</strong>, <em>ISO 8601-like</em> format</li><li><code>%ci</code>: <strong>fecha del commit</strong>, <em>ISO 8601-like</em> format</li></ul></p>",
			"code": "git show -s --format=%ci <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "overwrite-date-commit",
			"title": "Git. Sobrescribir la fecha de 'commit'",
			"description": "<p>Este comando cambia la fecha de autor y committer del 'commit' ya creado (2020-12-03 19:28:49 +0100).</br>¿Por qué cambiar dos fechas? El <strong>autor</strong> es la persona que escribió originalmente el trabajo, mientras que el <strong>committer</strong> es la persona que aplicó por última vez el trabajo. Si estamos trabajando solos en el proyecto, la fecha debe ser la misma en ambos casos.</p><p>Tenemos 2 formas de sobrescribir la fecha de un 'commit':</p><ul><li>Podemos modificar la fecha del <strong>último commit</strong> realizado con este primer comando.</br><a href='https://garysferrao.github.io/git/commit/date/2015/12/01/change-git-commit-date.html' target='_blank'>Saber más</a></li><li>O podemos modificar la fecha de un 'commit' en particular filtrando la lista de 'commits' <strong>por el ID del 'commit'</strong> a buscar. La fecha del primer 'commit' realizado en un repositorio se puede modificar utilizando este segundo comando.</br><a href='https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git' target='_blank'>Saber más</a></li></ul><p>La segunda vez que ejecutemos cualquiera de estos comandos no podremos crear una nueva copia de seguridad. Debemos borrar la copia de seguridad anterior que ya existe en la carpeta <code>.git/refs/original/</code> o forzar la sobrescritura de la copia de seguridad con <code>-f</code>.</p>",
			"code": [
				[
					"GIT_COMMITTER_DATE='<YYYY-MM-DDThh:mm:ss±hh:mm>' git commit --amend --date='<YYYY-MM-DDThh:mm:ss±hh:mm>' -C <COMMIT_ID>"
				],
				[
					"git filter-branch --env-filter \\",
					"'if [ $GIT_COMMIT = <COMMIT_ID> ]",
					"then",
					"    export GIT_AUTHOR_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"    export GIT_COMMITTER_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"fi'"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "git-add",
			"title": "Git. Añadir carpetas y archivos al área de preparación",
			"description": "<p>Existen diferentes áreas en un repositorio Git: el árbol de trabajo, el directorio de trabajo o espacio de trabajo, el área de preparación o índice, el 'stash', el repositorio local y el repositorio remoto.<ul><li>El <strong>espacio de trabajo</strong> contiene los archivos en los que estás trabajando actualmente, Git notará los cambios (si no los has excluido previamente), pero no los guardará hasta que le digas explícitamente que los rastree.</li><li>El <strong>área de preparación</strong> contiene una instantánea del contenido que rastrea el árbol de trabajo. Esta instantánea representa el contenido del siguiente 'commit'.</li></ul></p><p>Utilizamos el comando <code>git add</code> para añadir los cambios en el directorio de trabajo al área de preparación.</br>Puedes añadirlos todos a la vez (3 primeros comandos) o indicando las rutas de los archivos (último comando):</p>",
			"code": [
				[
					"git add --all"
				],
				[
					"git add -A"
				],
				[
					"git add ."
				],
				[
					"git add <PATH/TO/FOLDER/FILE>"
				],
				[
					"git add <PATH/TO/FOLDER/FILE_1> <PATH/TO/FOLDER/FILE_2>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-status-files",
			"title": "Git. Mostrar el estado de los archivos en un directorio Git",
			"description": "<p>Ejecutando este comando podemos ver la rama en la que nos encontramos y los archivos que contiene el área de preparación junto con su estado (nuevo/modificado/borrado). También nos avisa de los archivos no rastreados por Git (untracked) o de los archivos con conflictos.</p>",
			"code": "git status"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-file-track",
			"title": "Git. Borrar y rastrear el archivo",
			"description": "<p>El comando <code>git rm</code> se utiliza para eliminar archivos individuales o un conjunto de archivos de un repositorio, el comando contrario sería <code>git add</code>.</br>La eliminación solo afecta a las áreas del directorio de trabajo y al área de preparación, solo actúa sobre la rama actual y sobre los archivos que no tengan cambios sin guardar. Este cambio no se almacena en el historial del repositorio hasta que se crea un nuevo 'commit'.</p><p><strong>Por qué utilizar <code>git rm</code> en lugar de <code>rm</code></strong></br>Con el comando <code>rm</code>, un repositorio Git reconocerá cuando ha pasado por encima de un archivo que está siendo rastreado, actualizará el directorio de trabajo para reflejar la eliminación pero no el área de preparación. Es necesario ejecutar un comando adicional <code>git add</code> en las rutas de los archivos eliminados para añadir los cambios al área de preparación. El comando <code>git rm</code> actúa como un atajo, ya que actualizará el directorio de trabajo y el índice de prueba con la eliminación.</p><p>Los siguientes comandos hacen:<ul><li><code>rm</code>: Elimina el archivo seleccionado y Git no nota este cambio.</li><li><code>git rm</code>: Solo funciona si el archivo ya estaba siendo rastreado, es decir, si se ejecutó un <code>git add</code> y un <code>git commit</code>. Elimina el archivo seleccionado, y añade los cambios al área de preparación.</li><li><code>git rm --cached</code>: Elimina el rastro del archivo seleccionado del control de versiones, sin borrar el archivo, esto se llama un <strong>fichero sin seguimiento</strong>.</li></ul></p><p><a href='https://www.atlassian.com/es/git/tutorials/undoing-changes/git-rm' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"rm <PATH/TO/FOLDER/FILE>"
				],
				[
					"git rm <PATH/TO/FOLDER/FILE>"
				],
				[
					"git rm --cached <PATH/TO/FOLDER/FILE>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-file-track",
			"title": "Git. Renombrar y rastrear el archivo",
			"description": "<p>Este comando funciona igual que el comando <code>git rm</code>.</p><p>Los siguientes comandos hacen:<ul><li><code>mv</code>: Modificar el nombre de un archivo sin que el Git lo añada al área de preparación.</li><li><code>git mv</code>: Modificar el nombre de un archivo y que Git rastree este cambio. Después de esto, si hacemos un <code>git status</code> aparecerá como renombrado.</li></ul></p>",
			"code": [
				[
					"mv <OLD_FILE_NAME> <NEW_FILE_NAME>"
				],
				[
					"git mv <OLD_FILE_NAME> <NEW_FILE_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-commit",
			"title": "Git. Crear un 'commit' con un mensaje",
			"description": "<p>Los 'commits' se crean para capturar el estado de uno o más archivos del proyecto en un momento determinado. Son un <strong>conjunto de cambios</strong>, instantáneas o hitos en la historia de un proyecto Git. Cada 'commit' contiene la fecha en que se hizo, los cambios de cada archivo, la información del autor, un mensaje que describe el contenido del 'commit' y un identificador único (<code>SHA-1</code>) para referenciar este 'commit'.</p><p>Este comando solo incluye las modificaciones de los archivos rastreados (aquellos que han sido añadidos con <code>git add</code> en algún momento de su historia). La opción <code>-m</code> o <code>--message</code> sirve para indicar el mensaje del 'commit'.</p>",
			"code": "git commit -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "add-and-create-commit",
			"title": "Git. Añadir carpetas y archivos al área de preparación y crear un 'commit'",
			"description": "<p>Si ya hemos hecho el primer <code>git add</code> y <code>git commit</code> de un archivo, es decir, Git ya lo conoce, las próximas veces podemos usar otro comando que incluya ambos pasos en un solo comando. Esta combinación crea inmediatamente un 'commit' de todos los cambios preparados y aplica un mensaje de 'commit' en línea.</p><p>Es un comando de acceso directo para usuarios avanzados que combina las opciones <code>-a</code> o <code>--all</code> (añade los archivos modificados o borrados al escenario, pero no los recién creados, ya que no han sido reportados a Git para su seguimiento) y <code>-m</code> o <code>--message</code> (con el mensaje especificado).</p><p><a href='https://www.atlassian.com/es/git/tutorials/saving-changes/git-commit' target='_blank'>Saber más</a></p>",
			"code": "git commit -am '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "commit-particular-file-on-index",
			"title": "Git. Confirmar un solo archivo en el área preparación",
			"description": "<p>Si tiene varios archivos añadidos al <strong>staging area</strong> y se arrepiente, porque solo quiere añadir un archivo en particular, puede seleccionar el archivo y hacer un 'commit' solo de sus cambios.</p>",
			"code": [
				"git <FILE_NAME>",
				"git commit -am <COMMIT_MESSAGE>"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "overwrite-last-commit",
			"title": "Git. Sobrescribir el último 'commit'",
			"description": "<p>Si un mensaje o archivo de 'commit' contiene información poco clara, incorrecta, sensible o que falta, puedes corregirlo localmente y crear un 'commit' con un nuevo mensaje.</br>Al ejecutar este comando se abrirá un editor de texto y te pedirá que edites el mensaje y guardes el 'commit'. Este proceso cambiará el ID del 'commit', creando una nueva 'commit' que sustituye a la anterior.</p><p><a href='https://blog.kirei.io/buenas-pr%C3%A1cticas-para-los-mensajes-de-commit-en-git-a9fc43a83821' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git commit --amend"
				],
				[
					"git commit --amend",
					"git push -f"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-commit",
			"title": "Git. Eliminar un 'commit'",
			"description": "<p>El comando <code>git reset</code> es una herramienta para deshacer cambios. Si lo ejecutamos sin indicar un SHA de 'commit', solo eliminará los cambios añadidos al área de preparación.</p><p>Tiene 3 argumentos que se corresponden con los 3 mecanismos internos de gestión de estados de Git, el árbol de 'commit' (HEAD), el área de preparación y el directorio de trabajo.</p><p>Cuando especificamos el tipo de reset que queremos con uno de estos argumentos, indicamos el 'commit' SHA anterior a todos los que queremos borrar:<ul><li><code>--mixto</code>: Es la opción por defecto, provoca el mismo efecto que ejecutar <code>git reset</code>. Elimina los 'commits' posteriores al 'commit' seleccionado. Elimina los cambios del área de preparación, pero mantiene los del directorio de trabajo.</li><li><code>--soft</code>: Elimina los 'commits' posteriores al 'commit' seleccionado, pero mantiene los cambios añadidos al área de preparación y conserva los realizados en el directorio de trabajo.</li><li><code>--hard</code>: Es la opción más peligrosa porque se pierden todos los cambios realizados. Elimina los 'commits' posteriores al 'commit' seleccionado, lo que también elimina los cambios del área de preparación y del directorio de trabajo.</li></ul></p>",
			"code": [
				[
					"git reset --soft <COMMIT_ID>"
				],
				[
					"git reset --mixed <COMMIT_ID>"
				],
				[
					"git reset --hard <COMMIT_ID>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "squashing-commits",
			"title": "Git. Aplastamiento o fusión de confirmaciones",
			"description": "<p>El proceso de borrar un número de 'commits' con el argumento <code>--soft</code> y luego hacer un 'commit' se suele llamar hacer <strong>squashing</strong>, ya que es como compactar varios 'commits' en uno.</p>",
			"code": [
				"git reset --soft master~<NUMBER_LAST_COMMITS>",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "revert-commit",
			"title": "Git. Revertir los cambios de un 'commit' y crear uno nuevo",
			"description": "<p>Este comando nos permite crear un 'commit' con los cambios revertidos de la referencia indicada, es decir, si tenemos un 'commit' que añadía una línea y borraba dos, ahora estamos creando otro 'commit' que borra la línea añadida y añade las dos borradas.</br>Tras ejecutar este comando en la consola, nos pedirá el mensaje y creará un nuevo 'commit'.</p>",
			"code": "git revert <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "add-stash",
			"title": "Git. Guardar los cambios en el 'stash'",
			"description": "<p>Git tiene un área llamada <strong>stash</strong> donde puedes almacenar temporalmente una instantánea de tus cambios sin confirmarlos en el repositorio. Está separada del directorio de trabajo, del área de preparación o del repositorio.</br>Esta funcionalidad es útil cuando has hecho cambios en una rama que no estás listo para confirmar, pero necesitas cambiar a otra rama. Esto guarda tus cambios, que estarán disponibles desde cualquier rama en ese repositorio y revierte el directorio de trabajo a como estaba para el último 'commit'.</br>Note que los cambios que quiere almacenar necesitan estar en archivos rastreados. Si ha creado un nuevo archivo y trata de almacenar sus cambios, puede obtener el error <em>'No hay cambios locales para guardar'</em>.</p><p>Las instantáneas se guardan en el formato <code>stash@{0}: BRANCH: SHA MESSAGE</code>. Se guardarán con un identificador del tipo <code>stash@{0}</code>, donde <code>stash</code> indica que es una instantánea y el número entre las llaves, <code>{0}</code> es el índice de ese <code>stash</code>. El número del índice crece a medida que se crean nuevas instantáneas y se ordenan de forma inversa, es decir, el número más pequeño será siempre la última instantánea realizada. Se indica la rama en la que se hicieron los cambios, y el identificador y el mensaje serán los mismos que el último 'commit' que tengamos en el repositorio.</p><p>Por defecto, envía todos los ficheros que tengamos en el directorio de trabajo y en el área de preparación, excepto los no rastreados, a la zona <code>stash</code>. Y genera el mensaje automáticamente. Pero hay varias opciones que podemos añadir al comando:<ul><li><code>--include-untracked</code> o <code>-u</code>: Añade también los archivos no rastreados.</li><li><code>--all</code> o <code>-a</code>: Añade también los archivos no rastreados e ignorados (.gitignore).</li><li><code>--patch</code>: Git no almacenará todo lo que se modifique, sino que nos preguntará de forma interactiva cuáles de los cambios queremos almacenar y cuáles queremos mantener en nuestro directorio de trabajo.</li><li><code>push -m</code>: Nos permite especificar un mensaje para el 'commit' que estamos enviando al 'stash'.</li><li><code>save</code>: Está obsoleto en favor de <code>push -m</code>.</li></ul></p><p><a href='https://www.freecodecamp.org/news/git-stash-explained/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git stash"
				],
				[
					"git stash -u"
				],
				[
					"git stash -a"
				],
				[
					"git stash --patch"
				],
				[
					"git stash push -m '<STASH_MESSAGE>'"
				],
				[
					"git stash save '<STASH_MESSAGE>'"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-stash-list",
			"title": "Git. Obtener una lista de los 'stash' guardados",
			"description": "<p>Cuando tienes muchas instantáneas guardadas, te conviene ver una lista de todas ellas para poder seleccionarlas. El mensaje y el ID, que por defecto vienen del 'commit', te ayudarán a diferenciarlos.</br>Es recomendable limpiar el alijo o borrar aquellas instantáneas que no necesitemos para no acumularlas.</p>",
			"code": "git stash list"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-stash",
			"title": "Git. Volver a aplicar los cambios guardados en el 'stash'",
			"description": "<p>Hay dos formas diferentes de recuperar los cambios guardados en el 'stash': <code>apply</code> y <code>pop</code>.</p><p>Por defecto, ejecutando cualquiera de estos 2 comandos podemos recuperar el último 'stash' guardado, <code>stash@{0}</code>. La diferencia es que la opción <code>apply</code>, mantiene el cambio en la lista para una posible reutilización posterior, y <code>pop</code> tras aplicar el cambio lo elimina de la pila de 'stash', pero si durante este proceso hay conflictos, no lo elimina, dejando que se comporte exactamente como la opción <code>apply</code>.</br>Otra forma de hacer lo mismo que con la opción <code>pop</code> es hacerlo en 2 pasos: <code>git stash apply</code> && <code>git stash drop</code>.</p><p>También podemos obtener los cambios de un 'stash' concreto de nuestra pila, indicando su número de índice.</p><p><a href='https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning#_git_clean' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git stash apply"
				],
				[
					"git stash pop"
				],
				[
					"git stash apply",
					"git stash drop"
				],
				[
					"git stash apply stash@{<STASH_NUMBER>}"
				],
				[
					"git stash apply <STASH_NUMBER>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-stash-branch",
			"title": "Git. Crear una rama a partir de un 'stash'",
			"description": "<p>Este es un buen atajo para recuperar el código almacenado en 'stash' indicado y crear una nueva rama para trabajar en él por separado. Este comando crea una nueva rama con el último 'stash' (<code>stash@{0}</code>), y luego lo borra (<code>git stash pop</code>). Si necesitas un 'stash' en particular puedes especificar el ID del 'stash'.</p><p>Esto será útil cuando te encuentres con conflictos después de haber aplicado el 'stash' a la última versión de tu rama.</p><p><a href='https://www.freecodecamp.org/news/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git stash branch <BRANCH_NAME>"
				],
				[
					"git stash branch <BRANCH_NAME> stash@{<STASH_NUMBER>}"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "show-stash",
			"title": "Git. Mostrar las diferencias del 'stash'",
			"description": "<p>La opción <code>show</code> del comando <code>stash</code> ofrece un resumen muy breve de los cambios realizados en los archivos. Muestra en una línea la ruta y el nombre del fichero, y el número de líneas eliminadas.</p><p>Por defecto, muestra la información del último 'stash' (<code>stash@{0}</code>), pero podemos indicar un número de índice para ver algún otro.</p><p>Si queremos profundizar y ver todos los cambios de cada línea del fichero en el editor del terminal, podemos utilizar la opción <code>-p</code>.</p><p><a href='https://howto.lintel.in/how-to-see-stashed-changes-using-git-stash/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git stash show"
				],
				[
					"git stash show stash@{<STASH_NUMBER>}"
				],
				[
					"git stash show -p"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-stash",
			"title": "Git. Eliminar el 'stash'",
			"description": "<p>Hay dos formas diferentes de eliminar los cambios guardados en el área de 'stash': <code>drop</code> y <code>clear</code>.</p><p>Podemos eliminar el primer elemento guardado en el 'stash' (el último 'stash': <code>stash@{0}</code>) con <code>drop</code> o si ya no necesitas un 'stash' en particular, seleccionarlo por su número de índice.</p><p>Pero, si lo que queremos es limpiar el área de almacenamiento por completo, la opción <code>clear</code> borra toda la lista de stashes.</p><p><strong>ADVERTENCIA IMPORTANTE</strong>: Con la opción <code>clear</code> esos estados serán entonces objeto de poda, y puede ser imposible recuperarlos. Utilice ambas opciones con precaución, ya que puede ser difícil revertir los stashes una vez borrados.</p> <p>Para confirmar si todo se ha borrado, obtenga de nuevo la lista de stashes con el comando <code>git stash list</code>.</p><p><a href='https://kolosek.com/git-stash/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git stash drop"
				],
				[
					"git stash drop stash@{<STASH_NUMBER>}"
				],
				[
					"git stash drop <STASH_NUMBER>"
				],
				[
					"git stash clear"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "recover-dropped-stash",
			"title": "Git. Recuperar un 'commit' eliminado del 'stash'",
			"description": "<p>Pongamos el caso de que has hecho limpieza en tu repositorio, acabas de borrar todos los 'commits' antiguos almacenados en el 'stash' y justo te das cuenta de que en uno de esos 'commits' tenías cambios importantes que no has guardado.</p><p><strong>No entres en pánico</strong>, es posible que puedas recuperar los cambios perdidos con el comando <code>git fsck</code>.</p><p>Para resolver este problema lo primero es localizar el hash ID (de 6 cifras) del 'commit' eliminado. Una vez lo tengamos podemos ver en detalle la información que contiene y decidir si es el que estamos buscando. Si es así, todo lo que hay que hacer es volver a guardarlo.</p><p>Veámoslo en detalle: <ol><li><strong>Encontrar los 'commits' del 'stash' eliminados</strong></br>El siguiente comando te mostrará un gráfico con todos los 'commits' que ya no son referenciados desde ninguna rama o etiqueta, es decir, cada 'commit' perdido que hayas creado, incluyendo los del 'stash'.</br><em>Shell bash/sh:</em></br><code>git log --graph --oneline --decorate $( git fsck --no-reflog | awk '/dangling commit/ {print $3}’ )</code></br>En algún lugar de ese gráfico encontrarás el mensaje de confirmación que buscas.</br>Pista: Si no proporcionaste un mensaje cuando hiciste <code>git stash</code>, este 'commit' comenzará con <code>WIP on</code>.</li><li><strong>Confirmar que son los cambios que buscamos</strong></br>Una vez tienes el hash del 'commit' del 'stash' puedes utilizar el comando <code>git show &lt;COMMIT_ID&gt;</code> para examinar en detalle el <code>diff</code> del 'commit', es decir, los nombres de las carpetas, archivos y líneas de código modificadas.</li><li><strong>Recuperar los cambios y guardarlos</strong></br>Después de confirmar que son los cambios que quieres recuperar, puedes traerlos al área de trabajo usando <code>git stash apply &lt;COMMIT_ID&gt;</code>.</br>Y si, por si a caso, además quieres volver a guardar esos cambios en la lista del 'stash' ubicada en <code>.git/logs/refs/stash</code>, puedes usar el comando <code>git stash &lt;COMMIT_ID&gt;</code>.</li></ol></p><p><a href='https://foroayuda.es/recuperar-alijo-eliminado-en-git-usando-sourcetree/' target='_blank'>Saber más</a></p>",
			"code": [
				"git log --graph --oneline --decorate $( git fsck --no-reflog | awk '/dangling commit/ {print $3}' )",
				"git show <COMMIT_ID>",
				"git stash apply <COMMIT_ID>"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "exit-from-vim-without-save",
			"title": "Git. Salir de la ventana de texto sin guardar",
			"description": "<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres simplemente salir de la ventana de texto sin guardar los cambios, escribe el comando y pulsa <em>'enter'</em>.</p><p><a href='https://victorhckinthefreeworld.com/2017/06/14/como-salir-del-editor-vim/' target='_blank'>Saber más</a></p>",
			"code": ":q!"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "exit-from-vim-and-save",
			"title": "Git. Salir de la ventana de texto, después de guardar",
			"description": "<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres salir de la ventana de texto y guardar los cambios, escribe el comando y pulsa <em>'enter'</em>.</p><p><a href='https://victorhckinthefreeworld.com/2017/06/14/como-salir-del-editor-vim/' target='_blank'>Saber más</a></p>",
			"code": ":wq"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "reflog",
			"title": "Git. Ver registro de referencia con 'reflog'",
			"description": "<p>Antes de hablar del diario de referencias, hay que recordar que <code>HEAD</code> es una referencia, es decir, un puntero que apunta al 'commit' más reciente de la rama actual.</p><p>Existe un registro de todas las referencias tomadas por el puntero <code>HEAD</code> en Git llamado <strong>reflog</strong>. Es un listado que almacenará todos los 'commits' por los que pase el puntero, por ejemplo, podrá guardar los cambios de una rama o la adición de un 'commit'.</p><p>Este comando puede ser muy útil, en el caso de que queramos recuperar un 'commit' borrado.<ul><li><code>git reflog</code>: Te va a mostrar todos los 'commits' que realizaste sin importar si los borraste o no. Cada 'commit' mostrará una pequeña información de sí mismo: su número de hash (6 cifras), la rama a la que pertenece, el índice de la posición que ocupa su puntero <code>HEAD</code> y la primera línea del mensaje.</li><li><code>git show &lt;COMMIT_ID&gt;</code>: Viendo esta información podemos encontrar el 'commit' que queremos y acceder a él mediante su número de hash. Así podemos ver en detalle su información: su número de hash completo, el autor y la fecha del 'commit', el mensaje del 'commit' completo y qué archivos y líneas se han añadido, eliminado o modificado.</li><li><code>git reset --mixed &lt;COMMIT_ID&gt;</code>: Usamos este comando, una vez estamos seguros de que queremos recuperar este 'commit' y asi obtendremos de nuevo los archivos con los cambios que habiamos eliminado. Este comando no genera un 'commit' con estos cambios, así que tendremos que ejecutar un <code>git commit</code> para volver a guardarlos. Podremos recuperar el mensaje que habiamos usado con el commando anterior <code>git show</code>, ya que nos mostraba el mensaje completo.</li></ul></p><p><a href='https://www.atlassian.com/es/git/tutorials/rewriting-history/git-reflog' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git reflog"
				],
				[
					"git reflog --format='%C(auto)%h %<|(17)%gd %C(blue)%ci%C(reset) %s'"
				],
				[
					"git reflog",
					"git show <COMMIT_ID>",
					"git reset --mixed <COMMIT_ID>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "reflog-remove",
			"title": "Git. Podar todas las referencias con la recogida de basura y recuperar espacio",
			"description": "<p>El subcomando <code>expire</code> limpia las entradas de <strong>reflog</strong> viejas o inalcanzables. Tiene un potencial de pérdida de datos y no suele ser utilizado por los usuarios finales, pero sí por Git internamente. Por defecto, la fecha de caducidad de <strong>reflog</strong> se establece en 90 días. Se puede especificar un tiempo de caducidad pasando un argumento de línea de comandos o estableciendo un nombre de configuración de Git.</p>",
			"code": [
				"rm -rf .git/refs/original/",
				"git reflog expire --expire=now --all",
				"git gc --aggressive --prune=now"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-branches",
			"title": "Git. Obtener todas las ramas",
			"description": "<p>A veces es necesario saber qué ramas existen en un repositorio remoto para determinar los nombres de las ramas disponibles.</p><p>Con este comando puedes listar ambos tipos de ramas: remotas y locales. La rama actual aparecerá resaltada en color y marcada con un asterisco <code>*</code>.</p>",
			"code": [
				[
					"git branch --all"
				],
				[
					"git branch -a"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-branches-local",
			"title": "Git. Obtener todas las ramas locales",
			"description": "<p>Una rama local es aquella cuyo nombre completo empieza por <code>refs/heads/</code>, el comando <code>git branch</code> quita esta parte para hacerlo más fácil.</p><p>Parece que con Git siempre hay más de una forma de hacer la misma cosa:</p>",
			"code": [
				[
					"git branch"
				],
				[
					"git branch --list"
				],
				[
					"git branch -l"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-branches-remotes",
			"title": "Git. Obtener todas las ramas remotas",
			"description": "<p>Una rama de seguimiento remoto es aquella cuyo nombre completo empieza por <code>refs/remotes/</code>, este comando elimina esta parte para facilitarlo.</p>",
			"code": [
				[
					"git branch --remotes"
				],
				[
					"git branch -r"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-branch",
			"title": "Git. Crear una nueva rama",
			"description": "<p>Puedes crear una nueva rama mientras estás en otra y moverte a ella más tarde.</p>",
			"code": "git branch <NEW_BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "checkout-branch-path",
			"title": "Git. Desplazarse a una rama/ruta",
			"description": "<p>El comando <code>git checkout &lt;NAME&gt;</code> está realmente pensado para ramas, pero la sintaxis de Git es relajada, y si Git no puede encontrar una rama, entonces buscará un archivo.</p><p>Supongamos que tienes un archivo y una rama que se llaman igual, <code>stuff</code>. Entonces el siguiente comando parecería ambiguo, <code>git checkout stuff</code>, porque no está claro si estás pidiendo la salida de un archivo o de una rama.</br>Con <code>--</code> es una forma de decirle a Git que trate lo que sigue a <code>checkout</code> como un archivo y no como una rama, cuando lo usas, le dice explícitamente a Git que saque un archivo con ese nombre/ruta</p><p>Este comando hizo:<ul><li>Si es una rama local o rama remota rastreada, cambia a ella.</li><li>Si es una ruta rastreada de un archivo, lo restablece, es decir, borra los cambios no guardados del directorio de trabajo.</li><li>Si es una rama remota, crea una rama de seguimiento y cambia a ella.</li></ul><p>Así que en este caso los siguientes comandos permiten mover una rama local o descargarla de la remota y restablecer un archivo:</p>",
			"code": [
				[
					"git checkout <BRANCH_NAME>"
				],
				[
					"git checkout -- <FILE_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "move-to-branch",
			"title": "Git. Desplazarse a la rama",
			"description": "<p>Cuando intentas moverte a una rama local que no existe, este comando buscará si hay una rama de seguimiento remoto con un nombre similar. Si es así, creará la rama local y la configurará para seguir la rama de seguimiento remoto.</p>",
			"code": "git checkout <BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-and-move-to-branch",
			"title": "Git. Crear y moverse a una rama",
			"description": "<p>Debes utilizar una rama distinta para cada función o problema en el que trabajes. Con este comando se hacen 2 pasos a la vez, crear y moverse a la rama para que todos los cambios que hagas se apliquen a ella.</br>La opción <code>-b</code> le dice a Git que la cree si no existe ya, de lo contrario, se restablece, es decir, la rama no se restablece/crea a menos que <code>git checkout</code> tenga éxito.</p>",
			"code": [
				[
					"git checkout -B <NEW_BRANCH_NAME>"
				],
				[
					"git checkout -b <NEW_BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "extract-files-from-staging-area",
			"title": "Git. Extraer los archivos del área de preparación",
			"description": "<p>Si ya he añadido el archivo con un <code>git add</code> al <strong>staging area</strong> pero no quiero hacer 'commit' todavía, y quiero eliminarlo de esta zona, estas son algunas formas de solucionarlo:<ul><li><code>git reset &lt;FILE_NAME&gt;</code>: Si los cambios se han realizado y añadido al <strong>staging area</strong>.</li><li><code>git rm --cached &lt;FILE_NAME&gt;</code>: Si aún no he lanzado un 'commit', y por tanto no se ha creado el puntero <code>HEAD</code>.</li><li><code>git reset HEAD &lt;FILE_NAME&gt;</code>: Si ya he lanzado mi primer 'commit', es decir, hay un puntero HEAD. Git se mueve entre los 'commits' apuntando siempre al último creado.</li></ul></p>",
			"code": [
				[
					"git reset <FILE_NAME>"
				],
				[
					"git rm --cached <FILE_NAME>"
				],
				[
					"git reset HEAD <FILE_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-current-branch",
			"title": "Git. Renombrar la rama actual",
			"description": "<p>Es posible que en algún momento, como ocurre con los mensajes de 'commit', quieras renombrar una rama.</br>Con este comando puedes renombrar la rama local en la que estás trabajando.</p><p>Tiene parámetros opcionales:<ul><li><code>--mover</code> o <code>-m</code>: Mover/renombrar una rama y el correspondiente <strong>reflog</strong>.</li><li><code>-M</code>: Es un atajo de <code>--delete --force</code></li></ul></p><p><a href='https://git-scm.com/docs/git-branch' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git branch -m <NEW_BRANCH_NAME>"
				],
				[
					"git branch -M <NEW_BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-local-branch",
			"title": "Git. Renombrar una rama local",
			"description": "<p>Puedes renombrar una rama local mientras te encuentras en cualquier otra rama.</p>",
			"code": [
				[
					"git branch -m <OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-remote-branch",
			"title": "Git. Renombrar una rama remota",
			"description": "<p>Supongamos que estás colaborando en un proyecto con un grupo de personas, y habeis definido una convención de nombres para las ramas de Git. Tu has creado una nueva rama, has enviado los cambios al repositorio remoto y te has dado cuenta de que el nombre de tu rama era incorrecto. Por suerte, Git te permite renombrar la rama local y la remota muy fácilmente usando varios comandos o haciendo lo mismo con uno solo.</p><p><a href='https://linuxize.com/post/how-to-rename-local-and-remote-git-branch/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git checkout <OLD_BRANCH_NAME>",
					"git branch -m <NEW_BRANCH_NAME>",
					"git push origin -u <NEW_BRANCH_NAME>",
					"git push origin --delete <OLD_BRANCH_NAME>"
				],
				[
					"git push origin :<OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "upload-local-branch",
			"title": "Git. Publicar una rama local a un repositorio remoto",
			"description": "<p>Se recomienda enviar la nueva rama al repositorio remoto (<code>ORIGIN</code>), ya que esto actúa como copia de seguridad, y al colaborar con otros desarrolladores, les permite acceder a ver los 'commits' realizados en la nueva rama.</br>La opción <code>-u</code> o <code>--set-upstream-to</code> la añade como rama de seguimiento remoto.</p>",
			"code": [
				[
					"git branch --set-upstream-to origin/<OTHER_BRANCH_NAME>"
				],
				[
					"git push origin -u <NEW_BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-branch",
			"title": "Git. Eliminar una rama",
			"description": "<p>Para eliminar una rama del repositorio Git no debes estar posicionado en ella.</p>",
			"code": [
				[
					"git branch -D <BRANCH_NAME>"
				],
				[
					"git branch -d <BRANCH_NAME>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "merge-branch",
			"title": "Git. Fusionar una rama",
			"description": "<p>La fusión es la forma que tiene Git de volver a unir un historial bifurcado. El comando <code>git merge</code> permite tomar las líneas de desarrollo independientes creadas por el comando <code>git branch</code> e integrarlas en una única rama.</br>Toma dos punteros de 'commit' de los extremos de cada rama y los combina en la rama actual, generando un nuevo <strong>commit de fusión</strong>. Sin embargo, si Git encuentra datos que han sido cambiados en ambos historiales, no podrá combinarlos automáticamente. En ese caso, se crea un conflicto de control de versiones y Git pedirá la intervención del usuario para continuar.</p><p>Antes de realizar una fusión hay un par de pasos de preparación para asegurar que la fusión se realice sin problemas:<ul><li><strong>Confirmar la rama receptora:</strong> Asegúrate de que <code>HEAD</code> apunta a la rama correcta con el comando <code>git status</code>. Si es necesario, ejecute <code>git checkout</code> para cambiar a la rama receptora.</li><li><strong>Obtener los últimos 'commits' remotos:</strong> Asegúrate de que la rama receptora y la rama de fusión están actualizadas con los últimos cambios remotos. Ejecute <code>git fetch</code> para obtener los últimos 'commits' remotos. Una vez que el fetch se ha completado asegúrese de que la rama maestra tiene las últimas actualizaciones ejecutando <code>git pull</code>.</li></ul></p><p>Esto significa que <code>git merge</code> se utiliza a menudo junto con <code>git checkout</code> para seleccionar la rama actual y <code>git branch -d</code> para eliminar la rama de destino obsoleta.</p> <p>Si las dos ramas que estás intentando fusionar han cambiado la misma parte del mismo archivo, Git no será capaz de averiguar qué versión usar. Cuando se produce esta situación, se detiene justo antes de crear el <strong>commit de fusión</strong> para que puedas resolver los conflictos manualmente. Cuando Git encuentra un conflicto durante una fusión, editará el contenido de los archivos afectados con indicadores visuales que marcan ambos lados del contenido en conflicto <code><<<<<<<</code> <code> =======</code> <code>>>>>>>></code>. El contenido anterior al marcador <code>=======</code> es la rama receptora y la parte posterior es la rama de fusión. Una vez que hayas identificado las secciones conflictivas, puedes entrar y arreglar la fusión a tu gusto. Cuando estés listo para terminar la fusión, todo lo que tienes que hacer es ejecutar <code>git add</code> en los archivos en conflicto para decirle a Git que están resueltos. Luego, ejecuta <code>git commit</code> para generar el <strong>commit de fusión</strong>.</p><p><a href='https://www.atlassian.com/es/git/tutorials/using-branches/git-merge' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git merge <BRANCH_NAME>"
				],
				[
					"git merge --continue"
				],
				[
					"git merge --abort"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "merge-fast-forward",
			"title": "Git. Fusionar una rama y crear un 'commit'",
			"description": "<p>La opción <code>--no-ff</code> evita que <code>git merge</code> ejecute un <strong>'fast-forward'</strong> si detecta que tu <code>HEAD</code> actual es un ancestro del 'commit' que estás intentando fusionar. Un <strong>fast-forward</strong> (adelantar rápidamente) es cuando, en lugar de construir un <strong>commit merge</strong> (confirmación de fusión), Git simplemente mueve tu puntero de rama para apuntar a la confirmación entrante.</p><p>En ocasiones quieres evitar que este comportamiento ocurra, normalmente porque quieres mantener una topología de rama específica (por ejemplo, estás fusionando en una rama temática y quieres asegurarte de que se vea así al leer el historial). Para ello, puedes pasar esta opción <code>--no-ff</code> y <code>git merge</code> siempre construirá una fusión en lugar de <strong>fast-forwarding</strong>.</p>",
			"code": [
				"git merge <BRANCH_NAME> --no-ff"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rebase",
			"title": "Git. Rebasar una rama",
			"description": "<p>En Git tenemos dos formas de integrar los cambios de una rama a otra: la fusión (<code>merge</code>) y la reorganización (<code>rebase</code>).</p> <p>Git <code>rebase</code> nos permite modificar el historial de Git utilizando un punto de referencia. Captura todos los cambios confirmados de la rama en la que estamos y los aplica a la que le estamos indicando, es decir, es capaz de reconocer que 'commits' no están en la línea de tiempo de ese punto de referencia y aplicarlos sobre el punto de referencia, es lo que llamamos en Git <strong>rebasing</strong>.</br>En contraste con el merge, esto genera una historia del proyecto perfectamente lineal, pudiendo ir desde el final de la rama hasta el inicio del proyecto sin encontrar ninguna bifurcación.</p><p>Es muy importante entender que, aunque la rama parezca la misma, está formada por 'commits' totalmente nuevos, lo que cambia la historia de Git. Esto implica que estos 'commits' se están recreando con el mismo mensaje y contenido, lo que puede dar lugar a <strong>conflictos</strong> a la hora de aplicarlos a la nueva rama si ésta tiene nuevos cambios.</br>Si esto ocurre, hay que resolverlos a medida que se producen y se consideran modificaciones del propio 'commit'. Esto nos permite borrar, reordenar, fusionar o cambiar el mensaje del 'commit' antes de aplicarlos. Cuando tengas los cambios arreglados, tendrás que pedirle al comando que continúe con la opción <code>--continue</code> para aplicar el siguiente 'commit'.</br>En cualquier momento durante <code>rebase</code> si cambias de opinión puedes rechazar todo el proceso con la opción <code>--abort</code>.</p>",
			"code": [
				[
					"git rebase <BRANCH_NAME>"
				],
				[
					"git rebase --continue"
				],
				[
					"git rebase --abort"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "cherry-pick",
			"title": "Git. Copiar y pegar 'commits' con 'cherry-pick'",
			"description": "<p>Puede ocurrir que, en algún momento, queramos aplicar algunos de los cambios que hemos hecho en otra rama sin tener que hacer un merge completo. El comando <code>cherry-pick</code> permite <em>'copiar'</em> uno o varios 'commits' de una rama y <em>'pegarlos'</em> en otra rama. Antes de utilizarlo, debe tener un <strong>directorio de trabajo</strong> y <strong>zona de preparación</strong> limpios.</p><p>Por defecto, <code>cherry-pick</code> mantiene el mensaje de 'commit' original, por lo que la opción <code>-x</code> puede ser útil para añadir una referencia a el 'commit' original y así para saber de dónde se ha obtenido el 'commit'. Otras opciones interesantes son <code>-e</code>, que permite editar el mensaje de 'commit' en lugar de utilizar el original y la opción <code>-n</code> que aplicará los cambios pero no hará ningun 'commit'.</p><p>Al igual que con los comandos <code>merge</code> y <code>rebase</code>, tras resolver los conflictos, podemos indicar que se sigan aplicando los cambios con la opción <code>--continue</code> o rechazar el proceso completamente con la opción <code>--abort</code>.</p><p><a href='https://www.runroom.com/realworld/seleccionando-commits-cherry-pick' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git cherry-pick"
				],
				[
					"git cherry-pick <COMMIT_ID>"
				],
				[
					"git cherry-pick -x"
				],
				[
					"git cherry-pick -e"
				],
				[
					"git cherry-pick -n"
				],
				[
					"git cherry-pick --continue"
				],
				[
					"git cherry-pick --abort"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "diff",
			"title": "Git. Comparar cambios con 'git diff'",
			"description": "<p>Podemos ver qué cambios se han hecho en el código con el comando <code>diff</code>. Este, muestra en la terminal las líneas de código que se han eliminado con el símbolo <code>-</code> y en color rojo, y las líneas añadidas con el símbolo <code>+</code> y de color verde.</p><p>La siguiente herramienta online puede ayudarte. <strong>DiffMerge</strong> es una aplicación para comparar y fusionar visualmente archivos en Windows, OSX y Linux: <a href='http://sourcegear.com/diffmerge/' target='_blank'>http://sourcegear.com/diffmerge/</a></p><p>También podemos comparar los cambios que se han realizado en el código de varios 'commits'.</p><p><a href='https://www.atlassian.com/git/tutorials/saving-changes/git-diff' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git diff"
				],
				[
					"git diff <COMMIT_ID_1> <COMMIT_ID_2>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "mark-conflicts-resolved",
			"title": "Git. Marcar el conflicto como resuelto",
			"description": "<p>Pasos a seguir tras resolver un conflicto en los archivos:<ul><li>Añadir todos los archivos a la zona de preparación</li><li>Ver el estado de los archivos (modificados/borrados/añadidos)</li><li>Crear un 'commit' con esos cambios indicando una descripción de lo que se ha realizado</li></ul></p>",
			"code": [
				"git add .",
				"git status",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "get-tags",
			"title": "Git. Obtener todas las etiquetas realizadas",
			"description": "<p>Obtenga una lista simple de las etiquetas, si quiere asegurarse de que existen y cuáles son sus números de versión.</p>",
			"code": [
				[
					"git tag --list"
				],
				[
					"git tag -l"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "create-tag",
			"title": "Git. Crear una nueva etiqueta",
			"description": "<p>En el desarrollo de software, las etiquetas Git representan una versión de nuestro código en un momento dado. A diferencia de las ramas, las etiquetas no son mutables y siempre apuntan al mismo 'commit', por lo que la gente generalmente las utiliza para marcar puntos importantes en la historia de Git (como los puntos de liberación v1.0, v2.0 y así sucesivamente).</p><p>El <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a> utiliza un formato de versión basado en números 3 enteros separados por puntos: <code>X.Y.Z</code> (<em>Major.Minor.Patch</em>), los arreglos de bugs que no cambian el API incrementan el patch, los cambios y adiciones que no rompen la compatibilidad de las dependencias anteriores incrementan el minor, y los cambios que rompen la compatibilidad incrementan el major. Esto se traduciría a la estructura de ramas de <code>gitflow</code> como <em>lanzamiento.feature.bug</em>.</br>El desarrollador es el responsable de comunicar el estado de su software publicando este número.</p><p><a href='https://semver.org/' target='_blank'>Saber más</a></p>",
			"code": "git tag -a '<TAG_VERSION>' -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-local-tag",
			"title": "Git. Eliminar una etiqueta local",
			"description": "Eliminar la etiqueta local existente con los nombres dados",
			"code": [
				[
					"git tag -d <TAG_VERSION>"
				],
				[
					"git tag --delete <TAG_VERSION>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-tag-remote",
			"title": "Git. Eliminar una etiqueta remota",
			"description": "Eliminar la etiqueta remota existente con los nombres dados.",
			"code": "git push --delete origin <TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "remove-and-upload-tag",
			"title": "Git. Eliminar una etiqueta local y remota",
			"description": "<p>Cuando quieras renombrar o eliminar una etiqueta y ya la hayas empujado a un repositorio remoto (por ejemplo, GitHub) entonces también tendrás que actualizar las referencias remotas justo después de renombrar o eliminar la etiqueta de tu repo local.</p><p>Aquí hay dos alternativas para eliminar una etiqueta en el repositorio local y en el remoto:<ul><li>Eliminar la etiqueta local y sobrescribir este cambio haciendo referencia al nombre de la etiqueta eliminada en el repositorio remoto.</li><li>O hacer el proceso a la inversa, eliminar primero la etiqueta en el repositorio remoto y luego en el repositorio local.</li></ul></p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git tag -d <TAG_VERSION>",
					"git push origin :refs/tags/<TAG_VERSION>"
				],
				[
					"git push --delete origin <TAG_VERSION>",
					"git tag -d <TAG_VERSION>"
				]
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-local-tag",
			"title": "Git. Renombrar una etiqueta local",
			"description": "<p>Si utilizas etiquetas en tus proyectos, probablemente te hayas encontrado con algún problema que te haya obligado a eliminar la etiqueta:<ul><li>Hubo un cambio que debía enviarse con esta versión y te olvidaste de él.</li><li>Hay algún código de depuración que no debía incluirse con esta versión.</li><li>Hay un error tipográfico realmente obvio que todo el mundo notará de inmediato.</li></ul></p><p>Si aún no has subido la etiqueta al repositorio remoto, puedes renombrar la etiqueta con el siguiente comando:</p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Saber más</a></p>",
			"code": "git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "rename-and-upload-tag",
			"title": "Git. Renombrar una etiqueta y publicarla",
			"description": "<p>Si te has equivocado y necesitas renombrar una etiqueta y actualizarla en el repositorio remoto, debes seguir estos pasos:<ol></li><li>Renombrar la etiqueta local.</li><li>Eliminar la etiqueta antigua para que Git conozca el cambio.</li><li>Indicar al repositorio Git remoto que has eliminado la etiqueta antigua.</li><li>Actualizar las etiquetas del repositorio remoto para subir la nueva etiqueta.</li></ol></p>",
			"code": [
				"git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>",
				"git tag -d <OLD_TAG_VERSION>",
				"git push origin :refs/tags/<OLD_TAG_VERSION>",
				"git push --tags"
			]
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "update-remote-repository",
			"title": "Git. Actualizar el repositorio remoto",
			"description": "<p>Esto es muy deseable cuando se trabaja en un flujo de trabajo en equipo en el que las ramas remotas se eliminan después de la fusión con <code>master</code> o se quedan con etiquetas obsoletas.</p><p>En este caso, querrá eliminar las referencias a las ramas o etiquetas que ya no existen en el control remoto conectándose al control remoto y obteniendo el último estado antes de la poda.</br>Es esencialmente una combinación de comandos:</p>",
			"code": "git fetch --all && git remote prune"
		},
		{
			"parent": "git",
			"url": "command-git",
			"name": "update-local-tags",
			"title": "Git. Actualizar etiquetas remotas",
			"description": "<p>Si tu proyecto es de código abierto, probablemente tendrás que actualizar el estado de tu repositorio local de vez en cuando, ya que otras personas pueden haber eliminado o renombrado algunas etiquetas mientras estabas trabajando y ahora puedes tener etiquetas locales obsoletas.</p><p>Este comando poda las etiquetas que ya no existen en el repositorio remoto pero sí en tu repositorio local.</p>",
			"code": "git pull --prune --tags"
		}
	],
	"gitFlow": [
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "create-gitflow-repository",
			"title": "Git Flow. Inicializar el repositorio",
			"description": "<p>Git-flow es un <strong>flujo de trabajo</strong> aplicado a un repositorio Git.</br>Todo proyecto suele tener al menos 2 ramas infinitas: <code>develop</code> que contiene el código en desarrollo y <code>master</code> que contiene cada una de las versiones estables para incluir en producción.</br>Este modelo de ramificación, diseñado en torno a los lanzamientos del proyecto, tiene además un conjunto de ramas de apoyo, que están limitadas en el tiempo y son eliminadas eventualmente. Estas ramas permiten el trabajo en equipo, para la creación de nuevas funcionalidades (<code>feature</code>), resolución de errores en desarrollo (<code>bugfix</code>), resolución de errores urgentes en producción (<code>hotfix</code>) y la publicación de diferentes versiones (<code>release</code>).</p><p>Empieza a usarlo inicializándolo dentro de un repositorio Git existente con <code>git flow init</code>. Al comienzo, Git-flow necesita ser inicializado para personalizar la configuración del proyecto, tendrás que responder a algunas preguntas sobre las convenciones de nomenclatura de tus ramas, en este momento puedes cambiar el nombre de las ramas si lo deseas, aunque se recomienda utilizar los valores por defecto (<code>feature</code>, <code>release</code>, <code>hotfix</code> y <code>support</code>).</p>",
			"code": [
				[
					"git flow init"
				],
				[
					"git flow init",
					"",
					"Initialized empty Git repository in ~/project/.git/",
					"No branches exist yet. Base branches must be created now.",
					"Branch name for production releases: [master]",
					"Branch name for \"next release\" development: [develop]",
					"",
					"How to name your supporting branch prefixes?",
					"Feature branches? [feature/]",
					"Release branches? [release/]",
					"Hotfix branches? [hotfix/]",
					"Support branches? [support/]",
					"",
					"git branch",
					"* develop",
					"master"
				]
			]
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-start",
			"title": "Git Flow. Iniciar una nueva 'feature'",
			"description": "<p>Cuando se va desarrollar una nueva funcionalidad o característica del proyecto se crea una nueva rama llamada <code>feature</code>. Este tipo de ramas nacen a partir de la rama <code>develop</code> y una vez terminado su desarrollo, se incorporan nuevamente a ella.</p><p>El siguiente commando es un atajo, que engloba la ejecución de varios commandos:<ul><li><code>git checkout develop</code></li><li><code>git branch feature/&lt;BRANCH_NAME&gt;</code></li><li><code>git checkout feature/&lt;BRANCH_NAME&gt;</code></li></ul></p>",
			"code": [
				[
					"git flow feature start <FEATURE_NAME>"
				],
				[
					"git checkout -b feature/<FEATURE_NAME> develop"
				]
			]
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-list",
			"title": "Git Flow. Obtener la lista de 'features'",
			"description": "<p>Puedes ver una lista de las ramas <code>feature</code> ya creadas en el repositorio local usando el siguiente commando.</p>",
			"code": "git flow feature list"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-publish",
			"title": "Git Flow. Publicar una 'feature'",
			"description": "<p>Normalmente las <code>feature</code> existen solamente en los repositorios locales de los desarrolladores y no en el repositorio origen. Si quieres compartir esta rama con algunos miembros de tu equipo para poder hacer un desarrollo colaborativo, tendrías que publicar la <code>feature</code> en el servidor remoto para que pueda ser utilizada por otros usuarios.</p>",
			"code": "git flow feature publish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-pull",
			"title": "Git Flow. Conseguir una 'feature' publicada",
			"description": "<p>Cuando más de una persona trabaje a la vez en una <code>feature</code>, esta será publicada por tus compañeros de equipo, y podrás ser capaz de desarrollar en la misma rama con ellos.</p><p>Si es la primera vez que participas en el proyecto, primero tendrás que clonar repositorio usando <code>git clone &lt;URL&gt;</code> para tener una copia en tu ordenador (repositorio local), después inicializar Gitflow con <code>git flow init</code> y descargar las ramas <code>master</code> y <code>develop</code> con los comandos <code>git checkout master</code> y <code>git checkout develop</code>.</p><p>Si ya estás participando en el proyecto puedes saltarte los pasos anteriores y usar el siguiente comando para descargar una <code>feature</code> y para asegurar que el repositorio local está sincronizado con el remoto.</p>",
			"code": "git flow feature pull origin <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-track",
			"title": "Git Flow. Seguir una 'feature' publicada",
			"description": "<p>Digamos que has creado una nueva función con <code>git flow feature start &lt;FEATURE_NAME&gt;</code>, y la has publicado al repositorio remoto con <code>git flow feature publish &lt;FEATURE_NAME&gt;</code> para que otros miembros de tu equipo puedan colaborar contigo usando <code>git flow feature pull &lt;FEATURE_NAME&gt;</code> para descargarsela. Esto crea una nueva rama en su repositorio local, basada en la rama del remoto, sin embargo esto no la configura para que los cambios que se realizen en esta, sean rastreados por la rama remota, por lo que ahora tiene que ser rastreada manualmente.</p><p>Con el siguiente comando <code>git flow feature track &lt;FEATURE_NAME&gt;</code>, tu compañero de trabajo, puede descargar la <code>feature</code> y además seguir los cambios que otros realizen en la publicada en el repositorio de origen.</p><p>Para ilustrar el aspecto colaborativo con una rama de una nueva función, utilizando el aspecto de solicitud de extracción de GitHub que facilita la parte de revisión y discursión del código, nos ponemos en la siguiente situación:<ul><li>Varias personas trabajan en la misma función y a medida que se confirman los cambios, se envían a GitHub (o una vez al final de su desarrollo si se prefiere).</li><li>Cuando se completa la función, se abre una solicitud de extracción en GitHub comparando <code>develop</code> y con la rama.</li><li>El equipo revisa la solicitud de extracción y realiza comentarios.</li><li>Cualquier cambio de la solicitud de extracción se realiza en la rama de funciones.</li><li>Una vez que se incorporan todos los cambios en la rama de funciones se da por terminada: <code>git flow feature finish &lt;FEATURE_NAME&gt;</code>.</li><li>La rama <code>develop</code> se envía a GitHub (GitHub marcará automáticamente la solicitud de extracción como cerrada/fusionada cuando esto suceda).</li></ul><p>Sin embargo, eso deja el problema de cerrar esa sucursal, quien ejecute primero <code>git flow feature finish &lt;FEATURE_NAME&gt;</code> tendrá el lujo de eliminar su rama local, pero cualquier otra persona que haya verificado la rama tendrá que hacerlo manualmente si así lo desea. Puedes usar <code>git fetch --prune</code> o un simple <code>git fetch</code> para eliminar tu rama si ya ha sido eliminada en el remoto.</p><p>Si ya has descargado la rama y ahora necesitas realizar un seguimiento de esta, todo lo que tienes que hacer sería que tu rama existente rastree a la anterior con <code>git branch -u origin feature/&lt;FEATURE_NAME&gt;</code> o <code>git branch --set-upstream-to origin feature/&lt;FEATURE_NAME&gt;</code></p><p>En general, lo mejor sería empezar usando <code>git flow feature track &lt;FEATURE_NAME&gt;</code> y luego mantener tu rama actualizada con <code>git flow feature pull origin &lt;FEATURE_NAME&gt;</code></p></p><p><a href='https://stackoverflow.com/questions/18412750/why-doesnt-git-flow-feature-pull-track' target='_blank'>Know more</a></p>",
			"code": "git flow feature track <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-feature-finish",
			"title": "Git Flow. Terminar una 'feature'",
			"description": "<p>Cuando se finaliza el desarrollo de la nueva función, se deberá fusionar con <code>develop</code> y eliminarse del repositorio local y del remoto si llego a subirse.</p><p>El siguiente comando realiza los siguientes commandos:<ul><li><code>git checkout develop</code></li><li><code>git merge feature/&lt;FEATURE_NAME&gt;</code></li><li><code>git branch -D &lt;FEATURE_NAME&gt;</code></li><li><code>git push origin :&lt;FEATURE_NAME&gt;</code></li></ul></p>",
			"code": "git flow feature finish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-bugfix-start",
			"title": "Git Flow. Empezar un 'bugfix'",
			"description": "<p>Durante el desarrollo del proyecto podrán encontrase errores en alguna de las ramas del repositorio. Para solucionarlos tenemos 2 tipos de ramas diferentes según el lugar que ocupan estos errores en el flujo de trabajo de Git: <code>bugfix</code> y <code>hotfix</code>.</p><p>El término <code>bugfix</code> o <strong>corrección de errores</strong> se utilizan cuando se encuentra un problema durante la fase de desarrollo, para arreglar errores de una anterior funcionalidad u omisiones de desarrollo.</br>Este tipo de ramas se crean desde <code>develop</code> y se fusionan de nuevo en <code>develop</code> al terminarse.</p><p>El siguiente comando es lo mismo que ejecutar:<ul><li><code>git checkout develop</code></li><li><code>git branch bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git checkout bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>",
			"code": "git flow bugfix start <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-bugfix-finish",
			"title": "Git Flow. Terminar un 'bugfix'",
			"description": "<p>Las ramas <code>bugfix</code> o de corrección de errores son ramas temporales, que una vez resueltos los errores, se eliminan después de fusionarse con la rama de desarrollo <code>develop</code>.</p><p>El siguiente comando es lo mismo que ejecutar:<ul><li><code>git checkout develop</code></li><li><code>git merge bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git branch -D bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>",
			"code": "git flow bugfix finish <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-release-start",
			"title": "Git Flow. Empezar una 'release'",
			"description": "<p>Para preparar nuestra aplicación para su puesta en producción existen unas ramas llamadas <code>release</code>. En algunos equipos, estas ramas son las que se vuelcan en los servidores de pre-producción para hacer el testing final: se corrigen errores menores, se pule la interfaz, se ajusta la maquetación…se hace la puesta a punto final de la aplicación antes de liberar la versión definitiva.</p><p>El nombre de la <code>release</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión 'major' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión 'minor' (incorporación de una funcionalidad), y <code>Z</code> es la versión 'patch' (correción de errores compatibles con la versión anterior).</br>Por tanto, el número de la <code>release</code> sería el primero, <code>X</code>.</p><p>El siguiente comando crea una rama de lanzamiento a partir de la rama <code>develop</code>. Opcionalmente, se puede suministrar el id de un 'commit' situada en <code>develop</code> para iniciar el lanzamiento desde el 'commit'.</p><p><a href='https://aprendegit.com/git-flow-release-branches/' target='_blank'>Saber más</a></p>",
			"code": "git flow release start <VERSION_NUMBER> <[BASE]>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-release-list",
			"title": "Git Flow. Obtener una lista de 'release'",
			"description": "<p>Puede ver una lista de todas las ramas de lanzamiento actuales creadas en el repositorio local.</p>",
			"code": "git flow release list"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-release-publish",
			"title": "Git Flow. Publicar una 'release'",
			"description": "<p>Si esta trabajando en equipo y otro de sus compañeros debe revisar el código antes del lanzamiento de una nueva versión, es aconsejable publicar la rama de lanzamiento después de crearla para permitir que otros desarrolladores hagan 'commits' de lanzamiento.</p>",
			"code": "git flow release publish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-release-track",
			"title": "Git Flow. Seguir el rastro de una 'release'",
			"description": "<p>Puede seguir los cambios de una versión publicada en el repositorio remoto.</p>",
			"code": "git flow release track <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-release-finish",
			"title": "Git Flow. Terminar una 'release'",
			"description": "<p>Una vez creada la rama <code>release</code>, empezamos el proceso de corrección y depuración, se realizan los 'commits' necesarios y cuando hemos terminado de arreglar todos los 'bugs', estamos listos para que nuestro proyecto pase a producción y eliminar la rama.</p><p>Terminar una versión es uno de los grandes pasos en la creación de ramas de Git. El siguiente comando realiza varias acciones: fusiona la rama de la versión con <code>master</code>, etiqueta la versión con su nombre, vuelve a fusionar la versión con <code>develop</code> y elimina la rama de la versión.</p><p>Cuando ejecutamos este comando git-flow nos va a pedir que introduzcamos 3 mensajes: <ol><li>El mensaje del 'commit' del merge como resultado de incorporar los cambios en <code>master</code>.</li><li>El mensaje que git-flow pondrá a la etiqueta que va a crear para identificar esta versión.</li><li>Y por último el mensaje del 'commit' del merge como resultado de incorporar la rama a <code>develop</code>.</li></ol></p><p>La ejecución de este comando que pueden resumirse en los siguientes comandos:<ul><li><code>git checkout master</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git tag v&lt;VERSION_NUMBER&gt;</code></li><li><code>git checkout develop</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git branch -d release/&lt;VERSION_NUMBER&gt;</code></li></ul></p>",
			"code": "git flow release finish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-tags-push-single",
			"title": "Git Flow. Publicar una sola etiqueta",
			"description": "<p>Después de terminar la rama de lanzamiento, no olvide añadir las etiquetas al repositorio remoto. Este comando empujará una sola etiqueta al repositorio remoto.</p>",
			"code": "git push <REPO_NAME> <TAG_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-tags-push",
			"title": "Git Flow. Publicar todas las etiquetas",
			"description": "<p>Puedes añadir todas las etiquetas al repositorio remoto con un solo comando. Esta forma no se recomienda porque es común que los desarrolladores tengan etiquetas viejas o 'malas' en sus repositorios locales que no tienen necesidad de estar en el remoto, por lo que se aconseja sólo empujar explícitamente una etiqueta y no todas sus etiquetas a la vez.</p>",
			"code": "git push <REPO_NAME> --tags"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-hotfix-start",
			"title": "Git Flow. Iniciar un 'hotfix'",
			"description": "<p>Al igual que existen ramas para resolver errores que hemos encontrado durante el proceso de desarrollo, exisiten otro tipo de ramas. Estas ramas llamadas <code>hotfix</code>, se crean para actuar inmediatamente sobre un estado no deseado de una versión de producción en vivo, se utilizan para corregir errores u omisiones urgentes que no pueden esperar al lanzamiento de la siguiente versión.</br>El tiempo de vida de esta rama es temporal, se crea a partir de <code>master</code>, se fusiona de nuevo en <code>master</code> y se elimina después de la fusión.</p><p>El nombre del <code>hotfix</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión 'major' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión 'minor' (incorporación de una funcionalidad), y <code>Z</code> es la versión 'patch' (correción de errores compatibles con la versión anterior).</br>Por tanto, el número del <code>hotfix</code> sería el tercero y último, <code>Z</code>.</p><p>Opcionalmente, se puede especificar un nombre base, el id de un 'commit', desde el que crear la rama.</p>",
			"code": "git flow hotfix start <VERSION_NUMBER> <[BASE_NAME]>"
		},
		{
			"parent": "gitFlow",
			"url": "command-git-flow",
			"name": "gitflow-hotfix-finish",
			"title": "Git Flow. Terminar un 'hotfix'",
			"description": "<p>Cuando se han realizado todas las correciones en una rama <code>hotfix</code>, hay que realizar el siguiente comando para finalizar la rama. Este proceso fusiona la rama de nuevo con <code>develop</code> y <code>master</code>, crea una etiqueta con el número de versión del <code>hotfix</code> y elimina dicha rama, ya que su existencia es temporal.</p>",
			"code": "git flow hotfix finish <VERSION_NUMBER>"
		}
	]
}
