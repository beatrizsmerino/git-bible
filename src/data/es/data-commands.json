{
	"git": [
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-git-version",
			"title": "Git. Obtener la versión git",
			"description": "<p>Antes de instalar git, es conveniente comprobar si ya lo tienes instalado mediante el siguiente comando, que te devolverá el número de versión instalado en tu ordenador. Si no es así, sigue los pasos descritos en este <a href='https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git' target='_blank'>enlace</a> en función de tu sistema operativo.</p>",
			"code": "git --version"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-git-repository",
			"title": "Git. Inicializar el repositorio git",
			"description": "<p>Un repositorio git es un almacén virtual, te permite guardar versiones del código de tu proyecto a las que puedes acceder siempre que lo necesites. El siguiente comando, utilizado sólo una vez durante la configuración inicial de un nuevo repositorio, creará un nuevo subdirectorio <code>.git</code> en tu directorio de trabajo actual y una nueva rama <code>master</code>.</p><p><a href='https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init' target='_blank'>Saber más</a></p>",
			"code": "git init"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-configuration",
			"title": "Git. Mostrar la configuración",
			"description": "<p>Para visualizar nuestra configuración actual debemos saber que toda la configuración se guarda en el archivo <code>.gitconfig</code>, que se encuentra en: si eres <strong>Linux</strong> en el usuario <code>HOME</code> o si estás en <strong>Windows</strong> en <code>C:Users</code> o si eres <strong>Mac</strong> escribiendo en la <strong>consola</strong> <code>git config --list --show-origin</code>.</p>",
			"code": [
				["git config -l"],
				["git config --list"],
				["git config --global --list"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "config-user-name-email",
			"title": "Git. Configurar el nombre y el correo electrónico del usuario",
			"description": "<p>Git es un <strong>sistema de control de versiones distribuido</strong> que está siendo utilizado por la mayoría de los equipos de software hoy en día. Lo primero que debes hacer después de instalar Git en tu sistema es configurar tu nombre de usuario y dirección de correo electrónico de git. Git asocia tu identidad con cada commit que haces.</p><p>Git te permite establecer un nombre de usuario y una dirección de correo electrónico globales y por proyecto. Si modificas el nombre y el correo durante el desarrollo del repositorio, los cambios sólo afectan a futuros commits, el nombre y el correo electrónico asociados a los commits que hiciste antes del cambio no se ven afectados.</p><p>Puedes establecer o cambiar tu identidad git usando el siguiente comando.</p>",
			"code": [
				["git config --global user.name <USER_NAME>"],
				["git config --global user.email <USER_EMAIL>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "config-code-editor",
			"title": "Git. Añadir o editar el editor por defecto",
			"description": "<p>Cuando creas un commit de Git con <code>git commit -a</code>, el editor por defecto que se abrirá es <strong>Vim</strong>. Esto puede ser muy confuso para la gente, ya que Vim no es un editor fácil si nunca has trabajado con él previamente.</p><p>Hay muchas formas de hacerlo: a través del terminal con el siguiente comando, abriendo y editando el archivo <code>.gitconfig</code>...</p><p>En <strong>OSX</strong> para establecer <strong>Visual Studio Code</strong> como editor global de Git, hay que hacer los siguientes pasos: <ul><li>Abrir el editor y pulsar a la vez las teclas <code>Shift + Command + P</code>.</li><li>Escribir la palabra <code>Code</code> en la ventana emergente y hacer clic en <code>Shell Command: Install 'code' command in PATH</code> para hacer la instalación.</li><li>Y luego usa el segundo bloque de comandos de esta descripción, para ejecutar las 2 líneas en tu terminal. Esto lo define en su configuración como el editor global de Git y abre este mismo archivo de configuración con él.</li></ul></p><p><a href='https://stackoverflow.com/questions/34746045/set-visual-studio-code-to-be-global-git-editor-on-osx' target='_blank'>Saber más</a></p>",
			"code": [
				["git config --global core.editor <PATH/TO/EDITOR_CODE>"],
				[
					"git config --global core.editor 'code --wait'",
					"git config --global -e"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "open-file-with-editor",
			"title": "Git. Abrir un proyecto o archivo con el editor",
			"description": "<p>A través del terminal puedes abrir un archivo con tu editor de código preferido. Estos comandos abren un archivo con los editores SublimeText, Atom y Visual Studio Code.</p>",
			"code": [
				["subl <PATH/TO/FOLDER/FILE>"],
				["atom <PATH/TO/FOLDER/FILE>"],
				["code <PATH/TO/FOLDER/FILE>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "change-autor-email-last-commits",
			"title": "Git. Cambiar el nombre y el correo electrónico del autor de la último commit",
			"description": "<p>Si te has equivocado y has hecho tu commit con otro nombre o correo electrónico puedes sobrescribir la información del autor sólo del último commit con este comando.</p>",
			"code": "git commit --amend --author='<USER_NAME> <USER_EMAIL>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "change-autor-email-commits",
			"title": "Git. Cambiar el nombre y el correo electrónico del autor después de hacer un commit",
			"description": "<p>Si te has equivocado y has hecho varios commits con otro nombre o email de usuario puedes sobrescribir la información de autor de todos los commits con el siguiente comando.</p><p>Ten mucho cuidado si estos commits han sido subidos previamente al repositorio remoto y si hay más gente colaborando en el repositorio. Si este es el caso, es importante comunicarlo antes de hacer este comando, ya que también tendrás que sobrescribir los cambios en el repositorio remoto con <code>git push -f</code> y los demás colaboradores tendrán que actualizar su repositorio local con <code>git pull -f</code>. Este tipo de cambios es mejor hacerlos sin tener ningún cambio guardado en el <strong>área de preparación</strong> o en el <strong>directorio de trabajo</strong>.</p>",
			"code": [
				"#!/bin/sh",
				"",
				"git filter-branch --env-filter '",
				"WRONG_EMAIL=\"<USER_EMAIL>\"",
				"CORRECT_NAME=\"<USER_NAME>\"",
				"CORRECT_EMAIL=\"<USER_EMAIL>\"",
				"if [\"$GIT_COMMITTER_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"",
				"    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"if [\"$GIT_AUTHOR_EMAIL\" = \"$WRONG_EMAIL\"]",
				"then",
				"    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"",
				"    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"",
				"fi",
				"' --tag-name-filter cat -- --branches --tags"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits",
			"title": "Git. Obtener todos los commits realizados",
			"description": "<p>Después de haber realizado varios commits, o si ha clonado un repositorio que ya tenía un historial de commits, probablemente querrá mirar hacia atrás para ver qué modificaciones se han realizado.</p><p>Este comando muestra una lista de todos los commits realizados, en orden cronológico inverso, es decir, los más recientes se muestran al principio. Cada commit contiene información sobre el número de identificación (<em>Secure Hash Algorithm</em>, <code>SHA-1</code>), el nombre y la dirección de correo electrónico del autor, la fecha y el mensaje del commit.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones' target='_blank'>Saber más</a></p>",
			"code": "git log"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-oneline",
			"title": "Git. Obtener todos los commits realizados en una sola línea",
			"description": "<p>El comando <code>git log</code> tiene muchos parámetros opcionales para formatear la salida de la información del commit. La opción <code>--oneline</code> muestra la información de cada commit en una sola línea con los 6 primeros caracteres del número <code>SHA-1</code>, las ramas, las etiquetas y el mensaje.</p><p><a href='https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones#rlog_options' target='_blank'>Saber más</a></p>",
			"code": "git log --oneline"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-oneline-graph",
			"title": "Git. Obtener todos los commits realizados en un gráfico",
			"description": "<p>Este comando condensa la información de cada commit en una sola línea, mostrando sólo el ID del commit y la primera línea del mensaje del commit, resaltando todas las referencias (ramas, etiquetas...).</p><p>Dibuja una representación gráfica <em>ASCII</em> de la estructura del historial de commit. Imprime líneas adicionales entre los commits, para que el gráfico del historial se dibuje correctamente, y utiliza asteriscos para mostrar en qué rama estaba el commit.</p><p><a href='https://www.atlassian.com/git/tutorials/git-log' target='_blank'>Saber más</a></p>",
			"code": "git log --oneline --graph --decorate"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commit-without-merges",
			"title": "Git. Obtener todos los commits realizados, ocultando los commits de fusión",
			"description": "<p>Un <code>merge</code> es el resultado de fusionar 2 o más ramas. En ocasiones, con esa fusión se genera un commit extra llamado <code>merge commit</code>. La información de este commit contiene una mezcla de todos los cambios realizados en ambas ramas, esto puede resultar confuso. Podemos mostrar la lista de commits sin ellos con este comando.</p>",
			"code": "git log --oneline --no-merges"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-range",
			"title": "Git. Obtener commits entre rangos",
			"description": "<p>La forma más común de especificar un rango de commits es mediante la sintaxis de doble punto.</p><p>Esto por ejemplo, suele usarse para obtener un rango concreto de commits seleccionando la posición que ocupan en el histórico.</p><p>O por otro lado si seleccionamos 2 ramas mostrará todos los commits de la primera rama que no aparecen en la segunda. Esto es útil para previsualizar lo que se está a punto de fusionar o para ver lo que se está a punto de publicar en el repositorio remoto.</p><p><a href='https://git-scm.com/book/es/v2/Herramientas-de-Git-Revisi%C3%B3n-por-selecci%C3%B3n#r_commit_ranges' target='_blank'>Saber más</a></p>",
			"code": [
				["git log master~<POSITION_NUMBER>..master~<POSITION_NUMBER>"],
				["git log master..develop"],
				["git log origin/master..HEAD"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commit-by-date",
			"title": "Git. Buscar los commits por fecha",
			"description": "<p>Con los siguientes comandos podemos obtener una lista de commits según la fecha indicada (AAAA-MM-DD): <ul><li><code>--since</code> Commits desde la fecha.</li><li><code>--before</code> Commits anteriores a la fecha.</li><li><code>--after</code> Commits posteriores a la fecha.</li></ul></p>",
			"code": [
				["git log --since={<DATE>}"],
				["git log --before={<DATE>}"],
				["git log --after={<DATE>}"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-commits-of-file",
			"title": "Git. Mostrar sólo los commits en los que está involucrado un archivo",
			"description": "<p>Muestra todos los commits en los que se ha modificado el archivo indicado.</p>",
			"code": "git log --oneline -- <FILE_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-commits-regex",
			"title": "Git. Filtro de commit utilizando una expresión regular.",
			"description": "<p>Podemos buscar dentro de un repositorio git, en todas las ramas, los commits cuyo mensaje coincida con la expresión regular que le indiquemos.</p>",
			"code": "git log --grep='<REGEX>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-info-commit",
			"title": "Git. Mostrar la información de un commit",
			"description": "<p>Se trata de una herramienta de línea de comandos que se utiliza para ver detalles ampliados en objetos git como blobs, árboles, etiquetas y commits.</p><p>En el caso de un commit, muestra su información completa: id o <code>SHA-1</code>, autor, fecha y mensaje. </p><p>Hay muchas formas de acceder a la información de un commit:<br><ul><li>De forma absoluta, refiriéndose al código que lo identifica.</li><li>De forma relativa, refiriéndose al nombre de la rama del último commit.</li><li>A través de <code>HEAD</code>, accediendo al último commit que se ha realizado.</li><li>Por su posición en el árbol de git. Podemos ver todos los commits hacia atrás desde el momento que le digamos, con el signo <code>^</code> podemos ir 1 o 3 commits hacia atrás y con el signo <code>-</code> o <code>~</code> podemos especificar el número de commits hacia atrás que queremos ir hasta encontrar el que queremos ver.</li></ul></p>",
			"code": [
				["git show <COMMIT_ID>"],
				["git show <BRANCH_NAME>"],
				["git show HEAD"],
				["git show HEAD^"],
				["git show HEAD^^^"],
				["git show HEAD~<POSITION_NUMBER>"],
				["git show -<POSITION_NUMBER>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "summary-branches",
			"title": "Git. Mostrar ramas y sus commits",
			"description": "<p>Nos muestra un resumen de todas las ramas que hay en un proyecto junto con sus últimas modificaciones o commits.</p><p><a href='https://git-scm.com/docs/git-show-branch' target='_blank'>Saber más</a></p>",
			"code": [
				["git show-branch"],
				["git show-branch --list"],
				["git show-branch --more=-1"],
				["git show-branch --more=<NUMBER_COMMITS>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-date-commit",
			"title": "Git. Mostrar fecha de commit",
			"description": "<p>Un commit tiene 2 tipos de fechas: la fecha del autor y la fecha del commit.<ul><li>La <strong>fecha del autor</strong> indica cuándo se realizó originalmente esta confirmación, es decir, cuándo se realizó por primera vez el <code>git commit</code>.</li><li>La <strong>fecha de confirmación</strong> cambia cada vez que se modifica la confirmación, por ejemplo, cuando se sobreescribe el commit con <code>git commit --amend</code></li></ul></p><p>Con el siguiente comando podemos formatear la información de salida de un commit (2020-12-03 19:28:49 +0100).<ul><li><code>%ai</code>: <strong>fecha del autor</strong>, <em>ISO 8601-like</em> format</li><li><code>%ci</code>: <strong>fecha del commit</strong>, <em>ISO 8601-like</em> format</li></ul></p>",
			"code": "git show -s --format=%ci <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "overwrite-date-commit",
			"title": "Git. Sobrescribir la fecha de commit",
			"description": "<p>Este comando cambia la fecha de autor y committer del commit ya creado (2020-12-03 19:28:49 +0100).<br>¿Por qué cambiar dos fechas? El <strong>autor</strong> es la persona que escribió originalmente el trabajo, mientras que el <strong>committer</strong> es la persona que aplicó por última vez el trabajo. Si estamos trabajando solos en el proyecto, la fecha debe ser la misma en ambos casos.</p><p>Tenemos 2 formas de sobrescribir la fecha de un commit:</p><ul><li>Podemos modificar la fecha del <strong>último commit</strong> realizado con este primer comando.<br><a href='https://garysferrao.github.io/git/commit/date/2015/12/01/change-git-commit-date.html' target='_blank'>Saber más</a></li><li>O podemos modificar la fecha de un commit en particular filtrando la lista de commits <strong>por el id del commit</strong> a buscar. La fecha del primer commit realizado en un repositorio se puede modificar utilizando este segundo comando.<br><a href='https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git' target='_blank'>Saber más</a></li></ul><p>La segunda vez que ejecutemos cualquiera de estos comandos no podremos crear una nueva copia de seguridad. Debemos borrar la copia de seguridad anterior que ya existe en la carpeta <code>.git/refs/original/</code> o forzar la sobreescritura de la copia de seguridad con <code>-f</code>.</p>",
			"code": [
				[
					"GIT_COMMITTER_DATE='<YYYY-MM-DDThh:mm:ss±hh:mm>' git commit --amend --date='<YYYY-MM-DDThh:mm:ss±hh:mm>' -C <COMMIT_ID>"
				],
				[
					"git filter-branch --env-filter \\",
					"'if [ $GIT_COMMIT = <COMMIT_ID> ]",
					"then",
					"    export GIT_AUTHOR_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"    export GIT_COMMITTER_DATE=\"<YYYY-MM-DDThh:mm:ss±hh:mm>\"",
					"fi'"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "git-add",
			"title": "Git. Añadir carpetas y archivos al área de preparación",
			"description": "<p>Existen diferentes áreas en un repositorio git: el árbol de trabajo, el directorio de trabajo o espacio de trabajo, el área de preparación o índice, el stash, el repositorio local y el repositorio remoto. <ul><li>El <strong>espacio de trabajo</strong> contiene los archivos en los que estás trabajando actualmente, git notará los cambios (si no los has excluido previamente), pero no los guardará hasta que le digas explícitamente que los rastree.</li><li>El <strong>área de preparación</strong> contiene una instantánea del contenido que rastrea el árbol de trabajo. Esta instantánea representa el contenido del siguiente commit.</li></ul></p><p>Utilizamos el comando <code>git add</code> para añadir los cambios en el directorio de trabajo al área de preparación.<br>Puedes añadirlos todos a la vez (3 primeros comandos) o indicando las rutas de los archivos (último comando):</p>",
			"code": [
				["git add --all"],
				["git add -A"],
				["git add ."],
				["git add <PATH/TO/FOLDER/FILE>"],
				["git add <PATH/TO/FOLDER/FILE_1> <PATH/TO/FOLDER/FILE_2>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-status-files",
			"title": "Git. Mostrar el estado de los archivos en un directorio git",
			"description": "<p>Ejecutando este comando podemos ver la rama en la que nos encontramos y los archivos que contiene el área de preparación junto con su estado (nuevo/modificado/borrado). También nos avisa de los archivos no rastreados por git (untracked) o de los archivos con conflictos.</p>",
			"code": "git status"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-file-track",
			"title": "Git. Borrar y rastrear el archivo",
			"description": "<p>El comando <code>git rm</code> se utiliza para eliminar archivos individuales o un conjunto de archivos de un repositorio, el commando contrario sería <code>git add</code>.<br>La eliminación sólo afecta a las áreas del directorio de trabajo y al área de preparación, sólo actúa sobre la rama actual y sobre los archivos que no tengan cambios sin guardar. Este cambio no se almacena en el historial del repositorio hasta que se crea un nuevo commit.</p><p><strong>Por qué utilizar <code>git rm</code> en lugar de <code>rm</code></strong><br>Con el comando <code>rm</code>, un repositorio Git reconocerá cuando ha pasado por encima de un archivo que está siendo rastreado, actualizará el directorio de trabajo para reflejar la eliminación pero no el área de preparación. Es necesario ejecutar un comando adicional <code>git add</code> en las rutas de los archivos eliminados para añadir los cambios al área de preparación. El comando <code>git rm</code> actúa como un atajo ya que actualizará el directorio de trabajo y el índice de prueba con la eliminación.</p><p>Los siguientes comandos hacen:<ul><li><code>rm</code>: Elimina el archivo seleccionado y git no nota este cambio.</li><li><code>git rm </code>: Sólo funciona si el archivo ya estaba siendo rastreado, es decir, si se ejecutó un <code>git add</code> y un <code>git commit</code>. Elimina el archivo seleccionado, y añade los cambios al área de preparación.</li><li><code>git rm --cached</code>: Elimina el rastro del archivo seleccionado del control de versiones, sin borrar el archivo, esto se llama un <strong>fichero sin seguimiento</strong>.</li></ul></p><p><a href='https://www.atlassian.com/es/git/tutorials/undoing-changes/git-rm' target='_blank'>Saber más</a></p>",
			"code": [
				["rm <PATH/TO/FOLDER/FILE>"],
				["git rm <PATH/TO/FOLDER/FILE>"],
				["git rm --cached <PATH/TO/FOLDER/FILE>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-file-track",
			"title": "Git. Renombrar y rastrear el archivo",
			"description": "<p>Este comando funciona igual que el comando <code>git rm</code>.</p><p>Los siguientes comandos hacen:<ul><li><code>mv</code>: Modificar el nombre de un archivo sin que el git lo añada al área de preparación.</li><li><code>git mv</code>: Modificar el nombre de un archivo y que git rastree este cambio. Después de esto, si hacemos un <code>git status</code> aparecerá como renombrado.</li></ul></p>",
			"code": [
				["mv <OLD_FILE_NAME> <NEW_FILE_NAME>"],
				["git mv <OLD_FILE_NAME> <NEW_FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-commit",
			"title": "Git. Crear un commit con un mensaje",
			"description": "<p>Los commits se crean para capturar el estado de uno o más archivos del proyecto en un momento determinado. Son un <strong>conjunto de cambios</strong>, instantáneas o hitos en la historia de un proyecto git. Cada commit contiene la fecha en que se hizo, los cambios de cada archivo, la información del autor, un mensaje que describe el contenido del commit y un identificador único (<code>SHA-1</code>) para referenciar este commit.</p><p>Este comando sólo incluye las modificaciones de los archivos rastreados (aquellos que han sido añadidos con <code>git add</code> en algún momento de su historia). La opción <code>-m</code> o <code>--message</code> sirve para indicar el mensaje del commit.</p>",
			"code": "git commit -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "add-and-create-commit",
			"title": "Git. Añadir carpetas y archivos al área de preparación y crear un commit",
			"description": "<p>Si ya hemos hecho el primer <code>git add</code> y <code>git commit</code> de un archivo, es decir, git ya lo conoce, las próximas veces podemos usar otro comando que incluya ambos pasos en un solo comando. Esta combinación crea inmediatamente una commit de todos los cambios preparados y aplica un mensaje de commit en línea.</p><p>Es un comando de acceso directo para usuarios avanzados que combina las opciones <code>-a</code> o <code>--all</code> (añade los archivos modificados o borrados al escenario, pero no los recién creados, ya que no han sido reportados a git para su seguimiento) y <code>-m</code> o <code>--message</code> (con el mensaje especificado).</p><p><a href='https://www.atlassian.com/es/git/tutorials/saving-changes/git-commit' target='_blank'>Saber más</a></p>",
			"code": "git commit -am '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "commit-particular-file-on-index",
			"title": "Git. Confirmar un solo archivo en el área preparación",
			"description": "<p>Si tiene varios archivos añadidos al <strong>staging area</strong> y se arrepiente, porque sólo quiere añadir un archivo en particular, puede seleccionar el archivo y hacer un commit sólo de sus cambios.</p>",
			"code": ["git <FILE_NAME>", "git commit -am <COMMIT_MESSAGE>"]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "overwrite-last-commit",
			"title": "Git. Sobrescribir el último commit",
			"description": "<p>Si un mensaje o archivo de commit contiene información poco clara, incorrecta, sensible o que falta, puedes corregirlo localmente y crear un commit con un nuevo mensaje. <br>Al ejecutar este comando se abrirá un editor de texto y te pedirá que edites el mensaje y guardes el commit. Este proceso cambiará el ID de el commit, creando una nueva commit que sustituye a la anterior.</p><p><a href='https://blog.kirei.io/buenas-pr%C3%A1cticas-para-los-mensajes-de-commit-en-git-a9fc43a83821' target='_blank'>Saber más</a></p>",
			"code": [
				["git commit --amend"],
				["git commit --amend", "git push -f"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-commit",
			"title": "Git. Eliminar una commit",
			"description": "<p>El comando <code>git reset</code> es una herramienta para deshacer cambios. Si lo ejecutamos sin indicar un SHA de commit, sólo eliminará los cambios añadidos al área de preparación.</p><p>Tiene 3 argumentos que se corresponden con los 3 mecanismos internos de gestión de estados de Git, el árbol de commit (HEAD), el área de preparación y el directorio de trabajo. </p><p>Cuando especificamos el tipo de reset que queremos con uno de estos argumentos, indicamos el commit SHA anterior a todos los que queremos borrar: <ul><li><code>--mixto</code>: Es la opción por defecto, provoca el mismo efecto que ejecutar<code>git reset</code>. Elimina los commits posteriores al commit seleccionado. Elimina los cambios del área de preparación, pero mantiene los del directorio de trabajo.</li><li><code>--soft</code>: Elimina los commits posteriores al commit seleccionado, pero mantiene los cambios añadidos al área de preparación y conserva los realizados en el directorio de trabajo.</li><li><code>--hard</code>: Es la opción más peligrosa porque se pierden todos los cambios realizados. Elimina los commits posteriores al commit seleccionado, lo que también elimina los cambios del área de preparación y del directorio de trabajo.</li></ul></p>",
			"code": [
				["git reset --soft <idCommit>"],
				["git reset --mixed <idCommit>"],
				["git reset --hard <idCommit>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "squashing-commits",
			"title": "Git. Aplastamiento o fusión de confirmaciones",
			"description": "<p>El proceso de borrar un número de commits con el argumento <code>--soft</code> y luego hacer un commit se suele llamar hacer <strong>squashing</strong>, ya que es como compactar varios commits en uno.</p>",
			"code": [
				"git reset --soft master~<NUMBER_LAST_COMMITS>",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "revert-commit",
			"title": "Git. Revertir los cambios de un commit y crear uno nuevo",
			"description": "<p>Este commando nos permite crear un commit con los cambios revertidos de la referencia indicada, es decir, si tenemos un commit que añadía una línea y borraba dos, ahora estamos creando otro commit que borra la línea añadida y añade las dos borradas.<br>Tras ejecutar este comando en la consola, nos pedirá el mensaje y creará un nuevo commit.</p>",
			"code": "git revert <COMMIT_ID>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "add-stash",
			"title": "Git. Guardar los cambios en el 'stash'",
			"description": "<p>Git tiene un área llamada <strong>stash</strong> donde puedes almacenar temporalmente una instantánea de tus cambios sin confirmarlos en el repositorio. Está separada del directorio de trabajo, del área de preparación o del repositorio.<br> Esta funcionalidad es útil cuando has hecho cambios en una rama que no estás listo para confirmar, pero necesitas cambiar a otra rama. Esto guarda tus cambios, que estarán disponibles desde cualquier rama en ese repositorio y revierte el directorio de trabajo a como estaba para el último commit.<br>Note que los cambios que quiere almacenar necesitan estar en archivos rastreados. Si ha creado un nuevo archivo y trata de almacenar sus cambios, puede obtener el error <em>'No hay cambios locales para guardar'</em>.</p><p>Las instantáneas se guardan en el formato <code>stash@{0}: BRANCH: SHA MESSAGE</code>. Se guardarán con un identificador del tipo <code>stash@{0}</code>, donde <code>stash</code> indica que es una instantánea y el número entre las llaves, <code>{0}</code> es el índice de ese <code>stash</code>. El número del índice crece a medida que se crean nuevas instantáneas y se ordenan de forma inversa, es decir, el número más pequeño será siempre la última instantánea realizada. Se indica la rama en la que se hicieron los cambios, y el identificador y el mensaje serán los mismos que el último commit que tengamos en el repositorio.</p><p>Por defecto, envía todos los ficheros que tengamos en el directorio de trabajo y en el área de preparación, excepto los no rastreados, a la zona <code>stash</code>. Y genera el mensaje automáticamente. Pero hay varias opciones que podemos añadir al comando:<ul><li><code>--include-untracked</code> o <code>-u</code>: Añade también los archivos no rastreados.</li><li><code>--all</code> o <code>-a</code>: Añade también los archivos no rastreados e ignorados (.gitignore).</li><li><code>--patch</code>: Git no almacenará todo lo que se modifique, sino que nos preguntará de forma interactiva cuáles de los cambios queremos almacenar y cuáles queremos mantener en nuestro directorio de trabajo.</li><li><code>push -m</code>: Nos permite especificar un mensaje para el commit que estamos enviando al stash.</li><li><code>save</code>: Está obsoleto en favor de <code>push -m</code>.</li></ul></p><p><a href='https://www.freecodecamp.org/news/git-stash-explained/' target='_blank'>Saber más</a></p>",
			"code": [
				["git stash"],
				["git stash -u"],
				["git stash -a"],
				["git stash --patch"],
				["git stash push -m '<STASH_MESSAGE>'"],
				["git stash save '<STASH_MESSAGE>'"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-stash-list",
			"title": "Git. Obtener una lista de los 'stash' guardados",
			"description": "<p>Cuando tienes muchas instantáneas guardadas, te conviene ver una lista de todas ellas para poder seleccionarlas. El mensaje y el id, que por defecto vienen del commit, te ayudarán a diferenciarlos.<br>Es recomendable limpiar el alijo o borrar aquellas instantáneas que no necesitemos para no acumularlas.</p>",
			"code": "git stash list"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-stash",
			"title": "Git. Volver a aplicar los cambios guardados en el 'stash'",
			"description": "<p>Hay dos formas diferentes de recuperar los cambios guardados en el stash: <code>apply</code> y <code>pop</code>.</p><p>Por defecto, ejecutando cualquiera de estos 2 comandos podemos recuperar el último stash guardado, <code>stash@{0}</code>. La diferencia es que la opción <code>apply</code>, mantiene el cambio en la lista para una posible reutilización posterior, y <code>pop</code> tras aplicar el cambio lo elimina de la pila de stash, pero si durante este proceso hay conflictos, no lo elimina, dejando que se comporte exactamente como la opción <code>apply</code>.<br>Otra forma de hacer lo mismo que con la opción <code>pop</code> es hacerlo en 2 pasos: <code>git stash apply</code> && <code>git stash drop</code>.</p><p>También podemos obtener los cambios de un stash concreto de nuestra pila, indicando su número de índice.</p><p><a href='https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning#_git_clean' target='_blank'>Saber más</a></p>",
			"code": [
				["git stash apply"],
				["git stash pop"],
				["git stash apply", "git stash drop"],
				["git stash apply stash@{<STASH_NUMBER>}"],
				["git stash apply <STASH_NUMBER>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-stash-branch",
			"title": "Git. Crear una rama a partir de un 'stash'",
			"description": "<p>Este es un buen atajo para recuperar el código almacenado en stash indicado y crear una nueva rama para trabajar en el por separado. Este comando crea una nueva rama con el último stash (<code>stash@{0}</code>), y luego lo borra (<code>git stash pop</code>). Si necesitas un stash en particular puedes especificar el id del stash.</p><p>Esto será útil cuando te encuentres con conflictos después de haber aplicado el stash a la última versión de tu rama.</p><p><a href='https://www.freecodecamp.org/news/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a/' target='_blank'>Saber más</a></p>",
			"code": [
				["git stash branch <BRANCH_NAME>"],
				["git stash branch <BRANCH_NAME> stash@{<STASH_NUMBER>}"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "show-stash",
			"title": "Git. Mostrar las diferencias del 'stash'",
			"description": "<p>La opción <code>show</code> del comando <code>stash</code> ofrece un resumen muy breve de los cambios realizados en los archivos. Muestra en una línea la ruta y el nombre del fichero, y el número de líneas eliminadas.</p><p>Por defecto, muestra la información del último stash (<code>stash@{0}</code>), pero podemos indicar un número de índice para ver algún otro.</p><p>Si queremos profundizar y ver todos los cambios de cada línea del fichero en el editor del terminal podemos utilizar la opción <code>-p</code>.</p><p><a href='https://howto.lintel.in/how-to-see-stashed-changes-using-git-stash/' target='_blank'>Saber más</a></p>",
			"code": [
				["git stash show"],
				["git stash show stash@{<STASH_NUMBER>}"],
				["git stash show -p"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-stash",
			"title": "Git. Eliminar el stash",
			"description": "<p>Hay dos formas diferentes de eliminar los cambios guardados en el área de stash: <code>drop</code> y <code>clear</code>.</p><p>Podemos eliminar el primer elemento guardado en el stash (el último stash: <code>stash@{0}</code>) con <code>drop</code> o si ya no necesitas un stash en particular, seleccionarlo por su número de índice.</p><p>Pero, si lo que queremos es limpiar el área de almacenamiento por completo, la opción <code>clear</code> borra toda la lista de stashes.</p><p><strong>ADVERTENCIA IMPORTANTE</strong>: Con la opción <code>clear</code> esos estados serán entonces objeto de poda, y puede ser imposible recuperarlos. Utilice ambas opciones con precaución, ya que puede ser difícil revertir los stashes una vez borrados.</p> <p>Para confirmar si todo se ha borrado, obtenga de nuevo la lista de stashes con el comando <code>git stash list</code>.</p><p><a href='https://kolosek.com/git-stash/' target='_blank'>Saber más</a></p>",
			"code": [
				["git stash drop"],
				["git stash drop stash@{<STASH_NUMBER>}"],
				["git stash drop <STASH_NUMBER>"],
				["git stash clear"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "exit-without-save",
			"title": "Git. Salir de la ventana de texto sin guardar",
			"description": "<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres simplemente salir de la ventana de texto sin guardar los cambios, escribe el comando y pulsa <em>'enter'</em>.</p>",
			"code": ":q!"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "exit-and-save",
			"title": "Git. Salir de la ventana de texto, después de guardar",
			"description": "<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres salir de la ventana de texto y guardar los cambios, escribe el comando y pulsa <em>'enter'</em>.</p>",
			"code": ":wq"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "reflog",
			"title": "Git. Ver registro de referencia (reflog)",
			"description": "<p>Antes de hablar del diario de referencias, hay que recordar que <code>HEAD</code> es una referencia (es decir, un puntero) que apunta al commit más reciente de la rama actual.</p><p>Existe un registro de todas las referencias tomadas por el puntero <code>HEAD</code> en Git llamado <strong>reflog</strong>. Es un listado que almacenará todos los commits por los que pase el puntero, por ejemplo, podrá guardar los cambios de una rama o la adición de un commit.</p><p>Este comando puede ser muy útil, en el caso de que queramos recuperar un commit borrado.<ul><li><code>git reflog</code>: Te va a mostrar todos los commits que realizaste sin importar si los borraste o no. Cada commit mostrara una pequeña información de si mismo: su número de hash (6 cifras), la rama a la que pertenece, el índice de la posición que ocupa su puntero <code>HEAD</code> y la primera línea del mensaje.</li><li><code>git show &lt;COMMIT_ID&gt;</code>: Viendo esta información podemos encontrar el commit que queremos y acceder a él mediante su número de hash. Así podemos ver en detalle su información: su número de hash completo, el autor y la fecha del commit, el mensaje del commit completo y que archivos y líneas se han añadido, eliminado o modificado.</li><li><code>git reset --mixed &lt;COMMIT_ID&gt;</code>: Usamos este comando, una vez estamos seguros de que queremos recuperar este commit y asi obtendremos de nuevo los archivos con los cambios que habiamos eliminado. Este comando no genera un commit con estos cambios, así que tendremos que ejecutar un <code>git commit</code> para volver a guardarlos. Podremos recuperar el mensaje que habiamos usado con el commando anterior <code>git show</code>, ya que nos mostraba el mensaje completo.</li></ul></p>",
			"code": [
				["git reflog"],
				[
					"git reflog",
					"git show <COMMIT_ID>",
					"git reset --mixed <COMMIT_ID>"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "reflog-remove",
			"title": "Git. Podar todas las referencias con la recogida de basura y recuperar espacio",
			"description": "<p>El subcomando <code>expire</code> limpia las entradas de <strong>reflog</strong> viejas o inalcanzables. Tiene un potencial de pérdida de datos y no suele ser utilizado por los usuarios finales, pero sí por git internamente. Por defecto, la fecha de caducidad de <strong>reflog</strong> se establece en 90 días. Se puede especificar un tiempo de caducidad pasando un argumento de línea de comandos o estableciendo un nombre de configuración de git.</p>",
			"code": [
				"rm -rf .git/refs/original/",
				"git reflog expire --expire=now --all",
				"git gc --aggressive --prune=now"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches",
			"title": "Git. Obtener todas las ramas",
			"description": "<p>A veces es necesario saber qué ramas existen en un repositorio remoto para determinar los nombres de las ramas disponibles.</p><p>Con este comando puedes listar ambos tipos de ramas: remotas y locales. La rama actual aparecerá resaltada en color y marcada con un asterisco <code>*</code>.</p>",
			"code": [["git branch --all"], ["git branch -a"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches-local",
			"title": "Git. Obtener todas las ramas locales",
			"description": "<p>Una rama local es aquella cuyo nombre completo empieza por <code>refs/heads/</code>, el comando <code>git branch</code> quita esta parte para hacerlo más fácil.</p><p>Parece que con git siempre hay más de una forma de hacer la misma cosa:</p>",
			"code": [["git branch"], ["git branch --list"], ["git branch -l"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-branches-remotes",
			"title": "Git. Obtener todas las ramas remotas",
			"description": "<p>Una rama de seguimiento remoto es aquella cuyo nombre completo empieza por <code>refs/remotes/</code>, este comando elimina esta parte para facilitarlo.</p>",
			"code": [["git branch --remotes"], ["git branch -r"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-branch",
			"title": "Git. Crear una nueva rama",
			"description": "<p>Puedes crear una nueva rama mientras estás en otra y moverte a ella más tarde.</p>",
			"code": "git branch <NEW_BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "checkout-branch-path",
			"title": "Git. Checkout branch/path",
			"description": "<p>El comando <code>git checkout &lt;NAME&gt;</code> está realmente pensado para ramas, pero la sintaxis de Git es relajada, y si Git no puede encontrar una rama, entonces buscará un archivo.</p><p>Supongamos que tienes un archivo y una rama que se llaman igual, <code>stuff</code>. Entonces el siguiente comando parecería ambiguo, <code>git checkout stuff</code>, porque no está claro si estás pidiendo la salida de un archivo o de una rama.<br> Con <code>--</code> es una forma de decirle a Git que trate lo que sigue a <code>checkout</code> como un archivo y no como una rama, cuando lo usas, le dice explícitamente a Git que saque un archivo con ese nombre/ruta</p><p>Este comando hizo: <ul><li>Si es una rama local o rama remota rastreada, cambia a ella.</li><li>Si es una ruta rastreada de un archivo, lo restablece, es decir, borra los cambios no guardados del directorio de trabajo.</li><li>Si es una rama remota, crea una rama de seguimiento y cambia a ella.</li></ul><p>Así que en este caso los siguientes comandos permiten mover una rama local o descargarla de la remota y restablecer un archivo:</p>",
			"code": [
				["git checkout <BRANCH_NAME>"],
				["git checkout -- <FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "move-to-branch",
			"title": "Git. Desplazarse a la rama",
			"description": "<p>Cuando intentas moverte a una rama local que no existe, este comando buscará si hay una rama de seguimiento remoto con un nombre similar. Si es así, creará la rama local y la configurará para seguir la rama de seguimiento remoto.</p>",
			"code": "git checkout <BRANCH_NAME>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-and-move-to-branch",
			"title": "Git. Crear y moverse a una rama",
			"description": "<p>Debes utilizar una rama distinta para cada función o problema en el que trabajes. Con este comando se hacen 2 pasos a la vez, crear y moverse a la rama para que todos los cambios que hagas se apliquen a ella.<br>La opción <code>-b</code> le dice a git que la cree si no existe ya, de lo contrario, se restablece, es decir, la rama no se restablece/crea a menos que <code>git checkout</code> tenga éxito.</p>",
			"code": [
				["git checkout -B <NEW_BRANCH_NAME>"],
				["git checkout -b <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "extract-files-from-staging-area",
			"title": "Git. Extraer los archivos del área de preparación",
			"description": "<p>Si ya he añadido el archivo con un <code>git add</code> al <strong>staging area</strong> pero no quiero hacer commit todavía, y quiero eliminarlo de esta zona, estas son algunas formas de solucionarlo:<ul><li><code>git reset &lt;FILE_NAME&gt;</code>: Si los cambios se han realizado y añadido al <strong>staging area</strong>.</li><li><code>git rm --cached &lt;FILE_NAME&gt;</code>: Si aún no he lanzado un commit, y por tanto no se ha creado el puntero <code>HEAD</code>.</li><li><code>git reset HEAD &lt;FILE_NAME&gt;</code>: Si ya he lanzado mi primer commit, es decir, hay un puntero HEAD. Git se mueve entre los commits apuntando siempre al último creado.</li></ul></p>",
			"code": [
				["git reset <FILE_NAME>"],
				["git rm --cached <FILE_NAME>"],
				["git reset HEAD <FILE_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-current-branch",
			"title": "Git. Renombrar la rama actual",
			"description": "<p>Es posible que en algún momento, como ocurre con los mensajes de commit, quieras renombrar una rama.<br>Con este comando puedes renombrar la rama local en la que estás trabajando.</p><p>Tiene parámetros opcionales: <ul><li><code>--mover</code> o <code>-m</code>: Mover/renombrar una rama y el correspondiente <strong>reflog</strong>.</li><li><code>-M</code>: Es un atajo de <code>--delete --force</code></li></ul></p><p><a href='https://git-scm.com/docs/git-branch' target='_blank'>Saber más</a></p>",
			"code": [
				["git branch -m <NEW_BRANCH_NAME>"],
				["git branch -M <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-local-branch",
			"title": "Git. Rename a local branch",
			"description": "<p>Puedes renombrar una rama local mientras te encuentras en cualquier otra rama.</p>",
			"code": [["git branch -m <OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-remote-branch",
			"title": "Git. Renombrar una rama remota",
			"description": "<p>Supongamos que estás colaborando en un proyecto con un grupo de personas, y habeis definido una convención de nombres para las ramas de git. Tu has creado una nueva rama, has enviado los cambios al repositorio remoto y te has dado cuenta de que el nombre de tu rama era incorrecto. Por suerte, git te permite renombrar la rama local y la remota muy fácilmente usando varios comandos o haciendo lo mismo con uno solo.</p><p><a href='https://linuxize.com/post/how-to-rename-local-and-remote-git-branch/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git checkout <OLD_BRANCH_NAME>",
					"git branch -m <NEW_BRANCH_NAME>",
					"git push origin -u <NEW_BRANCH_NAME>",
					"git push origin --delete <OLD_BRANCH_NAME>"
				],
				["git push origin :<OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "upload-local-branch",
			"title": "Git. Publicar una rama local a un repositorio remoto",
			"description": "<p>Se recomienda enviar la nueva rama al repositorio remoto (<code>ORIGIN</code>), ya que esto actúa como copia de seguridad, y al colaborar con otros desarrolladores, les permite acceder a ver los commits realizados en la nueva rama.<br> La opción <code>-u</code> o <code>--set-upstream-to</code> la añade como rama de seguimiento remoto.</p>",
			"code": [
				["git branch --set-upstream-to origin/<OTHER_BRANCH_NAME>"],
				["git push origin -u <NEW_BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-branch",
			"title": "Git. Eliminar una rama",
			"description": "<p>Para eliminar una rama del repositorio git no debes estar posicionado en ella.</p>",
			"code": [
				["git branch -D <BRANCH_NAME>"],
				["git branch -d <BRANCH_NAME>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "merge",
			"title": "Git. Fusionar una rama",
			"description": "<p>La fusión es la forma que tiene Git de volver a unir un historial bifurcado. El comando <code>git merge</code> permite tomar las líneas de desarrollo independientes creadas por el comando <code>git branch</code> e integrarlas en una única rama.<br>Toma dos punteros de commit de los extremos de cada rama y los combina en la rama actual, generando un nuevo <strong>commit de fusión</strong>. Sin embargo, si git encuentra datos que han sido cambiados en ambos historiales, no podrá combinarlos automáticamente. En ese caso, se crea un conflicto de control de versiones y Git pedirá la intervención del usuario para continuar.</p><p>Antes de realizar una fusión hay un par de pasos de preparación para asegurar que la fusión se realice sin problemas: <ul><li><strong>Confirmar la rama receptora:</strong> Asegúrate de que <code>HEAD</code> apunta a la rama correcta con el comando <code>git status</code>. Si es necesario, ejecute <code>git checkout</code> para cambiar a la rama receptora.</li><li><strong>Obtener los últimos commits remotos: </strong> Asegúrate de que la rama receptora y la rama de fusión están actualizadas con los últimos cambios remotos. Ejecute <code>git fetch</code> para obtener los últimos commits remotos. Una vez que el fetch se ha completado asegúrese de que la rama maestra tiene las últimas actualizaciones ejecutando <code>git pull</code>.</li></ul></p><p>Esto significa que <code>git merge</code> se utiliza a menudo junto con <code>git checkout</code> para seleccionar la rama actual y <code>git branch -d</code> para eliminar la rama de destino obsoleta. </p> <p>Si las dos ramas que estás intentando fusionar han cambiado la misma parte del mismo archivo, Git no será capaz de averiguar qué versión usar. Cuando se produce esta situación, se detiene justo antes de crear el <strong>commit de fusión</strong> para que puedas resolver los conflictos manualmente. Cuando Git encuentra un conflicto durante una fusión, editará el contenido de los archivos afectados con indicadores visuales que marcan ambos lados del contenido en conflicto <code><<<<<<<</code> <code> =======</code> <code>>>>>>>></code>. El contenido anterior al marcador <code>=======</code> es la rama receptora y la parte posterior es la rama de fusión. Una vez que hayas identificado las secciones conflictivas, puedes entrar y arreglar la fusión a tu gusto. Cuando estés listo para terminar la fusión, todo lo que tienes que hacer es ejecutar <código>git add</código> en los archivos en conflicto para decirle a Git que están resueltos. Luego, ejecuta <code>git commit</code> para generar el <strong>commit de fusión</strong>.</p><p><a href='https://www.atlassian.com/es/git/tutorials/using-branches/git-merge' target='_blank'>Saber más</a></p>",
			"code": [
				["git merge <BRANCH_NAME>"],
				["git merge --continue"],
				["git merge --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-merge-commit",
			"name": "commands-merge-commit",
			"title": "Git. Fusionar una rama y crear un commit",
			"description": "<p>La opción <code>--no-ff</code> evita que <code>git merge</code> ejecute un <strong>'fast-forward'</strong> si detecta que tu <code>HEAD</code> actual es un ancestro del commit que estás intentando fusionar. Un <strong>fast-forward</strong> (adelantar rápidamente) es cuando, en lugar de construir un <strong>commit merge</strong> (confirmación de fusión), git simplemente mueve tu puntero de rama para apuntar a la confirmación entrante.</p><p>En ocasiones quieres evitar que este comportamiento ocurra, normalmente porque quieres mantener una topología de rama específica (por ejemplo, estás fusionando en una rama temática y quieres asegurarte de que se vea así al leer el historial). Para ello, puedes pasar esta opción <code>--no-ff</code> y <code>git merge</code> siempre construirá una fusión en lugar de <strong>fast-forwarding</strong>.</p>",
			"code": ["git merge <BRANCH_NAME> --no-ff"]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rebase",
			"title": "Git. Rebasar una rama",
			"description": "<p>En Git tenemos dos formas de integrar los cambios de una rama a otra: la fusión (<code>merge</code>) y la reorganización (<code>rebase</code>).</p> <p>Git <code>rebase</code> nos permite modificar el historial de Git utilizando un punto de referencia. Captura todos los cambios confirmados de la rama en la que estamos y los aplica a la que le estamos indicando, es decir, es capaz de reconocer que commits no están en la línea de tiempo de ese punto de referencia y aplicarlos sobre el punto de referencia, es lo que llamamos en Git <strong>rebasing</strong>. <br>En contraste con el merge, esto genera una historia del proyecto perfectamente lineal, pudiendo ir desde el final de la rama hasta el inicio del proyecto sin encontrar ninguna bifurcación.</p><p>Es muy importante entender que, aunque la rama parezca la misma, está formada por commits totalmente nuevos, lo que cambia la historia de Git. Esto implica que estos commits se están recreando con el mismo mensaje y contenido, lo que puede dar lugar a <strong>conflictos</strong> a la hora de aplicarlos a la nueva rama si ésta tiene nuevos cambios.<br>Si esto ocurre, hay que resolverlos a medida que se producen y se consideran modificaciones del propio commit. Esto nos permite borrar, reordenar, fusionar o cambiar el mensaje del commit antes de aplicarlos. Cuando tengas los cambios arreglados, tendrás que pedirle al comando que continúe con la opción <code>--continue</code> para aplicar el siguiente commit.<br>En cualquier momento durante <code>rebase</code> si cambias de opinión puedes rechazar todo el proceso con la opción <code>--abort</code>.</p>",
			"code": [
				["git rebase <BRANCH_NAME>"],
				["git rebase --continue"],
				["git rebase --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "cherry-pick",
			"title": "Git. Cherry-pick: Copiar y pegar commits",
			"description": "<p>Puede ocurrir que, en algún momento, queramos aplicar algunos de los cambios que hemos hecho en otra rama sin tener que hacer un merge completo. El comando <code>cherry-pick</code> permite <em>'copiar'</em> uno o varios commits de una rama y <em>'pegarlos'</em> en otra rama. Antes de utilizarlo, debe tener un <strong>directorio de trabajo</strong> y <strong>zona de preparación</strong> limpios. </p><p>Por defecto, <code>cherry-pick</code> mantiene el mensaje de commit original, por lo que la opción <code>-x</code> puede ser útil para añadir una referencia a el commit original y así para saber de dónde se ha obtenido el commit. Otras opciones interesantes son <code>-e</code>, que permite editar el mensaje de commit en lugar de utilizar el original y la opción <code>-n</code> que aplicará los cambios pero no hará ningun commit. </p><p>Al igual que con los comandos <code>merge</code> y <code>rebase</code>, tras resolver los conflictos, podemos indicar que se sigan aplicando los cambios con la opción <code>--continue</code> o rechazar el proceso completamente con la opción <code>--abort</code>.</p><p><a href='https://www.runroom.com/realworld/seleccionando-commits-cherry-pick' target='_blank'>Saber más</a></p>",
			"code": [
				["git cherry-pick"],
				["git cherry-pick <COMMIT_ID>"],
				["git cherry-pick -x"],
				["git cherry-pick -e"],
				["git cherry-pick -n"],
				["git cherry-pick --continue"],
				["git cherry-pick --abort"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "diff",
			"title": "Git. Comparar cambios con git diff",
			"description": "<p>Podemos ver qué cambios se han hecho en el código con el comando <code>diff</code>. Este, muestra en la terminal las líneas de código que se han eliminado con el símbolo <code>-</code> y en color rojo, y las líneas añadidas con el símbolo <code>+</code> y de color verde.</p><p>La siguiente herramienta online puede ayudarte. <strong>DiffMerge</strong> es una aplicación para comparar y fusionar visualmente archivos en Windows, OSX y Linux: <a href='http://sourcegear.com/diffmerge/' target='_blank'>http://sourcegear.com/diffmerge/</a></p><p>También podemos comparar los cambios que se han realizado en el código de varios commits.</p><p><a href='https://www.atlassian.com/git/tutorials/saving-changes/git-diff' target='_blank'>Saber más</a></p>",
			"code": [["git diff"], ["git diff <idCommit1> <idCommit2>"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "mark-conflicts-resolved",
			"title": "Git. Marcar el conflicto como resuelto",
			"description": "<p>Pasos a seguir tras resolver un conflicto en los archivos: <ul><li>Añadir todos los archivos a la zona de preparación</li><li>Ver el estado de los archivos (modificados/borrados/añadidos)</li><li>Crear un commit con esos cambios indicando una descripción de lo que se ha realizado</li></ul></p>",
			"code": [
				"git add .",
				"git status",
				"git commit -m '<COMMIT_MESSAGE>'"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "get-tags",
			"title": "Git. Obtener todas las etiquetas realizadas",
			"description": "<p>Obtenga una lista simple de las etiquetas, si quiere asegurarse de que existen y cuáles son sus números de versión.</p>",
			"code": [["git tag --list"], ["git tag -l"]]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "create-tag",
			"title": "Git. Crear una nueva etiqueta",
			"description": "<p>En el desarrollo de software, las etiquetas git representan una versión de nuestro código en un momento dado. A diferencia de las ramas, las etiquetas no son mutables y siempre apuntan al mismo commit, por lo que la gente generalmente las utiliza para marcar puntos importantes en la historia de git (como los puntos de liberación v1.0, v2.0 y así sucesivamente).</p><p>El <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a> utiliza un formato de versión basado en números 3 enteros separados por puntos: <code>X.Y.Z</code> (<em>Major.Minor.Patch</em>), los arreglos de bugs que no cambian el API incrementan el patch, los cambios y adiciones que no rompen la compatibilidad de las dependencias anteriores incrementan el minor, y los cambios que rompen la compatibilidad incrementan el major. Esto se traduciría a la estructura de ramas de <code>gitflow</code> como <em>lanzamiento.feature.bug</em>.<br>El desarrollador es el responsable de comunicar el estado de su software publicando este número.</p><p><a href='https://semver.org/' target='_blank'>Saber más</a></p>",
			"code": "git tag -a '<TAG_VERSION>' -m '<COMMIT_MESSAGE>'"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-local-tag",
			"title": "Git. Eliminar una etiqueta local",
			"description": "Eliminar la etiqueta local existente con los nombres dados",
			"code": [
				["git tag -d <TAG_VERSION>"],
				["git tag --delete <TAG_VERSION>"]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-tag-remote",
			"title": "Git. Eliminar una etiqueta remota",
			"description": "Eliminar la etiqueta remota existente con los nombres dados.",
			"code": "git push --delete origin <TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "remove-and-upload-tag",
			"title": "Git. Eliminar una etiqueta local y remota",
			"description": "<p>Cuando quieras renombrar o eliminar una etiqueta y ya la hayas empujado a un repositorio remoto (por ejemplo, GitHub) entonces también tendrás que actualizar las referencias remotas justo después de renombrar o eliminar la etiqueta de tu repo local.</p><p>Aquí hay dos alternativas para eliminar una etiqueta en el repositorio local y en el remoto:<ul><li>Eliminar la etiqueta local y sobrescribir este cambio haciendo referencia al nombre de la etiqueta eliminada en el repositorio remoto.</li><li>O hacer el proceso a la inversa, eliminar primero la etiqueta en el repositorio remoto y luego en el repositorio local.</li></ul></p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Saber más</a></p>",
			"code": [
				[
					"git tag -d <TAG_VERSION>",
					"git push origin :refs/tags/<TAG_VERSION>"
				],
				[
					"git push --delete origin <TAG_VERSION>",
					"git tag -d <TAG_VERSION>"
				]
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-local-tag",
			"title": "Git. Renombrar una etiqueta local",
			"description": "<p>Si utilizas etiquetas en tus proyectos, probablemente te hayas encontrado con algún problema que te haya obligado a eliminar la etiqueta: <ul><li>Hubo un cambio que debía enviarse con esta versión y te olvidaste de él.</li><li>Hay algún código de depuración que no debía incluirse con esta versión.</li><li>Hay un error tipográfico realmente obvio que todo el mundo notará de inmediato.</li></ul></p><p>Si aún no has subido la etiqueta al repositorio remoto, puedes renombrar la etiqueta con el siguiente comando:</p><p><a href='https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/' target='_blank'>Saber más</a></p>",
			"code": "git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "rename-and-upload-tag",
			"title": "Git. Renombrar una etiqueta y publicarla",
			"description": "<p>Si te has equivocado y necesitas renombrar una etiqueta y actualizarla en el repositorio remoto, debes seguir estos pasos:<ol></li><li>Renombrar la etiqueta local.</li><li>Eliminar la etiqueta antigua para que git conozca el cambio.</li><li>Indicar al repositorio git remoto que has eliminado la etiqueta antigua.</li><li>Actualizar las etiquetas del repositorio remoto para subir la nueva etiqueta.</li></ol></p>",
			"code": [
				"git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>",
				"git tag -d <OLD_TAG_VERSION>",
				"git push origin :refs/tags/<OLD_TAG_VERSION>",
				"git push --tags"
			]
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "update-remote-repository",
			"title": "Git. Actualizar el repositorio remoto",
			"description": "<p>Esto es muy deseable cuando se trabaja en un flujo de trabajo en equipo en el que las ramas remotas se eliminan después de la fusión con <code>master</code> o se quedan con etiquetas obsoletas.</p><p>En este caso, querrá eliminar las referencias a las ramas o etiquetas que ya no existen en el control remoto conectándose al control remoto y obteniendo el último estado antes de la poda.<br> Es esencialmente una combinación de comandos:</p>",
			"code": "git fetch --all && git remote prune"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "update-local-tags",
			"title": "Git. Actualizar etiquetas remotas",
			"description": "<p>Si tu proyecto es de código abierto, probablemente tendrás que actualizar el estado de tu repositorio local de vez en cuando, ya que otras personas pueden haber eliminado o renombrado algunas etiquetas mientras estabas trabajando y ahora puedes tener etiquetas locales obsoletas.</p><p>Este comando poda las etiquetas que ya no existen en el repositorio remoto pero sí en tu repositorio local.</p>",
			"code": "git pull --prune --tags"
		},
		{
			"parent": "git",
			"url": "commands-git",
			"name": "",
			"title": "Git. ",
			"description": "",
			"code": ""
		}
	],
	"gitFlow": [
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "create-gitflow-repository",
			"title": "Git Flow. Inicializar el repositorio",
			"description": "<p>Git-flow es un <strong>flujo de trabajo</strong> aplicado a un repositorio Git.<br> Todo proyecto suele tener al menos 2 ramas infinitas: <code>develop</code> que contiene el código en desarrollo y <code>master</code> que contiene cada una de las versiones estables para incluir en producción.<br> Este modelo de ramificación, diseñado en torno a los lanzamientos del proyecto, tiene además un conjunto de ramas de apoyo, que están limitadas en el tiempo y son eliminadas eventualmente. Estas ramas permiten el trabajo en equipo, para la creación de nuevas funcionalidades (<code>feature</code>), resolución de errores en desarrollo (<code>bugfix</code>), resolución de errores urgentes en producción (<code>hotfix</code>) y la publicación de diferentes versiones (<code>release</code>).</p><p>Empieza a usarlo inicializándolo dentro de un repositorio git existente con <code>git flow init</code>. Al comienzo, Git-flow necesita ser inicializado para personalizar la configuración del proyecto, tendrás que responder a algunas preguntas sobre las convenciones de nomenclatura de tus ramas, en este momento puedes cambiar el nombre de las ramas si lo deseas, aunque se recomienda utilizar los valores por defecto (<code>feature</code>, <code>release</code>, <code>hotfix</code> y <code>support</code>).</p>",
			"code": [
				["git flow init"],
				[
					"git flow init",
					"",
					"Initialized empty Git repository in ~/project/.git/",
					"No branches exist yet. Base branches must be created now.",
					"Branch name for production releases: [master]",
					"Branch name for \"next release\" development: [develop]",
					"",
					"How to name your supporting branch prefixes?",
					"Feature branches? [feature/]",
					"Release branches? [release/]",
					"Hotfix branches? [hotfix/]",
					"Support branches? [support/]",
					"",
					"git branch",
					"* develop",
					"master"
				]
			]
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-start",
			"title": "Git Flow. Iniciar una nueva 'feature'",
			"description": "<p>Cuando se va desarrollar una nueva funcionalidad o característica del proyecto se crea una nueva rama llamada <code>feature</code>. Este tipo de ramas nacen a partir de la rama <code>develop</code> y una vez terminado su desarrollo, se incorporan nuevamente a ella.</p><p>El siguiente commando es un atajo, que engloba la ejecución de varios commandos: <ul><li><code>git checkout develop</code></li><li><code>git branch feature/&lt;BRANCH_NAME&gt;</code></li> <li><code>git checkout feature/&lt;BRANCH_NAME&gt;</code></li></ul></p>",
			"code": [
				["git flow feature start <FEATURE_NAME>"],
				["git checkout -b feature/<FEATURE_NAME> develop"]
			]
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-list",
			"title": "Git Flow. Obtener la lista de 'features'",
			"description": "<p>Puedes ver una lista de las ramas <code>feature</code> ya creadas en el repositorio local usando el siguiente commando.</p>",
			"code": "git flow feature list"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-publish",
			"title": "Git Flow. Publicar una 'feature'",
			"description": "<p>Normalmente las <code>feature</code> existen solamente en los repositorios locales de los desarrolladores y no en el repositorio origen. Si quieres compartir esta rama con algunos miembros de tu equipo para poder hacer un desarrollo colaborativo, tendrías que publicar la <code>feature</code> en el servidor remoto para que pueda ser utilizada por otros usuarios.</p>",
			"code": "git flow feature publish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-pull",
			"title": "Git Flow. Conseguir una 'feature' publicada",
			"description": "<p>Cuando más de una persona trabaje a la vez en una <code>feature</code>, esta será publicada por tus compañeros de equipo, y podrás ser capaz de desarrollar en la misma rama con ellos.</p><p>Si es la primera vez que participas en el proyecto, primero tendrás que clonar repositorio usando <code>git clone &lt;URL&gt;</code> para tener una copia en tu ordenador (repositorio local), después inicializar Gitflow con <code>git flow init</code> y descargar las ramas <code>master</code> y <code>develop</code> con los comandos <code>git checkout master</code> y <code>git checkout develop</code>.</p><p>Si ya estás participando en el proyecto puedes saltarte los pasos anteriores y usar el siguiente comando para descargar una <code>feature</code> y para asegurar que el repositorio local está sincronizado con el remoto.</p>",
			"code": "git flow feature pull origin <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-track",
			"title": "Git Flow. Seguir una 'feature' publicada",
			"description": "<p>Digamos que has creado una nueva función con <code>git flow feature start &lt;FEATURE_NAME&gt;</code>, y la has publicado al repositorio remoto con <code>git flow feature publish &lt;FEATURE_NAME&gt;</code> para que otros miembros de tu equipo puedan colaborar contigo usando <code>git flow feature pull &lt;FEATURE_NAME&gt;</code> para descargarsela. Esto crea una nueva rama en su repositorio local, basada en la rama del remoto, sin embargo esto no la configura para que los cambios que se realizen en esta, sean rastreados por la rama remota, por lo que ahora tiene que ser rastreada manualmente.</p><p>Con el siguiente comando <code>git flow feature track &lt;FEATURE_NAME&gt;</code>, tu compañero de trabajo, puede descargar la <code>feature</code> y además seguir los cambios que otros realizen en la publicada en el repositorio de origen.</p><p>Para ilustrar el aspecto colaborativo con una rama de una nueva función, utilizando el aspecto de solicitud de extracción de GitHub que facilita la parte de revisión y discursión del código, nos ponemos en la siguiente situación:<ul><li>Varias personas trabajan en la misma función y a medida que se confirman los cambios, se envían a GitHub (o una vez al final de su desarrollo si se prefiere).</li><li>Cuando se completa la función, se abre una solicitud de extracción en GitHub comparando <code>develop</code> y con la rama.</li><li>El equipo revisa la solicitud de extracción y realiza comentarios.</li><li>Cualquier cambio de la solicitud de extracción se realiza en la rama de funciones.</li><li>Una vez que se incorporan todos los cambios en la rama de funciones se da por terminada: <code>git flow feature finish &lt;FEATURE_NAME&gt;</code>.</li><li>La rama <code>develop</code> se envía a GitHub (GitHub marcará automáticamente la solicitud de extracción como cerrada/fusionada cuando esto suceda).</li></ul><p>Sin embargo, eso deja el problema de cerrar esa sucursal, quien ejecute primero <code>git flow feature finish &lt;FEATURE_NAME&gt;</code> tendrá el lujo de eliminar su rama local, pero cualquier otra persona que haya verificado la rama tendrá que hacerlo manualmente si así lo desea. Puedes usar <code>git fetch --prune</code> o un simple <code>git fetch</code> para eliminar tu rama si ya ha sido  eliminada en el remoto.</p><p>Si ya has descargado la rama y ahora necesitas realizar un seguimiento de esta, todo lo que tienes que hacer sería que tu rama existente rastree a la anterior con <code>git branch -u origin feature/&lt;FEATURE_NAME&gt;</code> o <code>git branch --set-upstream-to origin feature/&lt;FEATURE_NAME&gt;</code></p><p>En general, lo mejor sería empezar usando <code>git flow feature track &lt;FEATURE_NAME&gt;</code> y luego mantener tu rama actualizada con <code>git flow feature pull origin &lt;FEATURE_NAME&gt;</code></p></p><p><a href='https://stackoverflow.com/questions/18412750/why-doesnt-git-flow-feature-pull-track' target='_blank'>Know more</a></p>",
			"code": "git flow feature track <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-feature-finish",
			"title": "Git Flow. Terminar una 'feature'",
			"description": "<p>Cuando se finaliza el desarrollo de la nueva función, se deberá fusionar con <code>develop</code> y eliminarse del repositorio local y del remoto si llego a subirse.</p><p>El siguiente comando realiza los siguientes commandos: <ul><li><code>git checkout develop</code></li><li><code>git merge feature/&lt;FEATURE_NAME&gt;</code></li><li><code>git branch -D &lt;FEATURE_NAME&gt;</code></li><li><code>git push origin :&lt;FEATURE_NAME&gt;</code></li></ul></p>",
			"code": "git flow feature finish <FEATURE_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-bugfix-start",
			"title": "Git Flow. Empezar un 'bugfix'",
			"description": "<p>Durante el desarrollo del proyecto podrán encontrase errores en alguna de las ramas del repositorio. Para solucionarlos tenemos 2 tipos de ramas diferentes según el lugar que ocupan estos errores en el flujo de trabajo de git: <code>bugfix</code> y <code>hotfix</code>.</p><p>El término <code>bugfix</code> o <strong>corrección de errores</strong> se utilizan cuando se encuentra un problema durante la fase de desarrollo, para arreglar errores de una anterior funcionalidad u omisiones de desarrollo.<br> Este tipo de ramas se crean desde <code>develop</code> y se fusionan de nuevo en <code>develop</code> al terminarse.</p><p>El siguiente comando es lo mismo que ejecutar: <ul><li><code>git checkout develop</code></li><li><code>git branch bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git checkout bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>",
			"code": "git flow bugfix start <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-bugfix-finish",
			"title": "Git Flow. Terminar un 'bugfix'",
			"description": "<p>Las ramas <code>bugfix</code> o de corrección de errores son ramas temporales, que una vez resueltos los errores, se eliminan después de fusionarse con la rama de desarrollo <code>develop</code>.</p><p>El siguiente comando es lo mismo que ejecutar: <ul><li><code>git checkout develop</code></li><li><code>git merge bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git branch -D bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>",
			"code": "git flow bugfix finish <BUGFIX_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-start",
			"title": "Git Flow. Empezar una 'release'",
			"description": "<p>Para preparar nuestra aplicación para su puesta en producción existen unas ramas llamadas <code>release</code>. En algunos equipos, estas ramas son las que se vuelcan en los servidores de pre-producción para hacer el testing final: se corrigen errores menores, se pule la interfaz, se ajusta la maquetación…se hace la puesta a punto final de la aplicación antes de liberar la versión definitiva.</p><p>El nombre de la <code>release</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión 'major' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión 'minor' (incorporación de una funcionalidad), y <code>Z</code> es la versión 'patch' (correción de errores compatibles con la versión anterior). </br> Por tanto, el número de la <code>release</code> sería el primero, <code>X</code>.</p><p>El siguiente comando crea una rama de lanzamiento a partir de la rama <code>develop</code>. Opcionalmente, se puede suministrar el id de una commit situada en <code>develop</code> para iniciar el lanzamiento desde el commit.</p><p><a href='https://aprendegit.com/git-flow-release-branches/' target='_blank'>Saber más</a></p>",
			"code": "git flow release start <VERSION_NUMBER> <[BASE]>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-list",
			"title": "Git Flow. Obtener una lista de 'release'",
			"description": "<p>Puede ver una lista de todas las ramas de lanzamiento actuales creadas en el repositorio local.</p>",
			"code": "git flow release list"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-publish",
			"title": "Git Flow. Publicar una 'release'",
			"description": "<p>Si esta trabajando en equipo y otro de sus compañeros debe revisar el código antes del lanzamiento de una nueva versión, es aconsejable publicar la rama de lanzamiento después de crearla para permitir que otros desarrolladores hagan commits de lanzamiento.</p>",
			"code": "git flow release publish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-track",
			"title": "Git Flow. Seguir el rastro de una 'release'",
			"description": "<p>Puede seguir los cambios de una versión publicada en el repositorio remoto.</p>",
			"code": "git flow release track <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-release-finish",
			"title": "Git Flow. Terminar una 'release'",
			"description": "<p>Una vez creada la rama <code>release</code>, empezamos el proceso de corrección y depuración, se realizan los commits necesarios y cuando hemos terminado de arreglar todos los 'bugs', estamos listos para que nuestro proyecto pase a producción y eliminar la rama.</p><p>Terminar una versión es uno de los grandes pasos en la creación de ramas de git. El siguiente comando realiza varias acciones: fusiona la rama de la versión con <code>master</code>, etiqueta la versión con su nombre, vuelve a fusionar la versión con <code>develop</code> y elimina la rama de la versión.</p><p>Cuando ejecutamos este comando git-flow nos va a pedir que introduzcamos 3 mensajes: <ol><li>El mensaje del commit del merge como resultado de incorporar los cambios en <code>master</code>.</li><li>El mensaje que git-flow pondrá a la etiqueta que va a crear para identificar esta versión.</li><li>Y por último el mensaje del commit del merge como resultado de incorporar la rama a <code>develop</code>.</li></ol></p><p>La ejecución de este comando que pueden resumirse en los siguientes comandos: <ul><li><code>git checkout master</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git tag v&lt;VERSION_NUMBER&gt;</code></li><li><code>git checkout develop</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git branch -d release/&lt;VERSION_NUMBER&gt;</code></li></ul></p>",
			"code": "git flow release finish <VERSION_NUMBER>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-tags-push-single",
			"title": "Git Flow. Publicar una sola etiqueta",
			"description": "<p>Después de terminar la rama de lanzamiento, no olvide añadir las etiquetas al repositorio remoto. Este comando empujará una sola etiqueta al repositorio remoto.</p>",
			"code": "git push <REPO_NAME> <TAG_NAME>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-tags-push",
			"title": "Git Flow. Publicar todas las etiquetas",
			"description": "<p>Puedes añadir todas las etiquetas al repositorio remoto con un solo comando. Esta forma no se recomienda porque es común que los desarrolladores tengan etiquetas viejas o 'malas' en sus repositorios locales que no tienen necesidad de estar en el remoto, por lo que se aconseja sólo empujar explícitamente una etiqueta y no todas sus etiquetas a la vez.</p>",
			"code": "git push <REPO_NAME> --tags"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-hotfix-start",
			"title": "Git Flow. Iniciar un 'hotfix'",
			"description": "<p>Al igual que existen ramas para resolver errores que hemos encontrado durante el proceso de desarrollo, exisiten otro tipo de ramas. Estas ramas llamadas <code>hotfix</code>, se crean para actuar inmediatamente sobre un estado no deseado de una versión de producción en vivo, se utilizan para corregir errores u omisiones urgentes que no pueden esperar al lanzamiento de la siguiente versión.<br>El tiempo de vida de esta rama es temporal, se crea a partir de <code>master</code>, se fusiona de nuevo en <code>master</code> y se elimina después de la fusión.</p><p>El nombre del <code>hotfix</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href='https://semver.org/lang/es/' target='_blank'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión 'major' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión 'minor' (incorporación de una funcionalidad), y <code>Z</code> es la versión 'patch' (correción de errores compatibles con la versión anterior).</br> Por tanto, el número del <code>hotfix</code> sería el tercero y último, <code>Z</code>.</p><p>Opcionalmente, se puede especificar un nombre base, el id de un commit, desde el que crear la rama.</p>",
			"code": "git flow hotfix start <VERSION_NUMBER> <[BASE_NAME]>"
		},
		{
			"parent": "gitFlow",
			"url": "commands-git-flow",
			"name": "gitflow-hotfix-finish",
			"title": "Git Flow. Terminar un 'hotfix'",
			"description": "<p>Cuando se han realizado todas las correciones en una rama <code>hotfix</code>, hay que realizar el siguiente comando para finalizar la rama. Este proceso fusiona la rama de nuevo con <code>develop</code> y <code>master</code>, crea una etiqueta con el número de versión del <code>hotfix</code> y elimina dicha rama, ya que su existencia es temporal.</p>",
			"code": "git flow hotfix finish <VERSION_NUMBER>"
		}
	]
}
