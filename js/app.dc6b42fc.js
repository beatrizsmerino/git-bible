(function(e){function t(t){for(var a,n,s=t[0],c=t[1],l=t[2],m=0,u=[];m<s.length;m++)n=s[m],Object.prototype.hasOwnProperty.call(i,n)&&i[n]&&u.push(i[n][0]),i[n]=0;for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&(e[a]=c[a]);d&&d(t);while(u.length)u.shift()();return r.push.apply(r,l||[]),o()}function o(){for(var e,t=0;t<r.length;t++){for(var o=r[t],a=!0,s=1;s<o.length;s++){var c=o[s];0!==i[c]&&(a=!1)}a&&(r.splice(t--,1),e=n(n.s=o[0]))}return e}var a={},i={app:0},r=[];function n(t){if(a[t])return a[t].exports;var o=a[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=a,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(o,a,function(t){return e[t]}.bind(null,a));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="/git-bible/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],c=s.push.bind(s);s.push=t,s=s.slice();for(var l=0;l<s.length;l++)t(s[l]);var d=c;r.push([0,"chunk-vendors"]),o()})({0:function(e,t,o){e.exports=o("56d7")},"07e6":function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"logo",class:e.theme},[t("router-link",{staticClass:"logo__link",attrs:{to:"/"}},[t("i",{staticClass:"logo__icon icon icon-git"}),t("div",{staticClass:"logo__text"},[t("span",{staticClass:"logo__git"},[e._v(" git ")]),t("span",{staticClass:"logo__bible"},[e._v(" Bible ")])])])],1)},i=[],r={name:"UILogo",props:{theme:{type:String}}},n=r,s=(o("f00a"),o("2877")),c=Object(s["a"])(n,a,i,!1,null,null,null);t["a"]=c.exports},"0e51":function(e,t,o){"use strict";o("6326")},"128a":function(e,t,o){"use strict";o("834f")},"1c33":function(e,t,o){"use strict";o("b0db")},3339:function(e,t,o){},"3b31":function(e,t,o){},4083:function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"page-content"},[t("div",{staticClass:"page-content__inner"},[t("FilterNav"),t("CommandList",{attrs:{"command-list":e.getCommandList}})],1)])},i=[],r=o("8b84"),n=o("46e2"),s={name:"CommandsGit",components:{FilterNav:r["a"],CommandList:n["a"]},computed:{getCommandList:function(){return this.$t("commandList.git")}}},c=s,l=o("2877"),d=Object(l["a"])(c,a,i,!1,null,"453a3773",null);t["a"]=d.exports},"46e2":function(e,t,o){"use strict";o("b0c0");var a=function(){var e=this,t=e._self._c;return t("ul",{staticClass:"command-list"},e._l(e.commandListFormatted,(function(o,a){return t("li",{key:"command-".concat(a),ref:o.name,refInFor:!0,staticClass:"command-list__item"},[t("CommandItem",{attrs:{"command-item":o,"command-index":a,"command-status":o.name===e.anchorName}})],1)})),0)},i=[],r=(o("4de4"),o("d3b7"),o("0643"),o("2382"),o("a4d3"),o("e01a"),function(){var e=this,t=e._self._c;return t("div",{staticClass:"command-item",class:{"is-selected":e.commandStatus},attrs:{id:e.commandItem.name,"data-index":e.commandIndex}},[t("h3",{staticClass:"command-item__title"},[t("router-link",{staticClass:"command-item__anchor-link",attrs:{to:"#".concat(e.commandItem.name)}},[t("i",{staticClass:"reference__url-icon"},[t("font-awesome-icon",{attrs:{icon:["fas","link"]}})],1)]),e._v(" "+e._s(e.commandItem.title)+" ")],1),e.commandItem.description?t("div",{staticClass:"command-item__description",domProps:{innerHTML:e._s(e.commandItem.description)}}):e._e(),Array.isArray(e.commandItem.code)&&Array.isArray(e.commandItem.code[0])?t("div",{staticClass:"command-item__blocks-code"},e._l(e.commandItem.code,(function(e,o){return t("UICodeTheme",{key:"code-".concat(o),staticClass:"command-item__code",attrs:{code:e}})})),1):e._e(),Array.isArray(e.commandItem.code)&&"string"==typeof e.commandItem.code[0]||"string"==typeof e.commandItem.code?t("UICodeTheme",{staticClass:"command-item__code",attrs:{code:e.commandItem.code}}):e._e()],1)}),n=[],s=(o("a9e3"),function(){var e=this,t=e._self._c;return t("div",[t("div",{staticClass:"code-theme is-theme-light is-scroll is-scroll-start"},[t("div",{staticClass:"code-theme__header"},[t("p",{staticClass:"code-theme__type"},[t("i",{staticClass:"code-theme__type-icon"},[t("font-awesome-icon",{attrs:{icon:["fas","terminal"]}})],1),e._v(" Shell Bash ")]),t("div",{staticClass:"code-theme__buttons"},[t("UICopy",{staticClass:"code-theme__button-copy code-theme__button",attrs:{"text-to-copy":e.codeFormatted}}),t("label",{staticClass:"switch-theme code-theme__button-switch code-theme__button",on:{change:e.switchTheme}},[t("input",{staticClass:"switch-theme__field",attrs:{type:"checkbox"}}),t("span",{staticClass:"switch-theme__bullet switch-theme__bullet--rounded"})])],1)]),t("div",{staticClass:"code-theme__content"},[2===e.checkLines(e.code)?t("code",{staticClass:"code-theme__code is-multiple-line",on:{scroll:e.checkScrollHorizontal}},[t("ol",{staticClass:"code-theme__code-list"},e._l(e.code,(function(o,a){return t("li",{key:"line-".concat(a),staticClass:"code-theme__code-item"},[e._v(" "+e._s(e.code[a])+" ")])})),0)]):1===e.checkLines(e.code)?t("code",{staticClass:"code-theme__code is-one-line",on:{scroll:e.checkScrollHorizontal}},[e._v(" "+e._s(e.code[0])+" ")]):t("code",{staticClass:"code-theme__code is-one-line",on:{scroll:e.checkScrollHorizontal}},[e._v(" "+e._s(e.code)+" ")])])])])}),c=[],l=(o("a15b"),function(){var e=this,t=e._self._c;return t("button",{directives:[{name:"clipboard",rawName:"v-clipboard:copy",value:e.textToCopy,expression:"textToCopy",arg:"copy"},{name:"clipboard",rawName:"v-clipboard:success",value:e.onSuccess,expression:"onSuccess",arg:"success"},{name:"clipboard",rawName:"v-clipboard:error",value:e.onError,expression:"onError",arg:"error"}],staticClass:"button-copy",attrs:{"aria-label":"Copy text"}},[t("i",{staticClass:"button-copy-text__icon"},[t("font-awesome-icon",{attrs:{icon:["fas","clone"]}})],1),t("transition",{attrs:{name:"fade-up"}},[!0===e.status?t("span",{staticClass:"button-copy__message button-copy__message--success"},[e._v(" Copied! ")]):e._e(),!1===e.status?t("span",{staticClass:"button-copy__message button-copy__message--success"},[e._v(" Press CTRL+C to copy ")]):e._e()])],1)}),d=[],m={name:"UICopy",props:{textToCopy:{type:String,required:!0}},data:function(){return{status:null}},methods:{resetStatus:function(){this.status=null},onSuccess:function(){var e=this;this.status=!0,setTimeout((function(){return e.resetStatus()}),5e3)},onError:function(){var e=this;this.status=!1,setTimeout((function(){return e.resetStatus()}),5e3)}}},u=m,h=(o("e0a1"),o("2877")),p=Object(h["a"])(u,l,d,!1,null,"2d2d9ab6",null),g=p.exports,f={name:"UICodeTheme",components:{UICopy:g},props:{code:{type:[String,Array],required:!0}},data:function(){return{codeFormatted:""}},created:function(){this.codeFormatted=this.convertArrayToStringLines(this.code)},methods:{toggleScrollClass:function(e,t,o){o?e.classList.add(t):e.classList.remove(t)},checkScrollHorizontal:function(e){var t=e.target,o=t.parentNode.parentNode,a=t.scrollLeft,i=t.scrollWidth,r=t.offsetWidth,n=0===a,s=i-a===r;this.toggleScrollClass(o,"is-scroll-start",n),this.toggleScrollClass(o,"is-scroll-end",s)},switchTheme:function(e){var t=e.target,o=t.parentNode.parentNode.parentNode.parentNode;o&&t.checked?(o.classList.remove("is-theme-light"),o.classList.add("is-theme-dark")):(o.classList.remove("is-theme-dark"),o.classList.add("is-theme-light"))},checkLines:function(e){return Array.isArray(e)?1===e.length?1:2:0},convertArrayToStringLines:function(e){return Array.isArray(e)||Array.isArray(e[0])?e.join("\r\n"):e}}},b=f,w=(o("fb93"),Object(h["a"])(b,s,c,!1,null,"5e93a5e3",null)),y=w.exports,v={name:"CommandItem",components:{UICodeTheme:y},props:{commandItem:{type:Object,required:!0},commandIndex:{type:Number,required:!0},commandStatus:{type:Boolean,required:!0}}},E=v,_=(o("48a8"),Object(h["a"])(E,r,n,!1,null,"7e76e3d7",null)),A=_.exports,T={name:"CommandList",components:{CommandItem:A},props:{commandList:{type:Array,required:!0}},data:function(){return{commandListFormatted:"",anchorName:this.$route.hash.split("#").pop()}},watch:{$route:function(e){this.anchorName=e.hash.split("#").pop()},commandList:function(e){this.commandListFormatted=e}},created:function(){this.commandListFormatted=this.commandList.filter((function(e){return""!==e.name&&""!==e.title&&""!==e.code}))}},k=T,I=(o("9388"),Object(h["a"])(k,a,i,!1,null,"78673335",null));t["a"]=I.exports},"48a8":function(e,t,o){"use strict";o("3b31")},"4a9d":function(e,t,o){},"4bae":function(e){e.exports=JSON.parse('{"git":[{"parent":"git","url":"command-git","name":"get-git-version","title":"Git. Get git version","description":"<p>Before you install git, it\'s a good idea to check if you already have it installed by using the following command, which will return the version number installed on your computer. If not, follow the steps described in this <a href=\'https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git\' target=\'_blank\'>link</a> depending on your operating system.</p>","code":"git --version"},{"parent":"git","url":"command-git","name":"create-git-repository","title":"Git. Initialize git repository","description":"<p>A git repository is a virtual repository, allowing you to store versions of your project\'s code that you can access whenever you need to. The following command, used only once during the initial setup of a new repository, will create a new <code>.git</code> subdirectory in your current working directory and a new <code>master</code> branch.</p><p><a href=\'https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init\' target=\'_blank\'>Know more</a></p>","code":"git init"},{"parent":"git","url":"command-git","name":"show-configuration","title":"Git. Show the set configuration","description":"<p>To visualize our current configuration, We must know that all the configuration is saved in the file <code>.gitconfig</code>, found in: if you are <strong>Linux</strong> the user <code>HOME</code>or if you are on <strong>Windows</strong> in <code>C:Users</code> or if you are  <strong>Mac</strong> typing on the <strong>consola</strong> <code>git config --list --show-origin</code>.</p>","code":[["git config -l"],["git config --list"],["git config --global --list"]]},{"parent":"git","url":"command-git","name":"config-user-name-email","title":"Git. Configure the name and email of user","description":"<p>Git is a <strong>distributed version control system</strong> that’s being used by most software teams today. The first thing you should do after installing Git on your system is to configure your git username and email address. Git associate your identity with every commit you make.</p><p>Git allows you to set a global, per-project username and email address. If you change the name and email during repository development, the changes only affect future commits, the name and email associated with commits you made prior to the change are not affected.</p><p>You can set or change your git identity using the following command.</p>","code":[["git config --global user.name <USER_NAME>"],["git config --global user.email <USER_EMAIL>"]]},{"parent":"git","url":"command-git","name":"config-code-editor","title":"Git. Add or edit the default editor","description":"<p>When you create a Git commit with <code>git commit –a</code>, the default editor that will be opened is <strong>Vim</strong>. This can be very confusing for people, as Vim is not an easy editor if you have never worked with it previously.</p><p>There are many ways in which this can be done: via the terminal with the next command, opening and edting the <code>.gitconfig</code> file...</p><p>On <strong>OSX</strong> for set <strong>Visual Studio Code</strong> as global Git editor, you need to do the next steps: <ul><li>Open the editor and press at the same time the keys <code>Shift + Command + P</code>.</li><li>Type the word <code>Code</code> on the emergent window and click on <code>Shell Command: Install \'code\' command in PATH</code> to do the installation.</li><li>And then use the second block of commands of this description, for run the 2 lines in your terminal. This defines it in your settings as the global editor of Git and opens this same settings file with it.</li></ul></p><p><a href=\'https://stackoverflow.com/questions/34746045/set-visual-studio-code-to-be-global-git-editor-on-osx\' target=\'_blank\'>Know more</a></p>","code":[["git config --global core.editor <PATH/TO/EDITOR_CODE>"],["git config --global core.editor \'code --wait\'","git config --global -e"]]},{"parent":"git","url":"command-git","name":"open-file-with-editor","title":"Git. Open a project or file with the editor","description":"<p>Through the terminal you can open a file with your preferred code editor. These commands open a file with the SublimeText, Atom and Visual Studio Code editors.</p>","code":[["subl <PATH/TO/FOLDER/FILE>"],["atom <PATH/TO/FOLDER/FILE>"],["code <PATH/TO/FOLDER/FILE>"]]},{"parent":"git","url":"command-git","name":"change-autor-email-last-commits","title":"Git. Change the name and email of the author of the last commit","description":"<p>If you have made a mistake and made your commit with another name or email you can overwrite the author information of only the last commit with this command.</p>","code":"git commit --amend --author=\'<USER_NAME> <USER_EMAIL>\'"},{"parent":"git","url":"command-git","name":"change-autor-email-commits","title":"Git. Change the name and email of the author after make a commit","description":"<p>If you have made a mistake and made several commits with another name or user email you can overwrite the author information of all commits with the following command.</p><p>Be very careful if these commits have been previously uploaded to the remote repository and if more people are collaborating in the repository. If this is the case, it is important to communicate it before making this command, because you\'ll also have to overwrite changes in the remote repository with <code>git push -f</code> and the other contributors will have to update their local repository with <code>git pull -f</code>. This type of changes is best made without having any changes saved in the <strong>staging area</strong> or the <strong>working directory</strong>.</p><p><a href=\'https://stackoverflow.com/questions/750172/how-to-change-the-author-and-committer-name-and-e-mail-of-multiple-commits-in-gi\' target=\'_target\'>Know more</p>","code":["#!/bin/sh","","git filter-branch --env-filter \'","WRONG_EMAIL=\\"<USER_EMAIL>\\"","CORRECT_NAME=\\"<USER_NAME>\\"","CORRECT_EMAIL=\\"<USER_EMAIL>\\"","if [\\"$GIT_COMMITTER_EMAIL\\" = \\"$WRONG_EMAIL\\"]","then","    export GIT_COMMITTER_NAME=\\"$CORRECT_NAME\\"","    export GIT_COMMITTER_EMAIL=\\"$CORRECT_EMAIL\\"","fi","if [\\"$GIT_AUTHOR_EMAIL\\" = \\"$WRONG_EMAIL\\"]","then","    export GIT_AUTHOR_NAME=\\"$CORRECT_NAME\\"","    export GIT_AUTHOR_EMAIL=\\"$CORRECT_EMAIL\\"","fi","\' --tag-name-filter cat -- --branches --tags"]},{"parent":"git","url":"command-git","name":"get-commits","title":"Git. Get all commits made","description":"<p>After you have made several commits, or if you have cloned a repository that already had a commit history, you will probably want to look back to see what modifications have been made.</p><p>This command shows a list of all the commits made, in reverse chronological order, i.e. the most recent ones are shown at the beginning. Each commit contains information about the identification number (<em>Secure Hash Algorithm</em>, <code>SHA-1</code>), the author\'s name and e-mail address, the date and the commit message.</p><p><a href=\'https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones\' target=\'_blank\'>Know more</a></p>","code":"git log"},{"parent":"git","url":"command-git","name":"get-commits-oneline","title":"Git. Get all commits made in a single line","description":"<p>The <code>git log</code> command has many optional parameters for formatting the output of the commit information. The <code>--oneline</code> option shows the information of each commit in a single line with the first 6 characters of the <code>SHA-1</code> number, the branches, the tags and the message.</p><p><a href=\'https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones#rlog_options\' target=\'_blank\'>Know more</a></p>","code":"git log --oneline"},{"parent":"git","url":"command-git","name":"get-commits-oneline-graph","title":"Git. Get all commits made in a graph","description":"<p>This command condenses the information of each commit into a single line, showing only the commit ID and the first line of the commit message, highlighting all references (branches, tags...).</p><p>It draws a graphical <em>ASCII</em> representation of the commit history structure. Prints additional lines between commits, so that the history chart is drawn correctly, and it use asterisks to show which branch the commit was on.</p><p><a href=\'https://www.atlassian.com/git/tutorials/git-log\' target=\'_blank\'>Know more</a></p>","code":"git log --oneline --graph --decorate"},{"parent":"git","url":"command-git","name":"get-commit-without-merges","title":"Git. Get all commits made, hiding the merge commits","description":"<p>A <code>merge</code> is the result of merging 2 or more branches. Sometimes, with that merge, an extra commit called <code>merge commit</code> is generated. The information in this commit contains a mix of all changes made in both branches, this can be confusing. We can display the list of commits without them with this command.</p>","code":"git log --oneline --no-merges"},{"parent":"git","url":"command-git","name":"get-commits-range","title":"Git. Get commits between ranges","description":"<p>The most common way to specify a range of commits is by using the double dot syntax.</p><p>This for example, is often used to get a particular range of commits by selecting the position they occupy in the history.</p><p>Or on the other hand if we select 2 branches it will show all the commits in the first branch that do not appear in the second. This is useful for previewing what is about to be merged or to see what is about to be published in the remote repository.</p><p><a href=\'https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#_commit_ranges\' target=\'_blank\'>Know more</a></p>","code":[["git log master~<POSITION_NUMBER>..master~<POSITION_NUMBER>"],["git log master..develop"],["git log origin/master..HEAD"]]},{"parent":"git","url":"command-git","name":"get-commit-by-date","title":"Git. Search the commits by date","description":"<p>With the following commands we can obtain a list of commits according to the indicated date. (YYYY-MM-DD): <ul><li><code>--since</code> Commits from the date.</li><li><code>--before</code> Commits before the date.</li><li><code>--after</code> Commits after the date.</li></ul></p>","code":[["git log --since={<DATE>}"],["git log --before={<DATE>}"],["git log --after={<DATE>}"]]},{"parent":"git","url":"command-git","name":"show-commits-of-file","title":"Git. Show only the commits in which a file is involved","description":"<p>It shows all the commits in which the indicated file has been modified.</p>","code":"git log --oneline -- <FILE_NAME>"},{"parent":"git","url":"command-git","name":"get-commits-regex","title":"Git. Searching git files and commits using a regular expression","description":"<p>Usually, we check the repository history using the <code>git log</code> command, which shows us to see a list of all commits. But as our project gets bigger, it will become more complicated to search through the multiple files and commits. So at some point, we will want to <strong>filter this list to find changes that include specific words in the files or in the commit message</strong>.</p><p>Git has a command called <code>grep</code> that allows you to search inside the repository, through any tree or working directory, for files that match a string.</p><p>For example: <ul><li><code>git grep -n \'word\'</code> or <code>git grep --line-number \'word\'</code>, shows the file, the line number and the text of the line where the match was found.</li><li><code>git grep -c \'word\'</code> or <code>git grep --count \'word\'</code>, condenses the result showing only the files where the match was found and how many matches there are in each file.</li></ul></p><p>Also git has a command called <code>--grep</code> we can search inside a git repository, in any branch, for commits whose message matches the text string or regular expression you specify.</p><p>For example: <ul><li><code>git log -S \'word\'</code>, shows the commits that contain the word to search for both in the commit messages and in the content of the changes.</li><li><code>git log --grep \'word\'</code>, shows the commits whose message matches the specified expression.</ul> Once the commit is found, we could run the command <code>git show &lt;COMMIT_ID&gt;</code>, using the <code>HASH</code> (commit identifier), to see it in depth.</p><p><a href=\'https://mijingo.com/blog/search-git-commits-with-grep\' target=\'_blank\'>Know more</a></p>","code":[["git grep --line-number \'<REGEX>\'"],["git grep --count \'<REGEX>\'"],["git log -S \'<REGEX>\'"],["git log --oneline --grep=\'<REGEX>\'"]]},{"parent":"git","url":"command-git","name":"show-info-commit","title":"Git. Show the information of a commit","description":"<p>This is a command-line tool that you use to view expanded details in git objects such as blobs, trees, tags, and commits.</p><p>In the case of a commit, it shows its complete information: (id or <code>SHA-1</code>, author, date and message).</p><p>There are many ways to access a commit\'s information:<br><ul><li>In an absolute way, referring to the code that identifies it.</li><li>Relatively, referring to the name of the branch of the last commit.</li><li>Through <code>HEAD</code>, accessing the last commit that has been made.</li><li>By his position in the git tree. We can see all the commits backwards from the moment we tell you, with the sign <code>^</code> we can go 1 or 3 commits backwards and with the sign <code>-</code> or <code>~</code> we can specify the number of commits backwards we want to go until we find the one we want to see.</li></ul></p>","code":[["git show <COMMIT_ID>"],["git show <BRANCH_NAME>"],["git show HEAD"],["git show HEAD^"],["git show HEAD^^^"],["git show HEAD~<POSITION_NUMBER>"],["git show -<POSITION_NUMBER>"]]},{"parent":"git","url":"command-git","name":"summary-branches","title":"Git. Show branches and their commits","description":"<p>It shows us a summary of all the branches that are in a project together with their last modifications or commits.</p><p><a href=\'https://git-scm.com/docs/git-show-branch\' target=\'_blank\'>Saber más</a></p>","code":[["git show-branch"],["git show-branch --list"],["git show-branch --more=-1"],["git show-branch --more=<NUMBER_COMMITS>"]]},{"parent":"git","url":"command-git","name":"show-date-commit","title":"Git. Show date commit","description":"<p>A commit has 2 types of dates: the author date and the commit date.<ul><li>The <strong>author date</strong> indicates when this commit was originally made, i.e. when the <code>git commit</code> was first made. </li><li>The <strong>commit date</strong> changes each time the commit is modified, for example, when the commit is overwritten with <code>git commit --amend</code></li></ul></p><p>With the following command we can format the output information of a commit (2020-12-03 19:28:49 +0100).<ul><li><code>%ai</code>: <strong>author date</strong>, <em>ISO 8601-like</em> format</li><li><code>%ci</code>: <strong>committer date</strong>, <em>ISO 8601-like</em> format</li></ul></p>","code":"git show -s --format=%ci <COMMIT_ID>"},{"parent":"git","url":"command-git","name":"overwrite-date-commit","title":"Git. Overwrite date commit","description":"<p>This command change the author and committer date of the commit already created (2020-12-03 19:28:49 +0100).<br>Why change two dates? The <strong>author</strong> is the person who originally wrote the work, whereas the <strong>committer</strong> is the person who last applied the work. If we are working alone on the project, the date should be the same in both cases.</p><p>We have 2 ways to overwrite the date of a commit:</p><ul><li>We can modify the date of the <strong>last commit</strong> made with this first command.<br><a href=\'https://garysferrao.github.io/git/commit/date/2015/12/01/change-git-commit-date.html\' target=\'_blank\'>Know more</a></li><li>Or we can modify the date of a particular commit by filtering the list of commits <strong>by the id of the commit</strong> to be searched. The date of the first commit made to a repository can be modified using this second command.<br><a href=\'https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git\' target=\'_blank\'>Know more</a></li></ul><p>The second time we run any of these commands we we won\'t be able to create a new backup. We must delete the previous backup that already exists in <code>.git/refs/original/</code> folder or force overwriting the backup with <code>-f</code>.</p>","code":[["GIT_COMMITTER_DATE=\'<YYYY-MM-DDThh:mm:ss±hh:mm>\' git commit --amend --date=\'<YYYY-MM-DDThh:mm:ss±hh:mm>\' -C <COMMIT_ID>"],["git filter-branch --env-filter \\\\","\'if [ $GIT_COMMIT = <COMMIT_ID> ]","then","    export GIT_AUTHOR_DATE=\\"<YYYY-MM-DDThh:mm:ss±hh:mm>\\"","    export GIT_COMMITTER_DATE=\\"<YYYY-MM-DDThh:mm:ss±hh:mm>\\"","fi\'"]]},{"parent":"git","url":"command-git","name":"git-add","title":"Git. Add folders and files to staging area","description":"<p>There are different areas in a git repository: the working tree, working directory or workspace, the staging area or index, the stash, the local repository and remote repository.<ul><li>The <strong>workspace</strong> contains the files you\'re currently working on, git will notice the changes (if you haven\'t previously excluded them), but it won\'t save them until you explicitly tell it to track them.</li><li>The <strong>staging area</strong> contains a snapshot of the content tracking the work tree. This snapshot represents the contents of the next commit.</li></ul></p><p>We use the <code>git add</code> command to add the changes in the working directory to the staging area.<br>You can add them all at the same time (3 first commands) or by indicating the file paths (last command):</p>","code":[["git add --all"],["git add -A"],["git add ."],["git add <PATH/TO/FOLDER/FILE>"],["git add <PATH/TO/FOLDER/FILE_1> <PATH/TO/FOLDER/FILE_2>"]]},{"parent":"git","url":"command-git","name":"show-status-files","title":"Git. Show the status of files in a git directory","description":"<p>Executing this command we can see the branch in which we are and the files contained in the stage along with its state (new/modified/deleted). It also warns us of files that are untracked by git (untracked) or files with conflicts.</p>","code":"git status"},{"parent":"git","url":"command-git","name":"remove-file-track","title":"Git. Delete and tracking file","description":"<p>The <code>git rm</code> command is used to remove individual files or a set of files from a repository, the opposite command would be <code>git add</code>.<br>The removal only affects the working directory areas and the staging area, it only acts on the current branch and files that have no unsaved changes. This change is not stored in the repository history until a new commit is created.</p><p><strong>Why use <code>git rm</code> instead of <code>rm</code></strong><br>With the <code>rm</code> command, a Git repository will recognize when it has run over a file that is being tracked, update the working directory to reflect the removal but not the staging area. You need to run an additional <code>git add</code> command in the deleted file paths to add the changes to the staging area. The <code>git rm</code> command acts as a shortcut as it will update the working directory and the test index with the removal.</p><p>The next commands do:<ul><li><code>rm</code>: Delete the selected file and git doesn\'t notice this change.</li><li><code>git rm </code>: It only works if the file was already being tracked, i.e. if a <code>git add</code> and a <code>git commit</code> were executed. Delete the selected file, and add the changes to the staging area.</li><li><code>git rm --cached</code>: Removes the trace of the selected file from version control, without deleting the file, this is called an <strong>untracking file</strong>.</li></ul></p><p><a href=\'https://www.atlassian.com/es/git/tutorials/undoing-changes/git-rm\' target=\'_blank\'>Know more</a></p>","code":[["rm <PATH/TO/FOLDER/FILE>"],["git rm <PATH/TO/FOLDER/FILE>"],["git rm --cached <PATH/TO/FOLDER/FILE>"]]},{"parent":"git","url":"command-git","name":"rename-file-track","title":"Git. Rename and tracking file","description":"<p>This command works the same as <code>git rm</code> command.</p><p>The next commands do:<ul><li><code>mv</code>: Modify the name of a file without the git adding it to the staging area.</li><li><code>git mv</code>: Change the name of a file and have git track this change. After this, if we do a <code>git status</code> it will appear as renamed.</li></ul></p>","code":[["mv <OLD_FILE_NAME> <NEW_FILE_NAME>"],["git mv <OLD_FILE_NAME> <NEW_FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"create-commit","title":"Git. Create a commit with a message","description":"<p>Commits are created to capture the status of one or more project files at a particular time. They are a <strong>changeset</strong>, snapshots or milestones in the history of a git project. Each commit contains the date it was made, the changes of each file, the author information, a message describing the content of the commit, and a unique identifier (<code>SHA-1</code>) to reference this commit.</p><p>This command only includes modifications to tracked files (those that have been added with <code>git add</code> at some point in their history). The <code>-m</code> or <code>--message</code> option is used to indicate the commit message.</p>","code":"git commit -m \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"add-and-create-commit","title":"Git. Add folders and files to staging area and create a commit","description":"<p>If we\'ve already done the first <code>git add</code> and <code>git commit</code> of a file, that is, git already knows about it, the next times we can use another command that includes both steps in a single command. This combination immediately creates a confirmation of all prepared changes and applies an online confirmation message.</p><p>It is a shortcut command for advanced users that combines the options <code>-a</code> or <code>--all</code> (adds the modified or deleted files to the stage, but not the newly created ones, since they have not been reported to git for tracking) and <code>-m</code> or <code>--message</code> (with the specified message).</p><p><a href=\'https://www.atlassian.com/es/git/tutorials/saving-changes/git-commit\' target=\'_blank\'>Know more</a></p>","code":"git commit -am \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"commit-particular-file-on-index","title":"Git. Make a confirmation of only one file in the staging area","description":"<p>If you have several files added to the <strong>staging area</strong> and you regret it, because you only want to commit one particular file, you can select the file and commit only the changes to it.</p>","code":["git <FILE_NAME>","git commit -am <COMMIT_MESSAGE>"]},{"parent":"git","url":"command-git","name":"overwrite-last-commit","title":"Git. Overwrite the last commit","description":"<p>If a message or commit file contains unclear, incorrect, sensitive or missing information, you can correct it locally and create a commit with a new message.<br>Executing this command will open a text editor and ask you to edit the message and save the commit. This process will change the commit ID, creating a new commit that replaces the previous one.</p><p><a href=\'https://blog.kirei.io/buenas-pr%C3%A1cticas-para-los-mensajes-de-commit-en-git-a9fc43a83821\' target=\'_blank\'>Know more</a></p>","code":[["git commit --amend"],["git commit --amend","git push -f"]]},{"parent":"git","url":"command-git","name":"remove-commit","title":"Git. Remove a commit","description":"<p>The <code>git reset</code> command is a tool for undoing changes. If you run it without indicating a commit SHA, it will only remove the changes added to the staging area.</p><p>It has 3 arguments that correspond to the 3 internal mechanisms of Git state management, the confirmation tree (HEAD), the staging area, and the working directory.</p><p>When we specify the type of reset we want with one of these arguments, we indicate the previous SHA commit to all those we want to delete: <ul><li><code>--mixed</code>: It is the default option, it causes the same effect as executing<code>git reset</code>. Removes the commits after the selected commit. Remove the changes from the stage area, but keep the ones from the working directory.</li><li><code>--soft</code>: Removes the commits after the selected commit, but keeps the changes added to the stage area and keeps the changes made in the working directory.</li><li><code>--hard</code>: It is the most dangerous option because you lose all the changes made. Remove the commits after the selected commit, which also removes the changes from the stage area and the working directory.</li></ul></p>","code":[["git reset --soft <COMMIT_ID>"],["git reset --mixed <COMMIT_ID>"],["git reset --hard <COMMIT_ID>"]]},{"parent":"git","url":"command-git","name":"squashing-commits","title":"Git. Squashing or merging of commits","description":"<p>The process of deleting a number of commits with the argument <code>--soft</code> and then making a commit is usually called doing <strong>squashing</strong>, as it is like compacting several commits into one.</p>","code":["git reset --soft master~<NUMBER_LAST_COMMITS>","git commit -m \'<COMMIT_MESSAGE>\'"]},{"parent":"git","url":"command-git","name":"revert-commit","title":"Git. Reverses changes to a commit and creates a new one","description":"<p>This command allows us to create a commit with the changes reverted of the indicated reference. In other words, if we have a commit that added one line and deleted two, we are now creating another commit that deletes the added line and adds the two deleted ones.<br>After running this command in the terminal, it will ask us for the message and create a new commit.</p>","code":"git revert <COMMIT_ID>"},{"parent":"git","url":"command-git","name":"add-stash","title":"Git. Save changes on the stash","description":"<p>Git has an area called the <strong>stash</strong> where you can temporarily store a snapshot of your changes without committing them to the repository. It’s separate from the working directory, the staging area, or the repository.<br> This functionality is useful when you’ve made changes to a branch that you aren’t ready to commit, but you need to switch to another branch. This saves your changes, that will be available from any branch in that repository and reverts the working directory to what it looked like for the latest commit.<br>Note that changes you want to stash need to be on tracked files. If you created a new file and try to stash your changes, you may get the error <em>\'No local changes to save\'</em>.</p><p>Snapshots are saved in the format <code>stash@{0}: BRANCH: SHA MESSAGE</code>. They will be saved with an identifier of type <code>stash@{0}</code>, where <code>stash</code> indicates that it is a snapshot and the number between the keys, <code>{0}</code>, is the index of that <code>stash</code>. The number of the index grows as you create new snapshots and are ordered inversely, ie the smaller number will always be the last snapshot made. The branch in which the changes were made is indicated, and the identifier and message will be the same as the last commit we have in the repository.</p><p>By default, send all the files we have in the working directory and the staging area, except the untracked ones, to the <code>stash</code> zone. And it generates the message automatically. But there are several options that we can add to the command:<ul><li><code>--include-untracked</code> or <code>-u</code>: Add also the untracked files.</li><li><code>--all</code> or <code>-a</code>: Add also the untracked and ignored files (.gitignore).</li><li><code>--patch</code>: Git will not stash everything that is modified but will instead prompt you interactively which of the changes you would like to stash and which you would like to keep in your working directory.</li><li><code>push -m</code>: Allows us to specify a message for the commit we are sending to the stash.</li><li><code>save</code>: It is deprecated in favour of <code>push -m</code>.</li></ul></p><p><a href=\'https://www.freecodecamp.org/news/git-stash-explained/\' target=\'_blank\'>Know more</a></p>","code":[["git stash"],["git stash -u"],["git stash -a"],["git stash --patch"],["git stash push -m \'<STASH_MESSAGE>\'"],["git stash save \'<STASH_MESSAGE>\'"]]},{"parent":"git","url":"command-git","name":"get-stash-list","title":"Git. Get a list of saved stash","description":"<p>When you have a lot of snapshots saved, you\'ll want to see a list of all of them so you can select them. The message and id, which by default come from the confirmation, will help you differentiate them.<br>It is advisable to clean the stash or delete those snapshots that we do not need so as not to accumulate them.</p>","code":"git stash list"},{"parent":"git","url":"command-git","name":"get-stash","title":"Git. Re-applying your stashed changes","description":"<p>There are two different ways to recover the changes saved in the stash: <code>apply</code> and <code>pop</code>.</p><p>By default, executing any of these 2 commands we can recover the last stash saved, <code>stash@{0}</code>. The difference is that the option <code>apply</code>, keeps the change in the list for a possible later reuse, and <code>pop</code> after apply the change removes it from the stash stack, but if during this process there are conflicts, it will not delete it, leaving it to behave exactly like <code>apply</code> option.<br>>Another way to do the same as with the <code>pop</code> option is to do it in 2 steps: <code>git stash apply</code> && <code>git stash drop</code>.</p><p>Or also, we can obtain the changes of a specific stash from out stack, indicating their index number.</p><p><a href=\'https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning#_git_clean\' target=\'_blank\'>Know more</a></p>","code":[["git stash apply"],["git stash pop"],["git stash apply","git stash drop"],["git stash apply stash@{<STASH_NUMBER>}"],["git stash apply <STASH_NUMBER>"]]},{"parent":"git","url":"command-git","name":"create-stash-branch","title":"Git. Create a branch from a stash","description":"<p>This is a nice shortcut to recover the code saved in the indicated stash and create a new branch to work on it separately. This command creates a new branch with the latest stash (<code>stash@{0}</code>), and then delete it (<code>git stash pop</code>). If you need a particular stash you can specify the stash id.</p><p>This will be useful when you run into conflicts after you’ve applied the stash to the latest version of your branch.</p><p><a href=\'https://www.freecodecamp.org/news/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a/\' target=\'_blank\'>Know more</a></p>","code":[["git stash branch <BRANCH_NAME>"],["git stash branch <BRANCH_NAME> stash@{<STASH_NUMBER>}"]]},{"parent":"git","url":"command-git","name":"show-stash","title":"Git. Show the stash diffs","description":"<p>The <code>show</code> option of the <code>stash</code> command gives a very brief summary of the changes made to the files. It shows in one line the path and name of the file, and the number of deleted lines.</p><p>Default, shows the information of the last stash (<code>stash@{0}</code>), but we can indicate an index number to see some other.</p><p>If we want to go deeper and see all the changes of each line of the file in the terminal editor we can use the option <code>-p</code>.</p><p><a href=\'https://howto.lintel.in/how-to-see-stashed-changes-using-git-stash/\' target=\'_blank\'>Know more</a></p>","code":[["git stash show"],["git stash show stash@{<STASH_NUMBER>}"],["git stash show -p"]]},{"parent":"git","url":"command-git","name":"remove-stash","title":"Git. Remove stash","description":"<p>There are two different ways to remove the changes saved in the stash area: <code>drop</code> and <code> clear</code>.</p><p>We can remove the top stashed element saved (the last stash: <code>stash@{0}</code>) with <code>drop</code> or if you no longer need a particular stash, select it by their index number.</p><p>But, if what we want is to clean the storage area completely, the <code>clear</code> option deletes all the stashes list.</p><p><strong>IMPORTANT WARNING</strong>: With <code>clear</code>option those states will then be subject to pruning, and may be impossible to recover. Use both of them with caution, it maybe is difficult to revert the once deleted stashes.</p><p>To confirm if all cleared, obtain again the stashes list with <code>git stash list</code> command.</p><p><a href=\'https://kolosek.com/git-stash/\' target=\'_blank\'>Know more</a></p>","code":[["git stash drop"],["git stash drop stash@{<STASH_NUMBER>}"],["git stash drop <STASH_NUMBER>"],["git stash clear"]]},{"parent":"git","url":"command-git","name":"recover-dropped-stash","title":"Git. Recovering a deleted commit from the stash","description":"<p>Let\'s say you have cleaned up your repository, you have just deleted all the old commits stored in the stash and you just realized that in one of those commits you had important changes that you have not saved.</p><p><strong>Don\'t panic</strong>, you may be able to recover the lost changes with the <code>git fsck</code> command.</p><p>To solve this problem the first thing to do is to locate the hash ID (6 digits) of the deleted commit. Once we have it we can see in detail the information it contains and decide if it is the one we are looking for. If it is, all we have to do is to save it again.</p><p>Let\'s see it in detail: <ol><li><strong>Find deleted stash commits</strong><br>The following command will show you a graph with all the commits that are no longer referenced from any branch or tag, i.e., every missing commit you have created, including those from the stash.</br><em>Shell bash/sh:</em><br><code>git log --graph --oneline --decorate $( git fsck --no-reflog | awk \'/dangling commit/ {print $3}’ )</code><br>Somewhere in that graph you will find the confirmation message you are looking for.<br> Tip: If you did not provide a message when you did <code>git stash</code>, this commit will start with <code>WIP on</code>.</li><li><strong>Confirm that these are the changes we are looking for</strong><br>Once you have the commit hash of the stash you can use the command <code>git show &lt;COMMIT_ID&gt;</code> to examine in detail the commit <code>diff</code>, i.e., the names of the modified folders, files and lines of code.</li><li><strong>Retrieve the changes and save them</strong><br>After committing the changes you want to retrieve, you can bring them back to the workspace using <code>git stash apply &lt;COMMIT_ID&gt;</code>.<br> And if, just in case, you also want to save those changes back to the stash list located in <code>.git/logs/refs/stash</code>, you can use the command <code>git stash &lt;COMMIT_ID&gt;</code>.</li></ol></p><p><a href=\'https://gist.github.com/joseluisq/7f0f1402f05c45bac10814a9e38f81bf\' target=\'_blank\'>Know more</a></p>","code":["git log --graph --oneline --decorate $( git fsck --no-reflog | awk \'/dangling commit/ {print $3}\' )","git show <COMMIT_ID>","git stash apply <COMMIT_ID>"]},{"parent":"git","url":"command-git","name":"exit-from-vim-without-save","title":"Git. Exit without save from the text window","description":"<p>If you\'re inside the <strong>Vi</strong> editor (text editor created for UNIX, whose improved version is called <strong>Vim</strong>) and you want to just come out from the text window without save the changes, typing the command and press <em>\'enter\'</em>.</p><p><a href=\'https://phoenixnap.com/kb/how-to-vim-save-quit-exit\' target=\'_blank\'>Know more</a></p>","code":":q!"},{"parent":"git","url":"command-git","name":"exit-from-vim-and-save","title":"Git. Exit and save from the text window","description":"<p>If you\'re inside the <strong>Vi</strong> editor (text editor created for UNIX, whose improved version is called <strong>Vim</strong>) and you want come out from the text window and save the changes, typing the command and press <em>\'enter\'</em>.</p><p><a href=\'https://phoenixnap.com/kb/how-to-vim-save-quit-exit\' target=\'_blank\'>Know more</a></p>","code":":wq"},{"parent":"git","url":"command-git","name":"reflog","title":"Git. View reference log (reflog)","description":"<p>Before talking about the reference journal, it should be remembered that <code>HEAD</code> is a reference that points to the most recent commit of the current branch.</p><p>There is a record of all the references taken by the <code>HEAD</code> pointer in Git called <strong>reflog</strong> (reference record shortcut). It is a list that will store all commits where the pointer passes, for example, it will be able to save branch changes or the addition of a commit.</p><p>This command can be very useful, in case you want to recover a deleted commit.<ul><li><code>git reflog</code>: It will show you all the commits you made regardless of whether you deleted them or not. Each commit will display a small amount of information about itself: the hash number (6 digits), the branch it belongs to, the index of the position occupied by its pointer <code>HEAD</code> and the first line of the message.</li><li><code>git show &lt;COMMIT_ID&gt;</code>: Seeing this information we can find the commit we want and access it by its hash number. So we can see in detail its information: its complete hash number, the author and date of the commit, the complete commit message and which files and lines have been added, deleted or modified.</li><li><code>git reset --mixed &lt;COMMIT_ID&gt;</code>: We use this command, once we are sure that we want to recover this commit and so we will get back the files with the changes we had deleted. This command does not generate a commit with these changes, so we will have to run <code>git commit</code> to save them again. We will be able to recover the message we used with the previous command <code>git show</code>, since it showed us the complete message.</li></ul></p><p><a href=\'https://www.atlassian.com/git/tutorials/rewriting-history/git-reflog\' target=\'_blank\'>Know more</a></p>","code":[["git reflog"],["git reflog --format=\'%C(auto)%h %<|(17)%gd %C(blue)%ci%C(reset) %s\'"],["git reflog","git show <COMMIT_ID>","git reset --mixed <COMMIT_ID>"]]},{"parent":"git","url":"command-git","name":"reflog-remove","title":"Git. Prune all references with garbage collection and reclaim space","description":"<p>The <code>expire</code> subcommand cleans up old or unreachable <strong>reflog</strong> entries. It has potential for data loss and is not typically used by end users, but used by git internally. By default, the <strong>reflog</strong> expiration date is set to 90 days. An expire time can be specified by passing a command line argument or by setting a git configuration name.</p>","code":["rm -rf .git/refs/original/","git reflog expire --expire=now --all","git gc --aggressive --prune=now"]},{"parent":"git","url":"command-git","name":"get-branches","title":"Git. Get all branches","description":"<p>Sometimes it is necessary to know what branches exist in a remote repository in order to determine the names of the available branches.</p><p>With this command you can list both types of branches: remote and local. The current branch will be highlighted in color and marked an asterisk <code>*</code>.</p>","code":[["git branch --all"],["git branch -a"]]},{"parent":"git","url":"command-git","name":"get-branches-local","title":"Git. Get all local branches","description":"<p>A local branch is one whose full name starts with <code>refs/heads/</code>, the <code>git branch</code> command strips off this part to make it easier.</p><p>It seems that with git there is always more than one way to do the same thing:</p>","code":[["git branch"],["git branch --list"],["git branch -l"]]},{"parent":"git","url":"command-git","name":"get-branches-remotes","title":"Git. Get all remote branches","description":"<p>A remote-tracking branch is one whose full name starts with <code>refs/remotes/</code>, this command remove this part to make it easier.</p>","code":[["git branch --remotes"],["git branch -r"]]},{"parent":"git","url":"command-git","name":"create-branch","title":"Git. Create a new branch","description":"<p>You can create a new branch while in another and move to it later.</p>","code":"git branch <NEW_BRANCH_NAME>"},{"parent":"git","url":"command-git","name":"checkout-branch-path","title":"Git. Checkout branch/path","description":"<p>The command <code>git checkout &lt;NAME&gt;</code> is really meant for branches, but Git syntax is relaxed, and if Git can\'t find a branch, then it will look for a file.</p><p>Suppose you have a file and a branch with the same name, <code>stuff</code>. Then the following command would seem ambiguous, <code>git checkout stuff</code>, because it is not clear whether you are asking to checkout a file or a branch.<br> With <code>--</code> is a way to tell Git to treat what follows <code>checkout</code> as a file and not as a branch, when you use it, it explicitly tell Git to checkout a file by that name/path</p><p>This command made: <ul><li>If it\'s local branch or remote branch tracked, switch to it.</li><li>If it\'s a tracked path of a file, reset it, i.e. delete the unsaved changes from the working directory.</li><li>If it\'s a remote branch, create a tracking branch and switch to it.</li></ul></p><p>So in this case the following commands allow you to move a local branch or download it from the remote and reset a file:</p>","code":[["git checkout <BRANCH_NAME>"],["git checkout -- <FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"move-to-branch","title":"Git. Move to the branch","description":"<p>When you try move to a local branch that does not exist, this command will search to see if there is a remote-tracking branch with a similar name. If so, it will create the local branch and set it up to track the remote-tracking branch.</p>","code":"git checkout <BRANCH_NAME>"},{"parent":"git","url":"command-git","name":"create-and-move-to-branch","title":"Git. Create and move to branch","description":"<p>You must use a separate branch for each function or issue you work on. With this command you make 2 steps at the same time, create and move to the branch so that all changes you make are applied to it. The <code>-b</code> flag tells git to create it if it doesn\'t already exist, otherwise, it is reset, that is to say, the branch is not reset/created unless <code>git checkout</code> is successful.</p>","code":[["git checkout -B <NEW_BRANCH_NAME>"],["git checkout -b <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"extract-files-from-staging-area","title":"Git. Extract files from the staging area","description":"<p>If I have already added the file with a <code>git add</code> to the <strong>staging area</strong> but don\'t want to commit it yet, and want to remove it from this zone, these are some ways to solve it:<ul><li><code>git reset &lt;FILE_NAME&gt;</code>: If changes have been made and added to the <strong>staging area</strong>.</li><li><code>git rm --cached &lt;FILE_NAME&gt;</code>: If I have not launched a commit yet, and therefore the <code>HEAD</code> pointer has not been created.</li><li><code>git reset HEAD &lt;FILE_NAME&gt;</code>: If I\'ve already launched my first commit, i.e. there\'s a HEAD pointer. Git moves between the commits always pointing to the last one created.</li></ul></p>","code":[["git reset <FILE_NAME>"],["git rm --cached <FILE_NAME>"],["git reset HEAD <FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-current-branch","title":"Git. Rename current branch","description":"<p>It is possible that at some time, as with the commit messages, you may want to rename a branch.<br>With this command you can rename the local branch you are working on.</p><p>It has  optional parametters: <ul><li><code>--move</code> or <code>-m</code>: Move/rename a branch and the corresponding reflog.</li><li><code>-M</code>: It is a shortcut of <code>--delete --force</code></li></ul></p><p><a href=\'https://git-scm.com/docs/git-branch\' target=\'_blank\'>Know more</a></p>","code":[["git branch -m <NEW_BRANCH_NAME>"],["git branch -M <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-local-branch","title":"Git. Rename a local branch","description":"<p>You can rename a local branch while you are in any other branch.</p>","code":[["git branch -m <OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-remote-branch","title":"Git. Rename a remote branch","description":"<p>Let\'s say you are collaborating on a project with a group of people, and you have defined a naming convention for git branches. You created a new branch, pushed the changes to the remote repository, and realized that your branch name was incorrect. Luckily, git allows you to rename the branch local and remote very easily using several commands or doing the same thing with just one.</p><p><a href=\'https://linuxize.com/post/how-to-rename-local-and-remote-git-branch/\' target=\'_blank\'>Know more</a></p>","code":[["git checkout <OLD_BRANCH_NAME>","git branch -m <NEW_BRANCH_NAME>","git push origin -u <NEW_BRANCH_NAME>","git push origin --delete <OLD_BRANCH_NAME>"],["git push origin :<OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"upload-local-branch","title":"Git. Send the local branch to remote repository","description":"<p>It is recommended to send the new branch to the remote repository (<code>ORIGIN</code>), since this acts as backup, and when collaborating with other developers, it allows them access to see the commits made in the new branch. La opción <code>-u</code> or <code>--set-upstream-to</code> adds it as a remote tracking branch.</p>","code":[["git branch --set-upstream-to origin/<OTHER_BRANCH_NAME>"],["git push origin -u <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"remove-branch","title":"Git. Remove a branch","description":"<p>To delete a branch from git repository you must not be positioned in it.</p>","code":[["git branch -D <BRANCH_NAME>"],["git branch -d <BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"merge-branch","title":"Git. Merge branch","description":"<p>The fusion is Git\'s way of putting a forked history back together again. The <code>git merge</code> command lets you take the independent lines of development created by <code>git branch</code> command and integrate them into a single branch.<br>It takes two confirmation pointers from the ends of each branch and combines them into the current branch, generating a new <strong>merge commit</strong>. However, if git find data that has been changed in both histories, it will be unable to automatically combine them. In that case, a version control conflict is created and Git will ask for user intervention to continue.</p><p>Before performing a merge there are a couple of preparation steps to take to ensure the merge goes smoothly: <ul><li><strong>Confirm the receiving branch:</strong> Make sure<code>HEAD</code> points to the correct branch with the <code>git status</code> command. If needed, execute <code>git checkout</code> to switch to the receiving branch.</li><li><strong>Fetch latest remote commits: </strong> Make sure the receiving branch and the merging branch are updated with the latest remote changes. Execute <code>git fetch</code> to pull the latest remote commits. Once the fetch is completed ensure the master branch has the latest updates by executing <code>git pull</code>.</li></ul></p><p>This means that <code>git merge</code> is often used in conjunction with <code>git checkout</code> for selecting the current branch and <code>git branch -d</code> for deleting the obsolete target branch.</p><p>If the two branches you\'re trying to merge both changed the same part of the same file, Git won\'t be able to figure out which version to use. When such a situation occurs, it stops right before to create the <strong>merge commit</strong> so that you can resolve the conflicts manually. When Git encounters a conflict during a merge, It will edit the content of the affected files with visual indicators that mark both sides of the conflicted content <code><<<<<<<</code> <code> =======</code> <code>>>>>>>></code>. The content before the <code>=======</code> marker is the receiving branch and the part after is the merging branch.Once you\'ve identified conflicting sections, you can go in and fix up the merge to your liking. When you\'re ready to finish the merge, all you have to do is run <code>git add</code> on the conflicted file(s) to tell Git they\'re resolved. Then, you run <code>git commit</code> to generate the <strong>merge commit</strong>.</p><p><a href=\'https://www.atlassian.com/es/git/tutorials/using-branches/git-merge\' target=\'_blank\'>Know more</a></p>","code":[["git merge <BRANCH_NAME>"],["git merge --continue"],["git merge --abort"]]},{"parent":"git","url":"command-git","name":"merge-fast-forward","title":"Git. Merge commit","description":"<p>The <code>--no-ff</code> flag prevents <code>git merge</code> from executing a <strong>\'fast-forward\'</strong> if it detects that your current <code>HEAD</code> is an ancestor of the commit you\'re trying to merge. A <strong>fast-forward</strong> is when, instead of constructing a <strong>commit merge</strong>, git just moves your branch pointer to point at the incoming commit.</p><p>Occasionally you want to prevent this behavior from happening, typically because you want to maintain a specific branch topology (e.g. you\'re merging in a topic branch and you want to ensure it looks that way when reading history). In order to do that, you can pass the <code>--no-ff</code> flag and <code>git merge</code> will always construct a merge instead of <strong>fast-forwarding</strong>.</p>","code":["git merge <BRANCH_NAME> --no-ff"]},{"parent":"git","url":"command-git","name":"rebase","title":"Git. Rebase","description":"<p>At Git we have two ways of integrating changes from one branch to another: the fusion (<code>merge</code>) and the reorganization (<code>rebase</code>).</p>Git <code>rebase</code> allows us to modify the history of Git using a reference point. It captures all confirmed changes from the branch we\'re in and applies them to the one we\'re indicating you about, that is, it is able to recognize that commits are not on the timeline for that reference point and apply them on top of the reference point, this is what we call in Git <strong>rebasing</strong>.<br>In contrast to the merge, this generates a perfectly linear project history, being able to go from the end of the branch to the start of the project without finding any bifurcation.</p><p>It\'s very important to understand that, even though the branch looks the same, it is made up of entirely new commits, which changes the history of Git. This implies that these commits are being recreated with the same message and content, which can lead to <strong>conflicts</strong> when applying them to the new branch if it has new changes.<br>If this happens, they have to be resolved as they occur and are considered modifications of the commit itself. This allows us to delete, reorder, merge or change the commit message before applying them. When you have the changes fixed, you will have to ask the command to continue with the <code>--continue</code> option to apply the next commit.<br>At any time during <code>rebase</code> if you change your mind you can reject the whole process with the <code>--abort</code> option.</p>","code":[["git rebase <BRANCH_NAME>"],["git rebase --continue"],["git rebase --abort"]]},{"parent":"git","url":"command-git","name":"cherry-pick","title":"Git. Cherry-pick: Copy and paste commits","description":"<p>It may happen that, at some point, we want to apply some of the changes we have made in another branch without having to make a full merge. The <code>cherry-pick</code> command allows  allows you to <em>\'copy\'</em> one or more commits from one branch and <em>\'paste\'</em> them into another branch. Before using, you must have a clean <strong>working directory</strong> and <strong>staging area</strong>. </p><p>By default <code>cherry-pick</code> keeps the original commit message, so the <code>-x</code> option may be useful to add a reference to the original commit, so that you know where you\'ve got this commit from. Other interesting options are <code>-e</code>, which allows you to edit the commit message instead of using the original one and the <code>-n</code> option which will apply the changes but not make any commits.</p><p>As with the <code>merge</code> and <code>rebase</code> commands, after resolving the conflicts, we can indicate to continue applying the changes with the option <code>--continue</code> or reject the process completely with the option <code>--abort</code>.</p><p><a href=\'https://www.runroom.com/realworld/seleccionando-commits-cherry-pick\' target=\'_blank\'>Know more</a></p>","code":[["git cherry-pick"],["git cherry-pick <COMMIT_ID>"],["git cherry-pick -x"],["git cherry-pick -e"],["git cherry-pick -n"],["git cherry-pick --continue"],["git cherry-pick --abort"]]},{"parent":"git","url":"command-git","name":"diff","title":"Git. Comparing changes with git diff","description":"<p>We can see what changes have been made to the code with the command <code>diff</code>. This shows on the terminal the lines of code that have been removed with the symbol <code>-</code> and in red, and the lines added with the symbol <code>+</code> and in green.</p><p>The next tool online can help you. <strong>DiffMerge</strong> is an application to visually compare and merge files on Windows, OSX and Linux: <a href=\'http://sourcegear.com/diffmerge/\' target=\'_blank\'>http://sourcegear.com/diffmerge/</a></p><p>We can also compare the changes that have been made to the code of several commits.</p><p><a href=\'https://www.atlassian.com/git/tutorials/saving-changes/git-diff\' target=\'_blank\'>Know more</a></p>","code":[["git diff"],["git diff <COMMIT_ID_1> <COMMIT_ID_2>"]]},{"parent":"git","url":"command-git","name":"mark-conflicts-resolved","title":"Git. Mark that the conflict is resolved","description":"<p>Steps to follow after resolving a conflict in the files: <ul><li>Add all files to the index zone</li><li>View the status of the files (modified/deleted/added)</li><li>Create a commit with those changes indicating a description of what has been done.</li></ul></p>","code":["git add .","git status","git commit -m \'<COMMIT_MESSAGE>\'"]},{"parent":"git","url":"command-git","name":"get-tags","title":"Git. Get all tags made","description":"<p>Get a simple list of the tags, if you want to make sure they exist and what their version numbers are.</p>","code":[["git tag --list"],["git tag -l"]]},{"parent":"git","url":"command-git","name":"create-tag","title":"Git. Create a new tag","description":"<p>In software development, git tags represent a version of our code at a given moment in time. Unlike branches, tags are not mutable y always point to the same commit, them so people generally use them to mark important points in git history (as the release points v1.0, v2.0 and so on).</p><p>The <a href=\'https://semver.org/\' target=\'_blank\'>Semantic Versioning</a> use a version format based on 3 integers separated by points: <em>X.Y.Z</em> (<em>Major.Minor.Patch</em>), bug fixes not affecting the API increment the patch version, backwards compatible API additions/changes increment the minor version, and backwards incompatible API changes increment the major version.This would be translated to gitflow branch structure as <em>release.feature.bug</em>.<br>The developer is the responsible for communicating the status of their software publishing this number.</p><p><a href=\'https://semver.org/\' target=\'_blank\'>Know more</a></p>","code":"git tag -a \'<TAG_VERSION>\' -m \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"remove-local-tag","title":"Git. Remove a local tag","description":"Delete existing local tag with the given names","code":[["git tag -d <TAG_VERSION>"],["git tag --delete <TAG_VERSION>"]]},{"parent":"git","url":"command-git","name":"remove-tag-remote","title":"Git. Remove a remote tag","description":"Delete existing remote tag with the given names.","code":"git push --delete origin <TAG_VERSION>"},{"parent":"git","url":"command-git","name":"remove-and-upload-tag","title":"Git. Remove local and remote tag","description":"<p>When you want rename or remove a tag and you have already pushed it to a remote repository (eg. GitHub) then you’ll also need to update the remote references right after renaming or deleting the tag from your local repo.</p><p>Here are two alternatives for remove a tag on the local and remote repository:<ul><li>Delete the local tag and overwrite this change by referring to the name of the deleted tag in the remote repository.</li><li>Or do the process in reverse, delete it first the tag in the remote repository and then in the local repository.</li></ul></p><p><a href=\'https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/\' target=\'_blank\'>Know more</a></p>","code":[["git tag -d <TAG_VERSION>","git push origin :refs/tags/<TAG_VERSION>"],["git push --delete origin <TAG_VERSION>","git tag -d <TAG_VERSION>"]]},{"parent":"git","url":"command-git","name":"rename-local-tag","title":"Git. Rename a local tag","description":"<p>If you use tags in your projects, you probably have encountered some issue that forced you to remove the tag: <ul><li>There was a change that had to be shipped with this release and you forgot all about it.</li><li>There’s some debugging code that wasn’t supposed to be included with this release.</li><li>There’s a really obvious typo that everyone will notice right away.</li></ul></p><p>If you have not yet uploaded the tag to the remote repository, you can rename the tag with the following command:</p><p><a href=\'https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/\' target=\'_blank\'>Know more</a></p>","code":"git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>"},{"parent":"git","url":"command-git","name":"rename-and-upload-tag","title":"Git. Rename a tag and push it","description":"<p>If you have made a mistake and need to rename a tag and update it in the remote repository, you should follow these steps:<ol><li>Rename the local tag.</li><li>Remove the old tag so that git knows about the change.</li><li>Tell the remote git repository that you\'ve removed the old tag.</li><li>Update remote repository tags to upload new tag.</li></ol></p>","code":["git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>","git tag -d <OLD_TAG_VERSION>","git push origin :refs/tags/<OLD_TAG_VERSION>","git push --tags"]},{"parent":"git","url":"command-git","name":"update-remote-repository","title":"Git. Update remote repository","description":"<p>This is highly desirable when working in a team workflow where remote branches are removed after merging with <code>master</code> or are left with obsolete tags.</p><p>In this case, you will want to remove references to branches or tags that no longer exist on the remote control by connecting to the remote control and getting the last status before pruning.</br> It\'s essentially a combination of commands:</p>","code":"git fetch --all && git remote prune"},{"parent":"git","url":"command-git","name":"update-local-tags","title":"Git. Update local tags","description":"<p>If your project is open source, you will probably have to update the status of your local repository from time to time, since other people may have removed or renamed some tags while you were working and you now may have obsolete local tags.</p><p>This command prunes the tags that no longer exist in the remote repository but in your local repository.</p>","code":"git pull --prune --tags"}],"gitFlow":[{"parent":"gitFlow","url":"command-git-flow","name":"create-gitflow-repository","title":"Git Flow. Initialize repository","description":"<p>Git-flow is a <strong>workflow</strong> applied to a Git repository.<br> Every project usually has at least 2 infinite branches: <code>develop</code> containing the code under development and <code>master</code> containing each of the stable versions to include in production.<br>  This branching model, designed around project releases, also has a set of support branches, which are time-limited and eventually removed. These branches allow teamwork, for the creation of new features (<code>feature</code>), bug resolution in development (<code>bugfix</code>), urgent bug resolution in production (<code>hotfix</code>) and the release of different versions (<code>release</code>). </p><p>Start using it by initializing it inside an existing git repository with <code>git flow init</code>. At first, Git-flow needs to be initialized to customize the project configuration, you will have to answer some questions about the naming conventions of your branches, at this point you can rename the branches if you wish, although it is recommended to use the default values (<code>feature</code>, <code>release</code>, <code>hotfix</code> and <code>support</code>).</p>","code":[["git flow init"],["git flow init","","Initialized empty Git repository in ~/project/.git/","No branches exist yet. Base branches must be created now.","Branch name for production releases: [master]","Branch name for \\"next release\\" development: [develop]","","How to name your supporting branch prefixes?","Feature branches? [feature/]","Release branches? [release/]","Hotfix branches? [hotfix/]","Support branches? [support/]","","git branch","* develop","master"]]},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-start","title":"Git Flow. Start a new feature","description":"<p>When a new functionality or feature of the project is to be developed, a new branch called <code>feature</code> is created. This type of branches are born from the <code>develop</code> branch and once development is finished, they are incorporated back to it. </p><p>The following command is a shortcut, which includes the execution of several commands: <ul><li><code>git checkout develop</code></li><li><code>git branch feature/&lt;BRANCH_NAME&gt;</code></li><li><code>git checkout feature/&lt;BRANCH_NAME&gt;</code></li></ul></p>","code":[["git flow feature start <FEATURE_NAME>"],["git checkout -b feature/<FEATURE_NAME> develop"]]},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-list","title":"Git Flow. Get a feature list","description":"<p>You can view a list of the <code>feature</code> branches already created in the local repository using the following command.</p>","code":"git flow feature list"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-publish","title":"Git Flow. Publish a feature","description":"<p>Normally the <code>feature</code> exists only in the local repositories of the developers and not in the source repository. If you want to share this branch with some members of your team in order to do collaborative development, you would have to publish the <code>feature</code> on the remote server so that it can be used by other users.</p>","code":"git flow feature publish <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-pull","title":"Git Flow. Getting a published feature","description":"<p>When more than one person works on a <code>feature</code> at the same time, it will be published by your teammates, and you will be able to develop on the same branch with them.</p><p>If this is the first time you participate in the project, you will first have to clone repository using <code>git clone &lt;URL&gt;</code> to have a copy on your computer (local repository), then initialize Gitflow with <code>git flow init</code> and download the <code>master</code> and <code>develop</code> branches with the commands <code>git checkout master</code> and <code>git checkout develop</code>.</p><p>If you are already participating in the project you can skip the above steps and use the following command to download a <code>feature</code> and to make sure that the local repository is synchronized with the remote one.</p>","code":"git flow feature pull origin <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-track","title":"Git Flow. Track a published feature","description":"<p>Say you have created a new feature with <code>git flow feature start &lt;FEATURE_NAME&gt;</code>, and published it to the remote repository with <code>git flow feature publish &lt;FEATURE_NAME&gt;</code> so that other members of your team can collaborate with you using <code>git flow feature pull &lt;FEATURE_NAME&gt;</code> to download it. This creates a new branch in your local repository, based on the remote branch, however this does not set it up so that changes made to it, are tracked by the remote branch, so it now has to be tracked manually.</p><p>With the following command <code>git flow feature track &lt;FEATURE_NAME&gt;</code>, your co-worker, can download the <code>feature</code> and also track changes others make to the one published in the source repository. </p><p>To illustrate the collaborative aspect with a branch of a new feature, using the pull request aspect of GitHub that facilitates the code review and discussion part, we put ourselves in the following situation:<ul><li>Several people work on the same feature and as changes are committed, they are submitted to GitHub (or once at the end of development if preferred). </li><li>When the feature is complete, a pull request is opened on GitHub comparing <code>develop</code> and with the branch.</li><li>The team reviews the pull request and makes comments.</li><li>Any changes to the pull request are made to the feature branch. </li><li>Once all changes are incorporated into the feature branch it is terminated:<code>git flow feature finish &lt;FEATURE_NAME&gt;</code>.</li><li><li>The <code>develop</code> branch is sent to GitHub (GitHub will automatically mark the pull request as closed/merged when this happens).</li></ul><p>However, that leaves the problem of closing that branch, whoever runs first <code>git flow feature finish &lt;FEATURE_NAME&gt;</code> will have the luxury of deleting your local branch, but anyone else who has checked out the branch will have to do it manually if they wish. You can use <code>git fetch --prune</code> or a simple <code>git fetch</code> to remove your branch if it has already been removed on the remote. </p><p>If you have already downloaded the branch and now you need to track it, all you have to do would be for your existing branch to trace back to the previous branch with <code>git branch -u origin feature/&lt;FEATURE_NAME&gt;</code> or <code>git branch --set-upstream-to origin feature/&lt;FEATURE_NAME&gt;</code></code></p><p>In general, it would be best to start using <code>git flow feature track &lt;FEATURE_NAME&gt;</code> and then keep your branch updated with <code>git flow feature pull origin &lt;FEATURE_NAME&gt;</code>.</p><p><a href=\'https://stackoverflow.com/questions/18412750/why-doesnt-git-flow-feature-pull-track\' target=\'_blank\'>Know more</a></p>","code":"git flow feature track <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-finish","title":"Git Flow. Finish up a feature","description":"<p>When development of the new feature is complete, it should be merged with <code>develop</code> and removed from the local repository and the remote repository if it was uploaded.</p><p>The following command performs the following commands: <ul><li><code>git checkout develop</code></li><li><code>git merge feature/&lt;FEATURE_NAME&gt;</code></li><li><code>git branch -D &lt;FEATURE_NAME&gt;</code></li></li><li><code>git push origin :&lt;FEATURE_NAME&gt;</code></li></ul></p>","code":"git flow feature finish <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-bugfix-start","title":"Git Flow. Start a bugfix","description":"<p>During the development of the project you may encounter errors in one of the branches of the repository. To fix them we have 2 different types of branches depending on the place these errors occupy in the git workflow: <code>bugfix</code> and <code>hotfix</code>.</p><p>The term <code>bugfix</code> or <strong>bug fixes</strong> are used when a problem is found during the development phase, to fix bugs from a previous feature or development omissions.<br> These types of branches are created from <code>develop</code> and merged back into <code>develop</code> upon completion. </p><p>The following command is the same as running: <ul><li><code>git checkout develop</code></li><li><code>git branch bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git checkout bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>","code":"git flow bugfix start <BUGFIX_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-bugfix-finish","title":"Git Flow. Finish a bugfix","description":"<p>The <code>bugfix</code> branches are temporary branches, which once the bugs are resolved,are removed after merging with the <code>develop</code> branch..</p><p>The following command is the same as running: <ul><li><code>git checkout develop</code></li><li><code>git merge bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git branch -D bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p></p>","code":"git flow bugfix finish <BUGFIX_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-start","title":"Git Flow. Start a release","description":"<p>To prepare our application for production there are some branches called <code>release</code>. In some teams, these branches are the ones that are dumped on the pre-production servers to do the final testing: minor bugs are corrected, the interface is polished, the layout is adjusted...the final tuning of the application is done before releasing the final version. </p><p>The name of the <code>release</code> is a figure of 3 integers separated by dots that increase numerically in increments of 1. This number follows the nomenclature of the <a href=\'https://semver.org/\' target=\'_blank\'>semantic versioning</a>, <code>X. Y.Z</code>, where <code>X</code> is the \'major\' version (incorporation of multiple changes that are no longer compatible with the public API), <code>Y</code> is the \'minor\' version (incorporation of a feature), and <code>Z</code> is the \'patch\' version (bug fixes compatible with the previous version). </br> Therefore, the <code>release</code> number would be the first one, <code>X</code>.</p><p>The following command creates a release branch from the <code>develop</code> branch.<br>Optionally, you can supply the id of a commit located in <code>develop</code> to start the release from the commit.</p><p><a href=\'https://aprendegit.com/git-flow-release-branches/\' target=\'_blank\'>Know more</a></p>","code":"git flow release start <VERSION_NUMBER> <[BASE]>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-list","title":"Git Flow. Get a release list","description":"<p>You can see a lists all the current release branches created on the local repository.</p>","code":"git flow release list"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-publish","title":"Git Flow. Publish a release","description":"<p>If you are working in a team and another of your colleagues must review the code before the release of a new version, it is advisable to publish the release branch after creating it to allow other developers to make release commits.</p>","code":"git flow release publish <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-track","title":"Git Flow. Track a release","description":"<p>You can track the changes a release published on remote repository.</p>","code":"git flow release track <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-finish","title":"Git Flow. Finish up a release","description":"<p>Once the <code>release</code> branch is created, we start the fix and debug process, the necessary commits are performed and when we have finished fixing all the bugs, we are ready to move our project to production and remove the branch.</p><p>Terminating a release is one of the big steps in creating git branches. The following command performs several actions: it merges the version branch with <code>master</code>, tags the version with its name, merges the version back with <code>develop</code> and deletes the version branch.</p><p>When we run this command git-flow will ask us to enter 3 messages: <ol><li>The merge commit message as a result of incorporating the changes in <code>master</code>. </li><li>The message that git-flow will put to the tag it is going to create to identify this version.</li><li>And finally the merge commit message as a result of incorporating the branch to <code>develop</code>.</li></ol></p><p>The execution of this command which can be summarized in the following commands: <ul><li><code>git checkout master</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git tag v&lt;VERSION_NUMBER&gt;</code></li><li><code>git checkout develop</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git branch -d release/&lt;VERSION_NUMBER&gt;</code></li></ul></p>","code":"git flow release finish <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-tags-push-single","title":"Git Flow. Push a single tag","description":"<p>After finishing the release branch, don\'t forget to add the tags to the remote repository. This command will push a single tag to the remote repository.</p>","code":"git push <REPO_NAME> <TAG_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-tags-push","title":"Git Flow. Push all the tags","description":"<p>You can add all tags to the remote repository with a single command. This way is not recommended because it is common for developers to have old or \'bad\' tags in their local repositories that have no need to be in the remote one, so it is advised to only explicitly push one tag and not all its tags at once.</p>","code":"git push <REPO_NAME> --tags"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-hotfix-start","title":"Git Flow. Start a hotfix","description":"<p>Just as there are branches to resolve bugs that we have encountered during the development process, there are other types of branches. These branches, called <code>hotfix</code>, are created to act immediately on an undesired state of a live production version, they are used to fix urgent bugs or omissions that cannot wait for the release of the next version. <br>The lifetime of this branch is temporary, it is created from <code>master</code>, merged back into <code>master</code> and removed after the merge.</p><p>The <code>hotfix</code> name is a figure of 3 whole numbers separated by dots that increment numerically in increments of 1. This number follows the <a href=\'https://semver.org/\' target=\'_blank\'>semantic versioning</a> nomenclature, <code>X.Y.Z</code>, where X is the \'major\' version (incorporation of multiple changes that are no longer compatible with the public API), <code>Y</code> is the \'minor\' version (incorporation of a feature), and <code>Z</code> is the \'patch\' version (bug fixes compatible with the previous version). </br> Therefore, the <code>hotfix</code> number would be the third and last one, <code>Z</code>.</p><p></p><p>Optionally, you can specify a base name, the id of a commit, from which to create the branch.</p>","code":"git flow hotfix start <VERSION_NUMBER> <[BASE_NAME]>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-hotfix-finish","title":"Git Flow. Finish a hotfix","description":"<p>When all fixes have been made to a <code>hotfix</code> branch, the following command must be performed to finalize the branch. This process merges the branch back to <code>develop</code> and <code>master</code>, creates a tag with the version number of the <code>hotfix</code> and deletes that branch, since its existence is temporary.</p>","code":"git flow hotfix finish <VERSION_NUMBER>"}]}')},"56d7":function(e,t,o){"use strict";o.r(t);o("e260"),o("e6cf"),o("cca6"),o("a79d");var a=o("2b0e"),i=function(){var e=this,t=e._self._c;return t("div",{staticClass:"sticky__app",class:{"is-scroll-down":!e.isScrollUp},attrs:{id:"app"}},[t("div",{staticClass:"page-content__wrapper sticky__content"},[t("PageHeader"),t("PageTitle",{class:{"is-fixed":!e.isScrollUp}}),t("router-view")],1),t("PageFooter",{staticClass:"sticky__footer"})],1)},r=[],n=(o("b0c0"),function(){var e=this,t=e._self._c;return t("header",{staticClass:"page-header"},[t("UILogo",{attrs:{theme:"logo--header logo--light"}}),t("PageNav")],1)}),s=[],c=o("07e6"),l=function(){var e=this,t=e._self._c;return t("div",[t("nav",{staticClass:"nav",class:{"is-open":e.isOpen}},[t("ul",{staticClass:"nav__list"},[t("li",{staticClass:"nav__item"},[t("router-link",{staticClass:"nav__link",attrs:{to:"/",exact:""}},[t("span",[e._v("Search")]),t("span",{staticClass:"is-small"},[e._v(" commands ")])])],1),t("li",{staticClass:"nav__item"},[t("router-link",{staticClass:"nav__link",attrs:{to:"/command-git"}},[t("span",[e._v("Git")]),t("span",{staticClass:"is-small"},[e._v(" commands ")])])],1),t("li",{staticClass:"nav__item"},[t("router-link",{staticClass:"nav__link",attrs:{to:"/command-git-flow"}},[t("span",[e._v("Git Flow")]),t("span",{staticClass:"is-small"},[e._v(" commands ")])])],1),t("li",{directives:[{name:"show",rawName:"v-show",value:e.isOpen,expression:"isOpen"}],staticClass:"nav__item"},[t("router-link",{staticClass:"nav__link",attrs:{to:"/bibliografy"}},[e._v(" Bibliografy ")])],1)]),t("button",{staticClass:"nav__button",on:{click:e.openCloseNav}},[t("i",{staticClass:"nav__icon"},[t("font-awesome-icon",{attrs:{icon:["fas","code-branch"]}})],1)]),t("i",{staticClass:"nav__bg-mobile",class:{"is-view":e.isOpen}},[t("font-awesome-icon",{attrs:{icon:["fas","code-branch"]}})],1)])])},d=[],m={name:"PageNav",data:function(){return{isOpen:!1}},watch:{$route:function(e,t){e!==t&&this.closeNav()},isOpen:function(){document.body.style.overflow=this.isOpen?"hidden":""}},created:function(){window.addEventListener("resize",this.handleResize)},destroyed:function(){window.removeEventListener("resize",this.handleResize)},methods:{openCloseNav:function(){0==this.isOpen?this.isOpen=!0:this.isOpen=!1},closeNav:function(){this.isOpen=!1},handleResize:function(e){var t=768;e.target.outerWidth>=t&&this.closeNav()}}},u=m,h=(o("0e51"),o("2877")),p=Object(h["a"])(u,l,d,!1,null,"7a087702",null),g=p.exports,f={name:"PageHeader",components:{UILogo:c["a"],PageNav:g}},b=f,w=(o("6330"),Object(h["a"])(b,n,s,!1,null,"5236393a",null)),y=w.exports,v=function(){var e=this,t=e._self._c;return"Home"!=e.$route.meta.title?t("h1",{staticClass:"page-title"},[e._v(" "+e._s(e.$route.meta.title)+" ")]):e._e()},E=[],_={name:"PageTitle"},A=_,T=(o("c89c"),Object(h["a"])(A,v,E,!1,null,"2b1edf76",null)),k=T.exports,I=function(){var e=this,t=e._self._c;return t("footer",{staticClass:"footer"},[t("div",{staticClass:"footer__copyright footer__item"},[t("p",[e._v("© Copyright 2019-"+e._s(e.currentYear)+". Git Bible. @beatrizsmerino")])]),t("div",{staticClass:"footer__nav footer__item"},[t("nav",{staticClass:"nav"},[t("router-link",{staticClass:"nav__item",attrs:{to:"/bibliografy"}},[e._v(" Bibliografy ")])],1)])])},M=[],q={name:"PageFooter",data:function(){return{currentYear:(new Date).getFullYear()}}},C=q,G=(o("d6d7"),Object(h["a"])(C,I,M,!1,null,"89029204",null)),N=G.exports,S={components:{PageHeader:y,PageTitle:k,PageFooter:N},data:function(){return{isScrollUp:!0}},watch:{$route:{handler:function(e,t){var o=document.getElementsByTagName("html")[0],a=document.getElementsByTagName("body")[0];"undefined"!==typeof t&&o.classList.remove("page","page-".concat(t.name.toLowerCase())),o.classList.add("page","page-".concat(e.name.toLowerCase())),a.classList.add("page-body")},immediate:!0}},created:function(){this.addSticky(),window.addEventListener("scroll",this.handleScroll)},destroyed:function(){window.removeEventListener("scroll",this.handleScroll)},methods:{addSticky:function(){var e=document.getElementsByTagName("html")[0],t=document.getElementsByTagName("body")[0];e.classList.add("sticky"),t.classList.add("sticky__body")},handleScroll:function(){var e=95;window.scrollY>=e?this.isScrollUp=!1:this.isScrollUp=!0}}},R=S,O=(o("a0f9"),Object(h["a"])(R,i,r,!1,null,null,null)),x=O.exports,F=o("a18c"),j=o("be33"),L=o("11ca"),H=o("ad3d"),z=o("4eb5"),D=o.n(z),U=o("d3a4");j["c"].add(L["d"],L["b"],L["a"],L["e"],L["c"]),a["a"].component("FontAwesomeIcon",H["a"]),a["a"].component("FontAwesomeLayers",H["b"]),a["a"].component("FontAwesomeLayersText",H["c"]),a["a"].use(D.a),a["a"].config.productionTip=!1,new a["a"]({router:F["a"],el:"#app",i18n:U["a"],render:function(e){return e(x)}})},6326:function(e,t,o){},6330:function(e,t,o){"use strict";o("8bf6")},"6b9f":function(e){e.exports=JSON.parse('{"git":[{"parent":"git","url":"command-git","name":"get-git-version","title":"Git. Obtener la versión git","description":"<p>Antes de instalar git, es conveniente comprobar si ya lo tienes instalado mediante el siguiente comando, que te devolverá el número de versión instalado en tu ordenador. Si no es así, sigue los pasos descritos en este <a href=\'https://git-scm.com/book/es/v2/Inicio---Sobre-el-Control-de-Versiones-Instalaci%C3%B3n-de-Git\' target=\'_blank\'>enlace</a> en función de tu sistema operativo.</p>","code":"git --version"},{"parent":"git","url":"command-git","name":"create-git-repository","title":"Git. Inicializar el repositorio git","description":"<p>Un repositorio git es un almacén virtual, te permite guardar versiones del código de tu proyecto a las que puedes acceder siempre que lo necesites. El siguiente comando, utilizado sólo una vez durante la configuración inicial de un nuevo repositorio, creará un nuevo subdirectorio <code>.git</code> en tu directorio de trabajo actual y una nueva rama <code>master</code>.</p><p><a href=\'https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-init\' target=\'_blank\'>Saber más</a></p>","code":"git init"},{"parent":"git","url":"command-git","name":"show-configuration","title":"Git. Mostrar la configuración","description":"<p>Para visualizar nuestra configuración actual debemos saber que toda la configuración se guarda en el archivo <code>.gitconfig</code>, que se encuentra en: si eres <strong>Linux</strong> en el usuario <code>HOME</code> o si estás en <strong>Windows</strong> en <code>C:Users</code> o si eres <strong>Mac</strong> escribiendo en la <strong>consola</strong> <code>git config --list --show-origin</code>.</p>","code":[["git config -l"],["git config --list"],["git config --global --list"]]},{"parent":"git","url":"command-git","name":"config-user-name-email","title":"Git. Configurar el nombre y el correo electrónico del usuario","description":"<p>Git es un <strong>sistema de control de versiones distribuido</strong> que está siendo utilizado por la mayoría de los equipos de software hoy en día. Lo primero que debes hacer después de instalar Git en tu sistema es configurar tu nombre de usuario y dirección de correo electrónico de git. Git asocia tu identidad con cada commit que haces.</p><p>Git te permite establecer un nombre de usuario y una dirección de correo electrónico globales y por proyecto. Si modificas el nombre y el correo durante el desarrollo del repositorio, los cambios sólo afectan a futuros commits, el nombre y el correo electrónico asociados a los commits que hiciste antes del cambio no se ven afectados.</p><p>Puedes establecer o cambiar tu identidad git usando el siguiente comando.</p>","code":[["git config --global user.name <USER_NAME>"],["git config --global user.email <USER_EMAIL>"]]},{"parent":"git","url":"command-git","name":"config-code-editor","title":"Git. Añadir o editar el editor por defecto","description":"<p>Cuando creas un commit de Git con <code>git commit -a</code>, el editor por defecto que se abrirá es <strong>Vim</strong>. Esto puede ser muy confuso para la gente, ya que Vim no es un editor fácil si nunca has trabajado con él previamente.</p><p>Hay muchas formas de hacerlo: a través del terminal con el siguiente comando, abriendo y editando el archivo <code>.gitconfig</code>...</p><p>En <strong>OSX</strong> para establecer <strong>Visual Studio Code</strong> como editor global de Git, hay que hacer los siguientes pasos: <ul><li>Abrir el editor y pulsar a la vez las teclas <code>Shift + Command + P</code>.</li><li>Escribir la palabra <code>Code</code> en la ventana emergente y hacer clic en <code>Shell Command: Install \'code\' command in PATH</code> para hacer la instalación.</li><li>Y luego usa el segundo bloque de comandos de esta descripción, para ejecutar las 2 líneas en tu terminal. Esto lo define en su configuración como el editor global de Git y abre este mismo archivo de configuración con él.</li></ul></p><p><a href=\'https://stackoverflow.com/questions/34746045/set-visual-studio-code-to-be-global-git-editor-on-osx\' target=\'_blank\'>Saber más</a></p>","code":[["git config --global core.editor <PATH/TO/EDITOR_CODE>"],["git config --global core.editor \'code --wait\'","git config --global -e"]]},{"parent":"git","url":"command-git","name":"open-file-with-editor","title":"Git. Abrir un proyecto o archivo con el editor","description":"<p>A través del terminal puedes abrir un archivo con tu editor de código preferido. Estos comandos abren un archivo con los editores SublimeText, Atom y Visual Studio Code.</p>","code":[["subl <PATH/TO/FOLDER/FILE>"],["atom <PATH/TO/FOLDER/FILE>"],["code <PATH/TO/FOLDER/FILE>"]]},{"parent":"git","url":"command-git","name":"change-autor-email-last-commits","title":"Git. Cambiar el nombre y el correo electrónico del autor de la último commit","description":"<p>Si te has equivocado y has hecho tu commit con otro nombre o correo electrónico puedes sobrescribir la información del autor sólo del último commit con este comando.</p>","code":"git commit --amend --author=\'<USER_NAME> <USER_EMAIL>\'"},{"parent":"git","url":"command-git","name":"change-autor-email-commits","title":"Git. Cambiar el nombre y el correo electrónico del autor después de hacer un commit","description":"<p>Si te has equivocado y has hecho varios commits con otro nombre o email de usuario puedes sobrescribir la información de autor de todos los commits con el siguiente comando.</p><p>Ten mucho cuidado si estos commits han sido subidos previamente al repositorio remoto y si hay más gente colaborando en el repositorio. Si este es el caso, es importante comunicarlo antes de hacer este comando, ya que también tendrás que sobrescribir los cambios en el repositorio remoto con <code>git push -f</code> y los demás colaboradores tendrán que actualizar su repositorio local con <code>git pull -f</code>. Este tipo de cambios es mejor hacerlos sin tener ningún cambio guardado en el <strong>área de preparación</strong> o en el <strong>directorio de trabajo</strong>.</p><p><a href=\'https://stackoverflow.com/questions/750172/how-to-change-the-author-and-committer-name-and-e-mail-of-multiple-commits-in-gi\' target=\'_target\'>Saber más</p>","code":["#!/bin/sh","","git filter-branch --env-filter \'","WRONG_EMAIL=\\"<USER_EMAIL>\\"","CORRECT_NAME=\\"<USER_NAME>\\"","CORRECT_EMAIL=\\"<USER_EMAIL>\\"","if [\\"$GIT_COMMITTER_EMAIL\\" = \\"$WRONG_EMAIL\\"]","then","    export GIT_COMMITTER_NAME=\\"$CORRECT_NAME\\"","    export GIT_COMMITTER_EMAIL=\\"$CORRECT_EMAIL\\"","fi","if [\\"$GIT_AUTHOR_EMAIL\\" = \\"$WRONG_EMAIL\\"]","then","    export GIT_AUTHOR_NAME=\\"$CORRECT_NAME\\"","    export GIT_AUTHOR_EMAIL=\\"$CORRECT_EMAIL\\"","fi","\' --tag-name-filter cat -- --branches --tags"]},{"parent":"git","url":"command-git","name":"get-commits","title":"Git. Obtener todos los commits realizados","description":"<p>Después de haber realizado varios commits, o si ha clonado un repositorio que ya tenía un historial de commits, probablemente querrá mirar hacia atrás para ver qué modificaciones se han realizado.</p><p>Este comando muestra una lista de todos los commits realizados, en orden cronológico inverso, es decir, los más recientes se muestran al principio. Cada commit contiene información sobre el número de identificación (<em>Secure Hash Algorithm</em>, <code>SHA-1</code>), el nombre y la dirección de correo electrónico del autor, la fecha y el mensaje del commit.</p><p><a href=\'https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones\' target=\'_blank\'>Saber más</a></p>","code":"git log"},{"parent":"git","url":"command-git","name":"get-commits-oneline","title":"Git. Obtener todos los commits realizados en una sola línea","description":"<p>El comando <code>git log</code> tiene muchos parámetros opcionales para formatear la salida de la información del commit. La opción <code>--oneline</code> muestra la información de cada commit en una sola línea con los 6 primeros caracteres del número <code>SHA-1</code>, las ramas, las etiquetas y el mensaje.</p><p><a href=\'https://git-scm.com/book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones#rlog_options\' target=\'_blank\'>Saber más</a></p>","code":"git log --oneline"},{"parent":"git","url":"command-git","name":"get-commits-oneline-graph","title":"Git. Obtener todos los commits realizados en un gráfico","description":"<p>Este comando condensa la información de cada commit en una sola línea, mostrando sólo el ID del commit y la primera línea del mensaje del commit, resaltando todas las referencias (ramas, etiquetas...).</p><p>Dibuja una representación gráfica <em>ASCII</em> de la estructura del historial de commit. Imprime líneas adicionales entre los commits, para que el gráfico del historial se dibuje correctamente, y utiliza asteriscos para mostrar en qué rama estaba el commit.</p><p><a href=\'https://www.atlassian.com/git/tutorials/git-log\' target=\'_blank\'>Saber más</a></p>","code":"git log --oneline --graph --decorate"},{"parent":"git","url":"command-git","name":"get-commit-without-merges","title":"Git. Obtener todos los commits realizados, ocultando los commits de fusión","description":"<p>Un <code>merge</code> es el resultado de fusionar 2 o más ramas. En ocasiones, con esa fusión se genera un commit extra llamado <code>merge commit</code>. La información de este commit contiene una mezcla de todos los cambios realizados en ambas ramas, esto puede resultar confuso. Podemos mostrar la lista de commits sin ellos con este comando.</p>","code":"git log --oneline --no-merges"},{"parent":"git","url":"command-git","name":"get-commits-range","title":"Git. Obtener commits entre rangos","description":"<p>La forma más común de especificar un rango de commits es mediante la sintaxis de doble punto.</p><p>Esto por ejemplo, suele usarse para obtener un rango concreto de commits seleccionando la posición que ocupan en el histórico.</p><p>O por otro lado si seleccionamos 2 ramas mostrará todos los commits de la primera rama que no aparecen en la segunda. Esto es útil para previsualizar lo que se está a punto de fusionar o para ver lo que se está a punto de publicar en el repositorio remoto.</p><p><a href=\'https://git-scm.com/book/es/v2/Herramientas-de-Git-Revisi%C3%B3n-por-selecci%C3%B3n#r_commit_ranges\' target=\'_blank\'>Saber más</a></p>","code":[["git log master~<POSITION_NUMBER>..master~<POSITION_NUMBER>"],["git log master..develop"],["git log origin/master..HEAD"]]},{"parent":"git","url":"command-git","name":"get-commit-by-date","title":"Git. Buscar los commits por fecha","description":"<p>Con los siguientes comandos podemos obtener una lista de commits según la fecha indicada (AAAA-MM-DD): <ul><li><code>--since</code> Commits desde la fecha.</li><li><code>--before</code> Commits anteriores a la fecha.</li><li><code>--after</code> Commits posteriores a la fecha.</li></ul></p>","code":[["git log --since={<DATE>}"],["git log --before={<DATE>}"],["git log --after={<DATE>}"]]},{"parent":"git","url":"command-git","name":"show-commits-of-file","title":"Git. Mostrar sólo los commits en los que está involucrado un archivo","description":"<p>Muestra todos los commits en los que se ha modificado el archivo indicado.</p>","code":"git log --oneline -- <FILE_NAME>"},{"parent":"git","url":"command-git","name":"get-commits-regex","title":"Git. Buscar en archivos y commits de git usando una expresión regular","description":"<p>Por lo general, revisamos el historial del repositorio usando el comando <code>git log</code>, que nos muestra ver una lista de todos los commits. Pero a medida que nuestro proyecto se vaya haciendo más grande, se complicará la búsqueda entre los múltiples archivos y confirmaciones. Por ello, en algún momento, querremos <strong>filtrar esta lista para encontrar los cambios que incluyan ciertas palabras en los archivos o en el mensaje de confirmación</strong>.</p><p>Git tiene un comando llamado <code>grep</code> que le permite buscar dentro del repositorio, a través de cualquier árbol o directorio de trabajo, los archivos que coincidan con una cadena de texto.</p><p>Por ejemplo: <ul><li><code>git grep -n \'word\'</code> o <code>git grep --line-number \'word\'</code>, muestra el archivo, el número de línea y el texto de la línea donde se ha encontrado la coincidencia.</li><li><code>git grep -c \'word\'</code> o <code>git grep --count \'word\'</code>, resume el resultado mostrando solo los archivos donde se ha encontrado la coincidencia y cuantas coincidencias hay en cada archivo.</li></ul></p><p>También con el comando <code>--grep</code> podemos buscar dentro de un repositorio git, en cualquier rama, los commits cuyo mensaje coincida con la cadena de texto o expresión regular que le indiquemos.</p><p>Por ejemplo: <ul><li><code>git log -S \'word\'</code>, muestra los commits que contiene la palabra a buscar, tanto en los mensajes de los commits como en el contenido de los cambios.</li><li><code>git log --grep=\'word\'</code>, muestra los commits cuyo mensaje coincida con la expresión que le indiquemos.</ul> Una vez encontrado el commit, podríamos ejecutar el comando <code>git show &lt;COMMIT_ID&gt;</code>, usando el <code>HASH</code> (identificador del commit), para verlo en profundidad.</p><p><a href=\'https://static.platzi.com/media/user_upload/38.gitgrep-91e4368f-580b-4d90-8d2f-628d0b76089a.jpg\' target=\'_blank\'>Ver imagen</a> | <a href=\'https://runebook.dev/es/docs/git/git-grep\' target=\'_blank\'>Saber más</a></p>","code":[["git grep --line-number \'<REGEX>\'"],["git grep --count \'<REGEX>\'"],["git log -S \'<REGEX>\'"],["git log --oneline --grep=\'<REGEX>\'"]]},{"parent":"git","url":"command-git","name":"show-info-commit","title":"Git. Mostrar la información de un commit","description":"<p>Se trata de una herramienta de línea de comandos que se utiliza para ver detalles ampliados en objetos git como blobs, árboles, etiquetas y commits.</p><p>En el caso de un commit, muestra su información completa: id o <code>SHA-1</code>, autor, fecha y mensaje. </p><p>Hay muchas formas de acceder a la información de un commit:<br><ul><li>De forma absoluta, refiriéndose al código que lo identifica.</li><li>De forma relativa, refiriéndose al nombre de la rama del último commit.</li><li>A través de <code>HEAD</code>, accediendo al último commit que se ha realizado.</li><li>Por su posición en el árbol de git. Podemos ver todos los commits hacia atrás desde el momento que le digamos, con el signo <code>^</code> podemos ir 1 o 3 commits hacia atrás y con el signo <code>-</code> o <code>~</code> podemos especificar el número de commits hacia atrás que queremos ir hasta encontrar el que queremos ver.</li></ul></p>","code":[["git show <COMMIT_ID>"],["git show <BRANCH_NAME>"],["git show HEAD"],["git show HEAD^"],["git show HEAD^^^"],["git show HEAD~<POSITION_NUMBER>"],["git show -<POSITION_NUMBER>"]]},{"parent":"git","url":"command-git","name":"summary-branches","title":"Git. Mostrar ramas y sus commits","description":"<p>Nos muestra un resumen de todas las ramas que hay en un proyecto junto con sus últimas modificaciones o commits.</p><p><a href=\'https://git-scm.com/docs/git-show-branch\' target=\'_blank\'>Saber más</a></p>","code":[["git show-branch"],["git show-branch --list"],["git show-branch --more=-1"],["git show-branch --more=<NUMBER_COMMITS>"]]},{"parent":"git","url":"command-git","name":"show-date-commit","title":"Git. Mostrar fecha de commit","description":"<p>Un commit tiene 2 tipos de fechas: la fecha del autor y la fecha del commit.<ul><li>La <strong>fecha del autor</strong> indica cuándo se realizó originalmente esta confirmación, es decir, cuándo se realizó por primera vez el <code>git commit</code>.</li><li>La <strong>fecha de confirmación</strong> cambia cada vez que se modifica la confirmación, por ejemplo, cuando se sobreescribe el commit con <code>git commit --amend</code></li></ul></p><p>Con el siguiente comando podemos formatear la información de salida de un commit (2020-12-03 19:28:49 +0100).<ul><li><code>%ai</code>: <strong>fecha del autor</strong>, <em>ISO 8601-like</em> format</li><li><code>%ci</code>: <strong>fecha del commit</strong>, <em>ISO 8601-like</em> format</li></ul></p>","code":"git show -s --format=%ci <COMMIT_ID>"},{"parent":"git","url":"command-git","name":"overwrite-date-commit","title":"Git. Sobrescribir la fecha de commit","description":"<p>Este comando cambia la fecha de autor y committer del commit ya creado (2020-12-03 19:28:49 +0100).<br>¿Por qué cambiar dos fechas? El <strong>autor</strong> es la persona que escribió originalmente el trabajo, mientras que el <strong>committer</strong> es la persona que aplicó por última vez el trabajo. Si estamos trabajando solos en el proyecto, la fecha debe ser la misma en ambos casos.</p><p>Tenemos 2 formas de sobrescribir la fecha de un commit:</p><ul><li>Podemos modificar la fecha del <strong>último commit</strong> realizado con este primer comando.<br><a href=\'https://garysferrao.github.io/git/commit/date/2015/12/01/change-git-commit-date.html\' target=\'_blank\'>Saber más</a></li><li>O podemos modificar la fecha de un commit en particular filtrando la lista de commits <strong>por el id del commit</strong> a buscar. La fecha del primer commit realizado en un repositorio se puede modificar utilizando este segundo comando.<br><a href=\'https://stackoverflow.com/questions/454734/how-can-one-change-the-timestamp-of-an-old-commit-in-git\' target=\'_blank\'>Saber más</a></li></ul><p>La segunda vez que ejecutemos cualquiera de estos comandos no podremos crear una nueva copia de seguridad. Debemos borrar la copia de seguridad anterior que ya existe en la carpeta <code>.git/refs/original/</code> o forzar la sobreescritura de la copia de seguridad con <code>-f</code>.</p>","code":[["GIT_COMMITTER_DATE=\'<YYYY-MM-DDThh:mm:ss±hh:mm>\' git commit --amend --date=\'<YYYY-MM-DDThh:mm:ss±hh:mm>\' -C <COMMIT_ID>"],["git filter-branch --env-filter \\\\","\'if [ $GIT_COMMIT = <COMMIT_ID> ]","then","    export GIT_AUTHOR_DATE=\\"<YYYY-MM-DDThh:mm:ss±hh:mm>\\"","    export GIT_COMMITTER_DATE=\\"<YYYY-MM-DDThh:mm:ss±hh:mm>\\"","fi\'"]]},{"parent":"git","url":"command-git","name":"git-add","title":"Git. Añadir carpetas y archivos al área de preparación","description":"<p>Existen diferentes áreas en un repositorio git: el árbol de trabajo, el directorio de trabajo o espacio de trabajo, el área de preparación o índice, el stash, el repositorio local y el repositorio remoto. <ul><li>El <strong>espacio de trabajo</strong> contiene los archivos en los que estás trabajando actualmente, git notará los cambios (si no los has excluido previamente), pero no los guardará hasta que le digas explícitamente que los rastree.</li><li>El <strong>área de preparación</strong> contiene una instantánea del contenido que rastrea el árbol de trabajo. Esta instantánea representa el contenido del siguiente commit.</li></ul></p><p>Utilizamos el comando <code>git add</code> para añadir los cambios en el directorio de trabajo al área de preparación.<br>Puedes añadirlos todos a la vez (3 primeros comandos) o indicando las rutas de los archivos (último comando):</p>","code":[["git add --all"],["git add -A"],["git add ."],["git add <PATH/TO/FOLDER/FILE>"],["git add <PATH/TO/FOLDER/FILE_1> <PATH/TO/FOLDER/FILE_2>"]]},{"parent":"git","url":"command-git","name":"show-status-files","title":"Git. Mostrar el estado de los archivos en un directorio git","description":"<p>Ejecutando este comando podemos ver la rama en la que nos encontramos y los archivos que contiene el área de preparación junto con su estado (nuevo/modificado/borrado). También nos avisa de los archivos no rastreados por git (untracked) o de los archivos con conflictos.</p>","code":"git status"},{"parent":"git","url":"command-git","name":"remove-file-track","title":"Git. Borrar y rastrear el archivo","description":"<p>El comando <code>git rm</code> se utiliza para eliminar archivos individuales o un conjunto de archivos de un repositorio, el commando contrario sería <code>git add</code>.<br>La eliminación sólo afecta a las áreas del directorio de trabajo y al área de preparación, sólo actúa sobre la rama actual y sobre los archivos que no tengan cambios sin guardar. Este cambio no se almacena en el historial del repositorio hasta que se crea un nuevo commit.</p><p><strong>Por qué utilizar <code>git rm</code> en lugar de <code>rm</code></strong><br>Con el comando <code>rm</code>, un repositorio Git reconocerá cuando ha pasado por encima de un archivo que está siendo rastreado, actualizará el directorio de trabajo para reflejar la eliminación pero no el área de preparación. Es necesario ejecutar un comando adicional <code>git add</code> en las rutas de los archivos eliminados para añadir los cambios al área de preparación. El comando <code>git rm</code> actúa como un atajo ya que actualizará el directorio de trabajo y el índice de prueba con la eliminación.</p><p>Los siguientes comandos hacen:<ul><li><code>rm</code>: Elimina el archivo seleccionado y git no nota este cambio.</li><li><code>git rm </code>: Sólo funciona si el archivo ya estaba siendo rastreado, es decir, si se ejecutó un <code>git add</code> y un <code>git commit</code>. Elimina el archivo seleccionado, y añade los cambios al área de preparación.</li><li><code>git rm --cached</code>: Elimina el rastro del archivo seleccionado del control de versiones, sin borrar el archivo, esto se llama un <strong>fichero sin seguimiento</strong>.</li></ul></p><p><a href=\'https://www.atlassian.com/es/git/tutorials/undoing-changes/git-rm\' target=\'_blank\'>Saber más</a></p>","code":[["rm <PATH/TO/FOLDER/FILE>"],["git rm <PATH/TO/FOLDER/FILE>"],["git rm --cached <PATH/TO/FOLDER/FILE>"]]},{"parent":"git","url":"command-git","name":"rename-file-track","title":"Git. Renombrar y rastrear el archivo","description":"<p>Este comando funciona igual que el comando <code>git rm</code>.</p><p>Los siguientes comandos hacen:<ul><li><code>mv</code>: Modificar el nombre de un archivo sin que el git lo añada al área de preparación.</li><li><code>git mv</code>: Modificar el nombre de un archivo y que git rastree este cambio. Después de esto, si hacemos un <code>git status</code> aparecerá como renombrado.</li></ul></p>","code":[["mv <OLD_FILE_NAME> <NEW_FILE_NAME>"],["git mv <OLD_FILE_NAME> <NEW_FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"create-commit","title":"Git. Crear un commit con un mensaje","description":"<p>Los commits se crean para capturar el estado de uno o más archivos del proyecto en un momento determinado. Son un <strong>conjunto de cambios</strong>, instantáneas o hitos en la historia de un proyecto git. Cada commit contiene la fecha en que se hizo, los cambios de cada archivo, la información del autor, un mensaje que describe el contenido del commit y un identificador único (<code>SHA-1</code>) para referenciar este commit.</p><p>Este comando sólo incluye las modificaciones de los archivos rastreados (aquellos que han sido añadidos con <code>git add</code> en algún momento de su historia). La opción <code>-m</code> o <code>--message</code> sirve para indicar el mensaje del commit.</p>","code":"git commit -m \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"add-and-create-commit","title":"Git. Añadir carpetas y archivos al área de preparación y crear un commit","description":"<p>Si ya hemos hecho el primer <code>git add</code> y <code>git commit</code> de un archivo, es decir, git ya lo conoce, las próximas veces podemos usar otro comando que incluya ambos pasos en un solo comando. Esta combinación crea inmediatamente un commit de todos los cambios preparados y aplica un mensaje de commit en línea.</p><p>Es un comando de acceso directo para usuarios avanzados que combina las opciones <code>-a</code> o <code>--all</code> (añade los archivos modificados o borrados al escenario, pero no los recién creados, ya que no han sido reportados a git para su seguimiento) y <code>-m</code> o <code>--message</code> (con el mensaje especificado).</p><p><a href=\'https://www.atlassian.com/es/git/tutorials/saving-changes/git-commit\' target=\'_blank\'>Saber más</a></p>","code":"git commit -am \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"commit-particular-file-on-index","title":"Git. Confirmar un solo archivo en el área preparación","description":"<p>Si tiene varios archivos añadidos al <strong>staging area</strong> y se arrepiente, porque sólo quiere añadir un archivo en particular, puede seleccionar el archivo y hacer un commit sólo de sus cambios.</p>","code":["git <FILE_NAME>","git commit -am <COMMIT_MESSAGE>"]},{"parent":"git","url":"command-git","name":"overwrite-last-commit","title":"Git. Sobrescribir el último commit","description":"<p>Si un mensaje o archivo de commit contiene información poco clara, incorrecta, sensible o que falta, puedes corregirlo localmente y crear un commit con un nuevo mensaje. <br>Al ejecutar este comando se abrirá un editor de texto y te pedirá que edites el mensaje y guardes el commit. Este proceso cambiará el ID de el commit, creando una nueva commit que sustituye a la anterior.</p><p><a href=\'https://blog.kirei.io/buenas-pr%C3%A1cticas-para-los-mensajes-de-commit-en-git-a9fc43a83821\' target=\'_blank\'>Saber más</a></p>","code":[["git commit --amend"],["git commit --amend","git push -f"]]},{"parent":"git","url":"command-git","name":"remove-commit","title":"Git. Eliminar un commit","description":"<p>El comando <code>git reset</code> es una herramienta para deshacer cambios. Si lo ejecutamos sin indicar un SHA de commit, sólo eliminará los cambios añadidos al área de preparación.</p><p>Tiene 3 argumentos que se corresponden con los 3 mecanismos internos de gestión de estados de Git, el árbol de commit (HEAD), el área de preparación y el directorio de trabajo. </p><p>Cuando especificamos el tipo de reset que queremos con uno de estos argumentos, indicamos el commit SHA anterior a todos los que queremos borrar: <ul><li><code>--mixto</code>: Es la opción por defecto, provoca el mismo efecto que ejecutar<code>git reset</code>. Elimina los commits posteriores al commit seleccionado. Elimina los cambios del área de preparación, pero mantiene los del directorio de trabajo.</li><li><code>--soft</code>: Elimina los commits posteriores al commit seleccionado, pero mantiene los cambios añadidos al área de preparación y conserva los realizados en el directorio de trabajo.</li><li><code>--hard</code>: Es la opción más peligrosa porque se pierden todos los cambios realizados. Elimina los commits posteriores al commit seleccionado, lo que también elimina los cambios del área de preparación y del directorio de trabajo.</li></ul></p>","code":[["git reset --soft <COMMIT_ID>"],["git reset --mixed <COMMIT_ID>"],["git reset --hard <COMMIT_ID>"]]},{"parent":"git","url":"command-git","name":"squashing-commits","title":"Git. Aplastamiento o fusión de confirmaciones","description":"<p>El proceso de borrar un número de commits con el argumento <code>--soft</code> y luego hacer un commit se suele llamar hacer <strong>squashing</strong>, ya que es como compactar varios commits en uno.</p>","code":["git reset --soft master~<NUMBER_LAST_COMMITS>","git commit -m \'<COMMIT_MESSAGE>\'"]},{"parent":"git","url":"command-git","name":"revert-commit","title":"Git. Revertir los cambios de un commit y crear uno nuevo","description":"<p>Este commando nos permite crear un commit con los cambios revertidos de la referencia indicada, es decir, si tenemos un commit que añadía una línea y borraba dos, ahora estamos creando otro commit que borra la línea añadida y añade las dos borradas.<br>Tras ejecutar este comando en la consola, nos pedirá el mensaje y creará un nuevo commit.</p>","code":"git revert <COMMIT_ID>"},{"parent":"git","url":"command-git","name":"add-stash","title":"Git. Guardar los cambios en el \'stash\'","description":"<p>Git tiene un área llamada <strong>stash</strong> donde puedes almacenar temporalmente una instantánea de tus cambios sin confirmarlos en el repositorio. Está separada del directorio de trabajo, del área de preparación o del repositorio.<br> Esta funcionalidad es útil cuando has hecho cambios en una rama que no estás listo para confirmar, pero necesitas cambiar a otra rama. Esto guarda tus cambios, que estarán disponibles desde cualquier rama en ese repositorio y revierte el directorio de trabajo a como estaba para el último commit.<br>Note que los cambios que quiere almacenar necesitan estar en archivos rastreados. Si ha creado un nuevo archivo y trata de almacenar sus cambios, puede obtener el error <em>\'No hay cambios locales para guardar\'</em>.</p><p>Las instantáneas se guardan en el formato <code>stash@{0}: BRANCH: SHA MESSAGE</code>. Se guardarán con un identificador del tipo <code>stash@{0}</code>, donde <code>stash</code> indica que es una instantánea y el número entre las llaves, <code>{0}</code> es el índice de ese <code>stash</code>. El número del índice crece a medida que se crean nuevas instantáneas y se ordenan de forma inversa, es decir, el número más pequeño será siempre la última instantánea realizada. Se indica la rama en la que se hicieron los cambios, y el identificador y el mensaje serán los mismos que el último commit que tengamos en el repositorio.</p><p>Por defecto, envía todos los ficheros que tengamos en el directorio de trabajo y en el área de preparación, excepto los no rastreados, a la zona <code>stash</code>. Y genera el mensaje automáticamente. Pero hay varias opciones que podemos añadir al comando:<ul><li><code>--include-untracked</code> o <code>-u</code>: Añade también los archivos no rastreados.</li><li><code>--all</code> o <code>-a</code>: Añade también los archivos no rastreados e ignorados (.gitignore).</li><li><code>--patch</code>: Git no almacenará todo lo que se modifique, sino que nos preguntará de forma interactiva cuáles de los cambios queremos almacenar y cuáles queremos mantener en nuestro directorio de trabajo.</li><li><code>push -m</code>: Nos permite especificar un mensaje para el commit que estamos enviando al stash.</li><li><code>save</code>: Está obsoleto en favor de <code>push -m</code>.</li></ul></p><p><a href=\'https://www.freecodecamp.org/news/git-stash-explained/\' target=\'_blank\'>Saber más</a></p>","code":[["git stash"],["git stash -u"],["git stash -a"],["git stash --patch"],["git stash push -m \'<STASH_MESSAGE>\'"],["git stash save \'<STASH_MESSAGE>\'"]]},{"parent":"git","url":"command-git","name":"get-stash-list","title":"Git. Obtener una lista de los \'stash\' guardados","description":"<p>Cuando tienes muchas instantáneas guardadas, te conviene ver una lista de todas ellas para poder seleccionarlas. El mensaje y el id, que por defecto vienen del commit, te ayudarán a diferenciarlos.<br>Es recomendable limpiar el alijo o borrar aquellas instantáneas que no necesitemos para no acumularlas.</p>","code":"git stash list"},{"parent":"git","url":"command-git","name":"get-stash","title":"Git. Volver a aplicar los cambios guardados en el \'stash\'","description":"<p>Hay dos formas diferentes de recuperar los cambios guardados en el stash: <code>apply</code> y <code>pop</code>.</p><p>Por defecto, ejecutando cualquiera de estos 2 comandos podemos recuperar el último stash guardado, <code>stash@{0}</code>. La diferencia es que la opción <code>apply</code>, mantiene el cambio en la lista para una posible reutilización posterior, y <code>pop</code> tras aplicar el cambio lo elimina de la pila de stash, pero si durante este proceso hay conflictos, no lo elimina, dejando que se comporte exactamente como la opción <code>apply</code>.<br>Otra forma de hacer lo mismo que con la opción <code>pop</code> es hacerlo en 2 pasos: <code>git stash apply</code> && <code>git stash drop</code>.</p><p>También podemos obtener los cambios de un stash concreto de nuestra pila, indicando su número de índice.</p><p><a href=\'https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning#_git_clean\' target=\'_blank\'>Saber más</a></p>","code":[["git stash apply"],["git stash pop"],["git stash apply","git stash drop"],["git stash apply stash@{<STASH_NUMBER>}"],["git stash apply <STASH_NUMBER>"]]},{"parent":"git","url":"command-git","name":"create-stash-branch","title":"Git. Crear una rama a partir de un \'stash\'","description":"<p>Este es un buen atajo para recuperar el código almacenado en stash indicado y crear una nueva rama para trabajar en el por separado. Este comando crea una nueva rama con el último stash (<code>stash@{0}</code>), y luego lo borra (<code>git stash pop</code>). Si necesitas un stash en particular puedes especificar el id del stash.</p><p>Esto será útil cuando te encuentres con conflictos después de haber aplicado el stash a la última versión de tu rama.</p><p><a href=\'https://www.freecodecamp.org/news/useful-tricks-you-might-not-know-about-git-stash-e8a9490f0a1a/\' target=\'_blank\'>Saber más</a></p>","code":[["git stash branch <BRANCH_NAME>"],["git stash branch <BRANCH_NAME> stash@{<STASH_NUMBER>}"]]},{"parent":"git","url":"command-git","name":"show-stash","title":"Git. Mostrar las diferencias del \'stash\'","description":"<p>La opción <code>show</code> del comando <code>stash</code> ofrece un resumen muy breve de los cambios realizados en los archivos. Muestra en una línea la ruta y el nombre del fichero, y el número de líneas eliminadas.</p><p>Por defecto, muestra la información del último stash (<code>stash@{0}</code>), pero podemos indicar un número de índice para ver algún otro.</p><p>Si queremos profundizar y ver todos los cambios de cada línea del fichero en el editor del terminal podemos utilizar la opción <code>-p</code>.</p><p><a href=\'https://howto.lintel.in/how-to-see-stashed-changes-using-git-stash/\' target=\'_blank\'>Saber más</a></p>","code":[["git stash show"],["git stash show stash@{<STASH_NUMBER>}"],["git stash show -p"]]},{"parent":"git","url":"command-git","name":"remove-stash","title":"Git. Eliminar el \'stash\'","description":"<p>Hay dos formas diferentes de eliminar los cambios guardados en el área de stash: <code>drop</code> y <code>clear</code>.</p><p>Podemos eliminar el primer elemento guardado en el stash (el último stash: <code>stash@{0}</code>) con <code>drop</code> o si ya no necesitas un stash en particular, seleccionarlo por su número de índice.</p><p>Pero, si lo que queremos es limpiar el área de almacenamiento por completo, la opción <code>clear</code> borra toda la lista de stashes.</p><p><strong>ADVERTENCIA IMPORTANTE</strong>: Con la opción <code>clear</code> esos estados serán entonces objeto de poda, y puede ser imposible recuperarlos. Utilice ambas opciones con precaución, ya que puede ser difícil revertir los stashes una vez borrados.</p> <p>Para confirmar si todo se ha borrado, obtenga de nuevo la lista de stashes con el comando <code>git stash list</code>.</p><p><a href=\'https://kolosek.com/git-stash/\' target=\'_blank\'>Saber más</a></p>","code":[["git stash drop"],["git stash drop stash@{<STASH_NUMBER>}"],["git stash drop <STASH_NUMBER>"],["git stash clear"]]},{"parent":"git","url":"command-git","name":"recover-dropped-stash","title":"Git. Recuperar un commit eliminado del \'stash\'","description":"<p>Pongamos el caso de que has hecho limpieza en tu repositorio, acabas de borrar todos los commits antiguos almacenados en el stash y justo te das cuenta que en uno de esos commits tenias cambios importantes que no has guardado.</p><p><strong>No entres en pánico</strong>, es posible que puedas recuperar los cambios perdidos con el comando <code>git fsck</code>.</p><p>Para resolver este problema lo primero es localizar el hash ID (de 6 cifras) del commit eliminado. Una vez lo tengamos podemos ver en detalle la información que contiene y decidir si es el que estamos buscando. Si es así, todo lo que hay que hacer es volver a guardarlo.</p><p>Veamoslo en detalle: <ol><li><strong>Encontrar los commits del stash eliminados</strong><br>El siguiente comando te mostrará un gráfico con todos los commits que ya no son referenciados desde ninguna rama o etiqueta, es decir, cada commit perdido que hayas creado, incluyendo los del stash.</br><em>Shell bash/sh:</em><br><code>git log --graph --oneline --decorate $( git fsck --no-reflog | awk \'/dangling commit/ {print $3}’ )</code><br>En algún lugar de ese gráfico encontrarás el mensaje de confirmación que buscas.<br> Pista: Si no proporcionaste un mensaje cuando hiciste <code>git stash</code>, este commit comenzará con <code>WIP on</code>.</li><li><strong>Confirmar que son los cambios que buscamos</strong><br>Una vez tienes el hash del commit del stash puedes utilizar el comando <code>git show &lt;COMMIT_ID&gt;</code> para examinar en detalle el <code>diff</code> del commit, es decir, los nombres de las carpetas, archivos y líneas de código modificadas.</li><li><strong>Recuperar los cambios y guardarlos</strong><br>Después de confirmar que son los cambios que quieres recuperar, puedes traerlos al área de trabajo usando <code>git stash apply &lt;COMMIT_ID&gt;</code>.<br> Y si, por si a caso, además quieres volver a guardar esos cambios en la lista del stash ubicada en <code>.git/logs/refs/stash</code>, puedes usar el comando <code>git stash &lt;COMMIT_ID&gt;</code>.</li></ol></p><p><a href=\'https://foroayuda.es/recuperar-alijo-eliminado-en-git-usando-sourcetree/\' target=\'_blank\'>Saber más</a></p>","code":["git log --graph --oneline --decorate $( git fsck --no-reflog | awk \'/dangling commit/ {print $3}\' )","git show <COMMIT_ID>","git stash apply <COMMIT_ID>"]},{"parent":"git","url":"command-git","name":"exit-from-vim-without-save","title":"Git. Salir de la ventana de texto sin guardar","description":"<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres simplemente salir de la ventana de texto sin guardar los cambios, escribe el comando y pulsa <em>\'enter\'</em>.</p><p><a href=\'https://victorhckinthefreeworld.com/2017/06/14/como-salir-del-editor-vim/\' target=\'_blank\'>Saber más</a></p>","code":":q!"},{"parent":"git","url":"command-git","name":"exit-from-vim-and-save","title":"Git. Salir de la ventana de texto, después de guardar","description":"<p>Si estás dentro del editor <strong>Vi</strong> (editor de texto creado para UNIX, cuya versión mejorada se llama <strong>Vim</strong>) y quieres salir de la ventana de texto y guardar los cambios, escribe el comando y pulsa <em>\'enter\'</em>.</p><p><a href=\'https://victorhckinthefreeworld.com/2017/06/14/como-salir-del-editor-vim/\' target=\'_blank\'>Saber más</a></p>","code":":wq"},{"parent":"git","url":"command-git","name":"reflog","title":"Git. Ver registro de referencia (reflog)","description":"<p>Antes de hablar del diario de referencias, hay que recordar que <code>HEAD</code> es una referencia, es decir, un puntero que apunta al commit más reciente de la rama actual.</p><p>Existe un registro de todas las referencias tomadas por el puntero <code>HEAD</code> en Git llamado <strong>reflog</strong>. Es un listado que almacenará todos los commits por los que pase el puntero, por ejemplo, podrá guardar los cambios de una rama o la adición de un commit.</p><p>Este comando puede ser muy útil, en el caso de que queramos recuperar un commit borrado.<ul><li><code>git reflog</code>: Te va a mostrar todos los commits que realizaste sin importar si los borraste o no. Cada commit mostrara una pequeña información de si mismo: su número de hash (6 cifras), la rama a la que pertenece, el índice de la posición que ocupa su puntero <code>HEAD</code> y la primera línea del mensaje.</li><li><code>git show &lt;COMMIT_ID&gt;</code>: Viendo esta información podemos encontrar el commit que queremos y acceder a él mediante su número de hash. Así podemos ver en detalle su información: su número de hash completo, el autor y la fecha del commit, el mensaje del commit completo y que archivos y líneas se han añadido, eliminado o modificado.</li><li><code>git reset --mixed &lt;COMMIT_ID&gt;</code>: Usamos este comando, una vez estamos seguros de que queremos recuperar este commit y asi obtendremos de nuevo los archivos con los cambios que habiamos eliminado. Este comando no genera un commit con estos cambios, así que tendremos que ejecutar un <code>git commit</code> para volver a guardarlos. Podremos recuperar el mensaje que habiamos usado con el commando anterior <code>git show</code>, ya que nos mostraba el mensaje completo.</li></ul></p><p><a href=\'https://www.atlassian.com/es/git/tutorials/rewriting-history/git-reflog\' target=\'_blank\'>Saber más</a></p>","code":[["git reflog"],["git reflog --format=\'%C(auto)%h %<|(17)%gd %C(blue)%ci%C(reset) %s\'"],["git reflog","git show <COMMIT_ID>","git reset --mixed <COMMIT_ID>"]]},{"parent":"git","url":"command-git","name":"reflog-remove","title":"Git. Podar todas las referencias con la recogida de basura y recuperar espacio","description":"<p>El subcomando <code>expire</code> limpia las entradas de <strong>reflog</strong> viejas o inalcanzables. Tiene un potencial de pérdida de datos y no suele ser utilizado por los usuarios finales, pero sí por git internamente. Por defecto, la fecha de caducidad de <strong>reflog</strong> se establece en 90 días. Se puede especificar un tiempo de caducidad pasando un argumento de línea de comandos o estableciendo un nombre de configuración de git.</p>","code":["rm -rf .git/refs/original/","git reflog expire --expire=now --all","git gc --aggressive --prune=now"]},{"parent":"git","url":"command-git","name":"get-branches","title":"Git. Obtener todas las ramas","description":"<p>A veces es necesario saber qué ramas existen en un repositorio remoto para determinar los nombres de las ramas disponibles.</p><p>Con este comando puedes listar ambos tipos de ramas: remotas y locales. La rama actual aparecerá resaltada en color y marcada con un asterisco <code>*</code>.</p>","code":[["git branch --all"],["git branch -a"]]},{"parent":"git","url":"command-git","name":"get-branches-local","title":"Git. Obtener todas las ramas locales","description":"<p>Una rama local es aquella cuyo nombre completo empieza por <code>refs/heads/</code>, el comando <code>git branch</code> quita esta parte para hacerlo más fácil.</p><p>Parece que con git siempre hay más de una forma de hacer la misma cosa:</p>","code":[["git branch"],["git branch --list"],["git branch -l"]]},{"parent":"git","url":"command-git","name":"get-branches-remotes","title":"Git. Obtener todas las ramas remotas","description":"<p>Una rama de seguimiento remoto es aquella cuyo nombre completo empieza por <code>refs/remotes/</code>, este comando elimina esta parte para facilitarlo.</p>","code":[["git branch --remotes"],["git branch -r"]]},{"parent":"git","url":"command-git","name":"create-branch","title":"Git. Crear una nueva rama","description":"<p>Puedes crear una nueva rama mientras estás en otra y moverte a ella más tarde.</p>","code":"git branch <NEW_BRANCH_NAME>"},{"parent":"git","url":"command-git","name":"checkout-branch-path","title":"Git. Checkout branch/path","description":"<p>El comando <code>git checkout &lt;NAME&gt;</code> está realmente pensado para ramas, pero la sintaxis de Git es relajada, y si Git no puede encontrar una rama, entonces buscará un archivo.</p><p>Supongamos que tienes un archivo y una rama que se llaman igual, <code>stuff</code>. Entonces el siguiente comando parecería ambiguo, <code>git checkout stuff</code>, porque no está claro si estás pidiendo la salida de un archivo o de una rama.<br> Con <code>--</code> es una forma de decirle a Git que trate lo que sigue a <code>checkout</code> como un archivo y no como una rama, cuando lo usas, le dice explícitamente a Git que saque un archivo con ese nombre/ruta</p><p>Este comando hizo: <ul><li>Si es una rama local o rama remota rastreada, cambia a ella.</li><li>Si es una ruta rastreada de un archivo, lo restablece, es decir, borra los cambios no guardados del directorio de trabajo.</li><li>Si es una rama remota, crea una rama de seguimiento y cambia a ella.</li></ul><p>Así que en este caso los siguientes comandos permiten mover una rama local o descargarla de la remota y restablecer un archivo:</p>","code":[["git checkout <BRANCH_NAME>"],["git checkout -- <FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"move-to-branch","title":"Git. Desplazarse a la rama","description":"<p>Cuando intentas moverte a una rama local que no existe, este comando buscará si hay una rama de seguimiento remoto con un nombre similar. Si es así, creará la rama local y la configurará para seguir la rama de seguimiento remoto.</p>","code":"git checkout <BRANCH_NAME>"},{"parent":"git","url":"command-git","name":"create-and-move-to-branch","title":"Git. Crear y moverse a una rama","description":"<p>Debes utilizar una rama distinta para cada función o problema en el que trabajes. Con este comando se hacen 2 pasos a la vez, crear y moverse a la rama para que todos los cambios que hagas se apliquen a ella.<br>La opción <code>-b</code> le dice a git que la cree si no existe ya, de lo contrario, se restablece, es decir, la rama no se restablece/crea a menos que <code>git checkout</code> tenga éxito.</p>","code":[["git checkout -B <NEW_BRANCH_NAME>"],["git checkout -b <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"extract-files-from-staging-area","title":"Git. Extraer los archivos del área de preparación","description":"<p>Si ya he añadido el archivo con un <code>git add</code> al <strong>staging area</strong> pero no quiero hacer commit todavía, y quiero eliminarlo de esta zona, estas son algunas formas de solucionarlo:<ul><li><code>git reset &lt;FILE_NAME&gt;</code>: Si los cambios se han realizado y añadido al <strong>staging area</strong>.</li><li><code>git rm --cached &lt;FILE_NAME&gt;</code>: Si aún no he lanzado un commit, y por tanto no se ha creado el puntero <code>HEAD</code>.</li><li><code>git reset HEAD &lt;FILE_NAME&gt;</code>: Si ya he lanzado mi primer commit, es decir, hay un puntero HEAD. Git se mueve entre los commits apuntando siempre al último creado.</li></ul></p>","code":[["git reset <FILE_NAME>"],["git rm --cached <FILE_NAME>"],["git reset HEAD <FILE_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-current-branch","title":"Git. Renombrar la rama actual","description":"<p>Es posible que en algún momento, como ocurre con los mensajes de commit, quieras renombrar una rama.<br>Con este comando puedes renombrar la rama local en la que estás trabajando.</p><p>Tiene parámetros opcionales: <ul><li><code>--mover</code> o <code>-m</code>: Mover/renombrar una rama y el correspondiente <strong>reflog</strong>.</li><li><code>-M</code>: Es un atajo de <code>--delete --force</code></li></ul></p><p><a href=\'https://git-scm.com/docs/git-branch\' target=\'_blank\'>Saber más</a></p>","code":[["git branch -m <NEW_BRANCH_NAME>"],["git branch -M <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-local-branch","title":"Git. Rename a local branch","description":"<p>Puedes renombrar una rama local mientras te encuentras en cualquier otra rama.</p>","code":[["git branch -m <OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"rename-remote-branch","title":"Git. Renombrar una rama remota","description":"<p>Supongamos que estás colaborando en un proyecto con un grupo de personas, y habeis definido una convención de nombres para las ramas de git. Tu has creado una nueva rama, has enviado los cambios al repositorio remoto y te has dado cuenta de que el nombre de tu rama era incorrecto. Por suerte, git te permite renombrar la rama local y la remota muy fácilmente usando varios comandos o haciendo lo mismo con uno solo.</p><p><a href=\'https://linuxize.com/post/how-to-rename-local-and-remote-git-branch/\' target=\'_blank\'>Saber más</a></p>","code":[["git checkout <OLD_BRANCH_NAME>","git branch -m <NEW_BRANCH_NAME>","git push origin -u <NEW_BRANCH_NAME>","git push origin --delete <OLD_BRANCH_NAME>"],["git push origin :<OLD_BRANCH_NAME> <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"upload-local-branch","title":"Git. Publicar una rama local a un repositorio remoto","description":"<p>Se recomienda enviar la nueva rama al repositorio remoto (<code>ORIGIN</code>), ya que esto actúa como copia de seguridad, y al colaborar con otros desarrolladores, les permite acceder a ver los commits realizados en la nueva rama.<br> La opción <code>-u</code> o <code>--set-upstream-to</code> la añade como rama de seguimiento remoto.</p>","code":[["git branch --set-upstream-to origin/<OTHER_BRANCH_NAME>"],["git push origin -u <NEW_BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"remove-branch","title":"Git. Eliminar una rama","description":"<p>Para eliminar una rama del repositorio git no debes estar posicionado en ella.</p>","code":[["git branch -D <BRANCH_NAME>"],["git branch -d <BRANCH_NAME>"]]},{"parent":"git","url":"command-git","name":"merge-branch","title":"Git. Fusionar una rama","description":"<p>La fusión es la forma que tiene Git de volver a unir un historial bifurcado. El comando <code>git merge</code> permite tomar las líneas de desarrollo independientes creadas por el comando <code>git branch</code> e integrarlas en una única rama.<br>Toma dos punteros de commit de los extremos de cada rama y los combina en la rama actual, generando un nuevo <strong>commit de fusión</strong>. Sin embargo, si git encuentra datos que han sido cambiados en ambos historiales, no podrá combinarlos automáticamente. En ese caso, se crea un conflicto de control de versiones y Git pedirá la intervención del usuario para continuar.</p><p>Antes de realizar una fusión hay un par de pasos de preparación para asegurar que la fusión se realice sin problemas: <ul><li><strong>Confirmar la rama receptora:</strong> Asegúrate de que <code>HEAD</code> apunta a la rama correcta con el comando <code>git status</code>. Si es necesario, ejecute <code>git checkout</code> para cambiar a la rama receptora.</li><li><strong>Obtener los últimos commits remotos: </strong> Asegúrate de que la rama receptora y la rama de fusión están actualizadas con los últimos cambios remotos. Ejecute <code>git fetch</code> para obtener los últimos commits remotos. Una vez que el fetch se ha completado asegúrese de que la rama maestra tiene las últimas actualizaciones ejecutando <code>git pull</code>.</li></ul></p><p>Esto significa que <code>git merge</code> se utiliza a menudo junto con <code>git checkout</code> para seleccionar la rama actual y <code>git branch -d</code> para eliminar la rama de destino obsoleta. </p> <p>Si las dos ramas que estás intentando fusionar han cambiado la misma parte del mismo archivo, Git no será capaz de averiguar qué versión usar. Cuando se produce esta situación, se detiene justo antes de crear el <strong>commit de fusión</strong> para que puedas resolver los conflictos manualmente. Cuando Git encuentra un conflicto durante una fusión, editará el contenido de los archivos afectados con indicadores visuales que marcan ambos lados del contenido en conflicto <code><<<<<<<</code> <code> =======</code> <code>>>>>>>></code>. El contenido anterior al marcador <code>=======</code> es la rama receptora y la parte posterior es la rama de fusión. Una vez que hayas identificado las secciones conflictivas, puedes entrar y arreglar la fusión a tu gusto. Cuando estés listo para terminar la fusión, todo lo que tienes que hacer es ejecutar <código>git add</código> en los archivos en conflicto para decirle a Git que están resueltos. Luego, ejecuta <code>git commit</code> para generar el <strong>commit de fusión</strong>.</p><p><a href=\'https://www.atlassian.com/es/git/tutorials/using-branches/git-merge\' target=\'_blank\'>Saber más</a></p>","code":[["git merge <BRANCH_NAME>"],["git merge --continue"],["git merge --abort"]]},{"parent":"git","url":"command-git","name":"merge-fast-forward","title":"Git. Fusionar una rama y crear un commit","description":"<p>La opción <code>--no-ff</code> evita que <code>git merge</code> ejecute un <strong>\'fast-forward\'</strong> si detecta que tu <code>HEAD</code> actual es un ancestro del commit que estás intentando fusionar. Un <strong>fast-forward</strong> (adelantar rápidamente) es cuando, en lugar de construir un <strong>commit merge</strong> (confirmación de fusión), git simplemente mueve tu puntero de rama para apuntar a la confirmación entrante.</p><p>En ocasiones quieres evitar que este comportamiento ocurra, normalmente porque quieres mantener una topología de rama específica (por ejemplo, estás fusionando en una rama temática y quieres asegurarte de que se vea así al leer el historial). Para ello, puedes pasar esta opción <code>--no-ff</code> y <code>git merge</code> siempre construirá una fusión en lugar de <strong>fast-forwarding</strong>.</p>","code":["git merge <BRANCH_NAME> --no-ff"]},{"parent":"git","url":"command-git","name":"rebase","title":"Git. Rebasar una rama","description":"<p>En Git tenemos dos formas de integrar los cambios de una rama a otra: la fusión (<code>merge</code>) y la reorganización (<code>rebase</code>).</p> <p>Git <code>rebase</code> nos permite modificar el historial de Git utilizando un punto de referencia. Captura todos los cambios confirmados de la rama en la que estamos y los aplica a la que le estamos indicando, es decir, es capaz de reconocer que commits no están en la línea de tiempo de ese punto de referencia y aplicarlos sobre el punto de referencia, es lo que llamamos en Git <strong>rebasing</strong>. <br>En contraste con el merge, esto genera una historia del proyecto perfectamente lineal, pudiendo ir desde el final de la rama hasta el inicio del proyecto sin encontrar ninguna bifurcación.</p><p>Es muy importante entender que, aunque la rama parezca la misma, está formada por commits totalmente nuevos, lo que cambia la historia de Git. Esto implica que estos commits se están recreando con el mismo mensaje y contenido, lo que puede dar lugar a <strong>conflictos</strong> a la hora de aplicarlos a la nueva rama si ésta tiene nuevos cambios.<br>Si esto ocurre, hay que resolverlos a medida que se producen y se consideran modificaciones del propio commit. Esto nos permite borrar, reordenar, fusionar o cambiar el mensaje del commit antes de aplicarlos. Cuando tengas los cambios arreglados, tendrás que pedirle al comando que continúe con la opción <code>--continue</code> para aplicar el siguiente commit.<br>En cualquier momento durante <code>rebase</code> si cambias de opinión puedes rechazar todo el proceso con la opción <code>--abort</code>.</p>","code":[["git rebase <BRANCH_NAME>"],["git rebase --continue"],["git rebase --abort"]]},{"parent":"git","url":"command-git","name":"cherry-pick","title":"Git. Cherry-pick: Copiar y pegar commits","description":"<p>Puede ocurrir que, en algún momento, queramos aplicar algunos de los cambios que hemos hecho en otra rama sin tener que hacer un merge completo. El comando <code>cherry-pick</code> permite <em>\'copiar\'</em> uno o varios commits de una rama y <em>\'pegarlos\'</em> en otra rama. Antes de utilizarlo, debe tener un <strong>directorio de trabajo</strong> y <strong>zona de preparación</strong> limpios. </p><p>Por defecto, <code>cherry-pick</code> mantiene el mensaje de commit original, por lo que la opción <code>-x</code> puede ser útil para añadir una referencia a el commit original y así para saber de dónde se ha obtenido el commit. Otras opciones interesantes son <code>-e</code>, que permite editar el mensaje de commit en lugar de utilizar el original y la opción <code>-n</code> que aplicará los cambios pero no hará ningun commit. </p><p>Al igual que con los comandos <code>merge</code> y <code>rebase</code>, tras resolver los conflictos, podemos indicar que se sigan aplicando los cambios con la opción <code>--continue</code> o rechazar el proceso completamente con la opción <code>--abort</code>.</p><p><a href=\'https://www.runroom.com/realworld/seleccionando-commits-cherry-pick\' target=\'_blank\'>Saber más</a></p>","code":[["git cherry-pick"],["git cherry-pick <COMMIT_ID>"],["git cherry-pick -x"],["git cherry-pick -e"],["git cherry-pick -n"],["git cherry-pick --continue"],["git cherry-pick --abort"]]},{"parent":"git","url":"command-git","name":"diff","title":"Git. Comparar cambios con git diff","description":"<p>Podemos ver qué cambios se han hecho en el código con el comando <code>diff</code>. Este, muestra en la terminal las líneas de código que se han eliminado con el símbolo <code>-</code> y en color rojo, y las líneas añadidas con el símbolo <code>+</code> y de color verde.</p><p>La siguiente herramienta online puede ayudarte. <strong>DiffMerge</strong> es una aplicación para comparar y fusionar visualmente archivos en Windows, OSX y Linux: <a href=\'http://sourcegear.com/diffmerge/\' target=\'_blank\'>http://sourcegear.com/diffmerge/</a></p><p>También podemos comparar los cambios que se han realizado en el código de varios commits.</p><p><a href=\'https://www.atlassian.com/git/tutorials/saving-changes/git-diff\' target=\'_blank\'>Saber más</a></p>","code":[["git diff"],["git diff <COMMIT_ID_1> <COMMIT_ID_2>"]]},{"parent":"git","url":"command-git","name":"mark-conflicts-resolved","title":"Git. Marcar el conflicto como resuelto","description":"<p>Pasos a seguir tras resolver un conflicto en los archivos: <ul><li>Añadir todos los archivos a la zona de preparación</li><li>Ver el estado de los archivos (modificados/borrados/añadidos)</li><li>Crear un commit con esos cambios indicando una descripción de lo que se ha realizado</li></ul></p>","code":["git add .","git status","git commit -m \'<COMMIT_MESSAGE>\'"]},{"parent":"git","url":"command-git","name":"get-tags","title":"Git. Obtener todas las etiquetas realizadas","description":"<p>Obtenga una lista simple de las etiquetas, si quiere asegurarse de que existen y cuáles son sus números de versión.</p>","code":[["git tag --list"],["git tag -l"]]},{"parent":"git","url":"command-git","name":"create-tag","title":"Git. Crear una nueva etiqueta","description":"<p>En el desarrollo de software, las etiquetas git representan una versión de nuestro código en un momento dado. A diferencia de las ramas, las etiquetas no son mutables y siempre apuntan al mismo commit, por lo que la gente generalmente las utiliza para marcar puntos importantes en la historia de git (como los puntos de liberación v1.0, v2.0 y así sucesivamente).</p><p>El <a href=\'https://semver.org/lang/es/\' target=\'_blank\'>versionado semántico</a> utiliza un formato de versión basado en números 3 enteros separados por puntos: <code>X.Y.Z</code> (<em>Major.Minor.Patch</em>), los arreglos de bugs que no cambian el API incrementan el patch, los cambios y adiciones que no rompen la compatibilidad de las dependencias anteriores incrementan el minor, y los cambios que rompen la compatibilidad incrementan el major. Esto se traduciría a la estructura de ramas de <code>gitflow</code> como <em>lanzamiento.feature.bug</em>.<br>El desarrollador es el responsable de comunicar el estado de su software publicando este número.</p><p><a href=\'https://semver.org/\' target=\'_blank\'>Saber más</a></p>","code":"git tag -a \'<TAG_VERSION>\' -m \'<COMMIT_MESSAGE>\'"},{"parent":"git","url":"command-git","name":"remove-local-tag","title":"Git. Eliminar una etiqueta local","description":"Eliminar la etiqueta local existente con los nombres dados","code":[["git tag -d <TAG_VERSION>"],["git tag --delete <TAG_VERSION>"]]},{"parent":"git","url":"command-git","name":"remove-tag-remote","title":"Git. Eliminar una etiqueta remota","description":"Eliminar la etiqueta remota existente con los nombres dados.","code":"git push --delete origin <TAG_VERSION>"},{"parent":"git","url":"command-git","name":"remove-and-upload-tag","title":"Git. Eliminar una etiqueta local y remota","description":"<p>Cuando quieras renombrar o eliminar una etiqueta y ya la hayas empujado a un repositorio remoto (por ejemplo, GitHub) entonces también tendrás que actualizar las referencias remotas justo después de renombrar o eliminar la etiqueta de tu repo local.</p><p>Aquí hay dos alternativas para eliminar una etiqueta en el repositorio local y en el remoto:<ul><li>Eliminar la etiqueta local y sobrescribir este cambio haciendo referencia al nombre de la etiqueta eliminada en el repositorio remoto.</li><li>O hacer el proceso a la inversa, eliminar primero la etiqueta en el repositorio remoto y luego en el repositorio local.</li></ul></p><p><a href=\'https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/\' target=\'_blank\'>Saber más</a></p>","code":[["git tag -d <TAG_VERSION>","git push origin :refs/tags/<TAG_VERSION>"],["git push --delete origin <TAG_VERSION>","git tag -d <TAG_VERSION>"]]},{"parent":"git","url":"command-git","name":"rename-local-tag","title":"Git. Renombrar una etiqueta local","description":"<p>Si utilizas etiquetas en tus proyectos, probablemente te hayas encontrado con algún problema que te haya obligado a eliminar la etiqueta: <ul><li>Hubo un cambio que debía enviarse con esta versión y te olvidaste de él.</li><li>Hay algún código de depuración que no debía incluirse con esta versión.</li><li>Hay un error tipográfico realmente obvio que todo el mundo notará de inmediato.</li></ul></p><p>Si aún no has subido la etiqueta al repositorio remoto, puedes renombrar la etiqueta con el siguiente comando:</p><p><a href=\'https://cabrerahector.com/development/how-to-remove-a-git-tag-locally-and-remotely/\' target=\'_blank\'>Saber más</a></p>","code":"git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>"},{"parent":"git","url":"command-git","name":"rename-and-upload-tag","title":"Git. Renombrar una etiqueta y publicarla","description":"<p>Si te has equivocado y necesitas renombrar una etiqueta y actualizarla en el repositorio remoto, debes seguir estos pasos:<ol></li><li>Renombrar la etiqueta local.</li><li>Eliminar la etiqueta antigua para que git conozca el cambio.</li><li>Indicar al repositorio git remoto que has eliminado la etiqueta antigua.</li><li>Actualizar las etiquetas del repositorio remoto para subir la nueva etiqueta.</li></ol></p>","code":["git tag <NEW_TAG_VERSION> <OLD_TAG_VERSION>","git tag -d <OLD_TAG_VERSION>","git push origin :refs/tags/<OLD_TAG_VERSION>","git push --tags"]},{"parent":"git","url":"command-git","name":"update-remote-repository","title":"Git. Actualizar el repositorio remoto","description":"<p>Esto es muy deseable cuando se trabaja en un flujo de trabajo en equipo en el que las ramas remotas se eliminan después de la fusión con <code>master</code> o se quedan con etiquetas obsoletas.</p><p>En este caso, querrá eliminar las referencias a las ramas o etiquetas que ya no existen en el control remoto conectándose al control remoto y obteniendo el último estado antes de la poda.<br> Es esencialmente una combinación de comandos:</p>","code":"git fetch --all && git remote prune"},{"parent":"git","url":"command-git","name":"update-local-tags","title":"Git. Actualizar etiquetas remotas","description":"<p>Si tu proyecto es de código abierto, probablemente tendrás que actualizar el estado de tu repositorio local de vez en cuando, ya que otras personas pueden haber eliminado o renombrado algunas etiquetas mientras estabas trabajando y ahora puedes tener etiquetas locales obsoletas.</p><p>Este comando poda las etiquetas que ya no existen en el repositorio remoto pero sí en tu repositorio local.</p>","code":"git pull --prune --tags"}],"gitFlow":[{"parent":"gitFlow","url":"command-git-flow","name":"create-gitflow-repository","title":"Git Flow. Inicializar el repositorio","description":"<p>Git-flow es un <strong>flujo de trabajo</strong> aplicado a un repositorio Git.<br> Todo proyecto suele tener al menos 2 ramas infinitas: <code>develop</code> que contiene el código en desarrollo y <code>master</code> que contiene cada una de las versiones estables para incluir en producción.<br> Este modelo de ramificación, diseñado en torno a los lanzamientos del proyecto, tiene además un conjunto de ramas de apoyo, que están limitadas en el tiempo y son eliminadas eventualmente. Estas ramas permiten el trabajo en equipo, para la creación de nuevas funcionalidades (<code>feature</code>), resolución de errores en desarrollo (<code>bugfix</code>), resolución de errores urgentes en producción (<code>hotfix</code>) y la publicación de diferentes versiones (<code>release</code>).</p><p>Empieza a usarlo inicializándolo dentro de un repositorio git existente con <code>git flow init</code>. Al comienzo, Git-flow necesita ser inicializado para personalizar la configuración del proyecto, tendrás que responder a algunas preguntas sobre las convenciones de nomenclatura de tus ramas, en este momento puedes cambiar el nombre de las ramas si lo deseas, aunque se recomienda utilizar los valores por defecto (<code>feature</code>, <code>release</code>, <code>hotfix</code> y <code>support</code>).</p>","code":[["git flow init"],["git flow init","","Initialized empty Git repository in ~/project/.git/","No branches exist yet. Base branches must be created now.","Branch name for production releases: [master]","Branch name for \\"next release\\" development: [develop]","","How to name your supporting branch prefixes?","Feature branches? [feature/]","Release branches? [release/]","Hotfix branches? [hotfix/]","Support branches? [support/]","","git branch","* develop","master"]]},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-start","title":"Git Flow. Iniciar una nueva \'feature\'","description":"<p>Cuando se va desarrollar una nueva funcionalidad o característica del proyecto se crea una nueva rama llamada <code>feature</code>. Este tipo de ramas nacen a partir de la rama <code>develop</code> y una vez terminado su desarrollo, se incorporan nuevamente a ella.</p><p>El siguiente commando es un atajo, que engloba la ejecución de varios commandos: <ul><li><code>git checkout develop</code></li><li><code>git branch feature/&lt;BRANCH_NAME&gt;</code></li> <li><code>git checkout feature/&lt;BRANCH_NAME&gt;</code></li></ul></p>","code":[["git flow feature start <FEATURE_NAME>"],["git checkout -b feature/<FEATURE_NAME> develop"]]},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-list","title":"Git Flow. Obtener la lista de \'features\'","description":"<p>Puedes ver una lista de las ramas <code>feature</code> ya creadas en el repositorio local usando el siguiente commando.</p>","code":"git flow feature list"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-publish","title":"Git Flow. Publicar una \'feature\'","description":"<p>Normalmente las <code>feature</code> existen solamente en los repositorios locales de los desarrolladores y no en el repositorio origen. Si quieres compartir esta rama con algunos miembros de tu equipo para poder hacer un desarrollo colaborativo, tendrías que publicar la <code>feature</code> en el servidor remoto para que pueda ser utilizada por otros usuarios.</p>","code":"git flow feature publish <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-pull","title":"Git Flow. Conseguir una \'feature\' publicada","description":"<p>Cuando más de una persona trabaje a la vez en una <code>feature</code>, esta será publicada por tus compañeros de equipo, y podrás ser capaz de desarrollar en la misma rama con ellos.</p><p>Si es la primera vez que participas en el proyecto, primero tendrás que clonar repositorio usando <code>git clone &lt;URL&gt;</code> para tener una copia en tu ordenador (repositorio local), después inicializar Gitflow con <code>git flow init</code> y descargar las ramas <code>master</code> y <code>develop</code> con los comandos <code>git checkout master</code> y <code>git checkout develop</code>.</p><p>Si ya estás participando en el proyecto puedes saltarte los pasos anteriores y usar el siguiente comando para descargar una <code>feature</code> y para asegurar que el repositorio local está sincronizado con el remoto.</p>","code":"git flow feature pull origin <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-track","title":"Git Flow. Seguir una \'feature\' publicada","description":"<p>Digamos que has creado una nueva función con <code>git flow feature start &lt;FEATURE_NAME&gt;</code>, y la has publicado al repositorio remoto con <code>git flow feature publish &lt;FEATURE_NAME&gt;</code> para que otros miembros de tu equipo puedan colaborar contigo usando <code>git flow feature pull &lt;FEATURE_NAME&gt;</code> para descargarsela. Esto crea una nueva rama en su repositorio local, basada en la rama del remoto, sin embargo esto no la configura para que los cambios que se realizen en esta, sean rastreados por la rama remota, por lo que ahora tiene que ser rastreada manualmente.</p><p>Con el siguiente comando <code>git flow feature track &lt;FEATURE_NAME&gt;</code>, tu compañero de trabajo, puede descargar la <code>feature</code> y además seguir los cambios que otros realizen en la publicada en el repositorio de origen.</p><p>Para ilustrar el aspecto colaborativo con una rama de una nueva función, utilizando el aspecto de solicitud de extracción de GitHub que facilita la parte de revisión y discursión del código, nos ponemos en la siguiente situación:<ul><li>Varias personas trabajan en la misma función y a medida que se confirman los cambios, se envían a GitHub (o una vez al final de su desarrollo si se prefiere).</li><li>Cuando se completa la función, se abre una solicitud de extracción en GitHub comparando <code>develop</code> y con la rama.</li><li>El equipo revisa la solicitud de extracción y realiza comentarios.</li><li>Cualquier cambio de la solicitud de extracción se realiza en la rama de funciones.</li><li>Una vez que se incorporan todos los cambios en la rama de funciones se da por terminada: <code>git flow feature finish &lt;FEATURE_NAME&gt;</code>.</li><li>La rama <code>develop</code> se envía a GitHub (GitHub marcará automáticamente la solicitud de extracción como cerrada/fusionada cuando esto suceda).</li></ul><p>Sin embargo, eso deja el problema de cerrar esa sucursal, quien ejecute primero <code>git flow feature finish &lt;FEATURE_NAME&gt;</code> tendrá el lujo de eliminar su rama local, pero cualquier otra persona que haya verificado la rama tendrá que hacerlo manualmente si así lo desea. Puedes usar <code>git fetch --prune</code> o un simple <code>git fetch</code> para eliminar tu rama si ya ha sido  eliminada en el remoto.</p><p>Si ya has descargado la rama y ahora necesitas realizar un seguimiento de esta, todo lo que tienes que hacer sería que tu rama existente rastree a la anterior con <code>git branch -u origin feature/&lt;FEATURE_NAME&gt;</code> o <code>git branch --set-upstream-to origin feature/&lt;FEATURE_NAME&gt;</code></p><p>En general, lo mejor sería empezar usando <code>git flow feature track &lt;FEATURE_NAME&gt;</code> y luego mantener tu rama actualizada con <code>git flow feature pull origin &lt;FEATURE_NAME&gt;</code></p></p><p><a href=\'https://stackoverflow.com/questions/18412750/why-doesnt-git-flow-feature-pull-track\' target=\'_blank\'>Know more</a></p>","code":"git flow feature track <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-feature-finish","title":"Git Flow. Terminar una \'feature\'","description":"<p>Cuando se finaliza el desarrollo de la nueva función, se deberá fusionar con <code>develop</code> y eliminarse del repositorio local y del remoto si llego a subirse.</p><p>El siguiente comando realiza los siguientes commandos: <ul><li><code>git checkout develop</code></li><li><code>git merge feature/&lt;FEATURE_NAME&gt;</code></li><li><code>git branch -D &lt;FEATURE_NAME&gt;</code></li><li><code>git push origin :&lt;FEATURE_NAME&gt;</code></li></ul></p>","code":"git flow feature finish <FEATURE_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-bugfix-start","title":"Git Flow. Empezar un \'bugfix\'","description":"<p>Durante el desarrollo del proyecto podrán encontrase errores en alguna de las ramas del repositorio. Para solucionarlos tenemos 2 tipos de ramas diferentes según el lugar que ocupan estos errores en el flujo de trabajo de git: <code>bugfix</code> y <code>hotfix</code>.</p><p>El término <code>bugfix</code> o <strong>corrección de errores</strong> se utilizan cuando se encuentra un problema durante la fase de desarrollo, para arreglar errores de una anterior funcionalidad u omisiones de desarrollo.<br> Este tipo de ramas se crean desde <code>develop</code> y se fusionan de nuevo en <code>develop</code> al terminarse.</p><p>El siguiente comando es lo mismo que ejecutar: <ul><li><code>git checkout develop</code></li><li><code>git branch bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git checkout bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>","code":"git flow bugfix start <BUGFIX_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-bugfix-finish","title":"Git Flow. Terminar un \'bugfix\'","description":"<p>Las ramas <code>bugfix</code> o de corrección de errores son ramas temporales, que una vez resueltos los errores, se eliminan después de fusionarse con la rama de desarrollo <code>develop</code>.</p><p>El siguiente comando es lo mismo que ejecutar: <ul><li><code>git checkout develop</code></li><li><code>git merge bugfix/&lt;BUGFIX_NAME&gt;</code></li><li><code>git branch -D bugfix/&lt;BUGFIX_NAME&gt;</code></li></ul></p>","code":"git flow bugfix finish <BUGFIX_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-start","title":"Git Flow. Empezar una \'release\'","description":"<p>Para preparar nuestra aplicación para su puesta en producción existen unas ramas llamadas <code>release</code>. En algunos equipos, estas ramas son las que se vuelcan en los servidores de pre-producción para hacer el testing final: se corrigen errores menores, se pule la interfaz, se ajusta la maquetación…se hace la puesta a punto final de la aplicación antes de liberar la versión definitiva.</p><p>El nombre de la <code>release</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href=\'https://semver.org/lang/es/\' target=\'_blank\'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión \'major\' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión \'minor\' (incorporación de una funcionalidad), y <code>Z</code> es la versión \'patch\' (correción de errores compatibles con la versión anterior). </br> Por tanto, el número de la <code>release</code> sería el primero, <code>X</code>.</p><p>El siguiente comando crea una rama de lanzamiento a partir de la rama <code>develop</code>. Opcionalmente, se puede suministrar el id de un commit situada en <code>develop</code> para iniciar el lanzamiento desde el commit.</p><p><a href=\'https://aprendegit.com/git-flow-release-branches/\' target=\'_blank\'>Saber más</a></p>","code":"git flow release start <VERSION_NUMBER> <[BASE]>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-list","title":"Git Flow. Obtener una lista de \'release\'","description":"<p>Puede ver una lista de todas las ramas de lanzamiento actuales creadas en el repositorio local.</p>","code":"git flow release list"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-publish","title":"Git Flow. Publicar una \'release\'","description":"<p>Si esta trabajando en equipo y otro de sus compañeros debe revisar el código antes del lanzamiento de una nueva versión, es aconsejable publicar la rama de lanzamiento después de crearla para permitir que otros desarrolladores hagan commits de lanzamiento.</p>","code":"git flow release publish <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-track","title":"Git Flow. Seguir el rastro de una \'release\'","description":"<p>Puede seguir los cambios de una versión publicada en el repositorio remoto.</p>","code":"git flow release track <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-release-finish","title":"Git Flow. Terminar una \'release\'","description":"<p>Una vez creada la rama <code>release</code>, empezamos el proceso de corrección y depuración, se realizan los commits necesarios y cuando hemos terminado de arreglar todos los \'bugs\', estamos listos para que nuestro proyecto pase a producción y eliminar la rama.</p><p>Terminar una versión es uno de los grandes pasos en la creación de ramas de git. El siguiente comando realiza varias acciones: fusiona la rama de la versión con <code>master</code>, etiqueta la versión con su nombre, vuelve a fusionar la versión con <code>develop</code> y elimina la rama de la versión.</p><p>Cuando ejecutamos este comando git-flow nos va a pedir que introduzcamos 3 mensajes: <ol><li>El mensaje del commit del merge como resultado de incorporar los cambios en <code>master</code>.</li><li>El mensaje que git-flow pondrá a la etiqueta que va a crear para identificar esta versión.</li><li>Y por último el mensaje del commit del merge como resultado de incorporar la rama a <code>develop</code>.</li></ol></p><p>La ejecución de este comando que pueden resumirse en los siguientes comandos: <ul><li><code>git checkout master</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git tag v&lt;VERSION_NUMBER&gt;</code></li><li><code>git checkout develop</code></li><li><code>git merge release/&lt;VERSION_NUMBER&gt; --no-ff</code></li><li><code>git branch -d release/&lt;VERSION_NUMBER&gt;</code></li></ul></p>","code":"git flow release finish <VERSION_NUMBER>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-tags-push-single","title":"Git Flow. Publicar una sola etiqueta","description":"<p>Después de terminar la rama de lanzamiento, no olvide añadir las etiquetas al repositorio remoto. Este comando empujará una sola etiqueta al repositorio remoto.</p>","code":"git push <REPO_NAME> <TAG_NAME>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-tags-push","title":"Git Flow. Publicar todas las etiquetas","description":"<p>Puedes añadir todas las etiquetas al repositorio remoto con un solo comando. Esta forma no se recomienda porque es común que los desarrolladores tengan etiquetas viejas o \'malas\' en sus repositorios locales que no tienen necesidad de estar en el remoto, por lo que se aconseja sólo empujar explícitamente una etiqueta y no todas sus etiquetas a la vez.</p>","code":"git push <REPO_NAME> --tags"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-hotfix-start","title":"Git Flow. Iniciar un \'hotfix\'","description":"<p>Al igual que existen ramas para resolver errores que hemos encontrado durante el proceso de desarrollo, exisiten otro tipo de ramas. Estas ramas llamadas <code>hotfix</code>, se crean para actuar inmediatamente sobre un estado no deseado de una versión de producción en vivo, se utilizan para corregir errores u omisiones urgentes que no pueden esperar al lanzamiento de la siguiente versión.<br>El tiempo de vida de esta rama es temporal, se crea a partir de <code>master</code>, se fusiona de nuevo en <code>master</code> y se elimina después de la fusión.</p><p>El nombre del <code>hotfix</code> es una cifra de 3 números enteros separados por puntos que van incrementandose numericamente en incrementos de 1. Este número sigue la nomenclatura del <a href=\'https://semver.org/lang/es/\' target=\'_blank\'>versionado semántico</a>, <code>X.Y.Z</code>, donde <code>X</code> es la versión \'major\' (incorporación de multiples cambios que ya no son compatibles con la API pública), <code>Y</code> es la versión \'minor\' (incorporación de una funcionalidad), y <code>Z</code> es la versión \'patch\' (correción de errores compatibles con la versión anterior).</br> Por tanto, el número del <code>hotfix</code> sería el tercero y último, <code>Z</code>.</p><p>Opcionalmente, se puede especificar un nombre base, el id de un commit, desde el que crear la rama.</p>","code":"git flow hotfix start <VERSION_NUMBER> <[BASE_NAME]>"},{"parent":"gitFlow","url":"command-git-flow","name":"gitflow-hotfix-finish","title":"Git Flow. Terminar un \'hotfix\'","description":"<p>Cuando se han realizado todas las correciones en una rama <code>hotfix</code>, hay que realizar el siguiente comando para finalizar la rama. Este proceso fusiona la rama de nuevo con <code>develop</code> y <code>master</code>, crea una etiqueta con el número de versión del <code>hotfix</code> y elimina dicha rama, ya que su existencia es temporal.</p>","code":"git flow hotfix finish <VERSION_NUMBER>"}]}')},"6c7e":function(e){e.exports=JSON.parse('[{"url":"https://gist.github.com/beatrizsmerino/4a91c69b7590b469c2d09e5007855e56","description":"GitHub Gist of @beatrizsmerino: Commands Git"},{"url":"https://git-scm.com/doc","description":"Git documentation"},{"url":"https://training.github.com/","description":"Git Cheat Sheets"},{"url":"https://ndpsoftware.com/git-cheatsheet.html","description":"Git: cheatsheet interactive"},{"url":"http://danielkummer.github.io/git-flow-cheatsheet/","description":"Git Flow: cheatsheet"},{"url":"https://yakiloo.com/getting-started-git-flow/","description":"Getting Started – Git-Flow"},{"url":"https://stackabuse.com/git-push-tags-to-a-remote-repo/","description":"Git: Push Tags to a Remote Repo"},{"url":"https://jointcenterforsatellitedataassimilation-jedi-docs.readthedocs-hosted.com/en/latest/developer/practices/gitflow.html#gitflow-top","description":"Follow the Git flow Paradigm"},{"url":"https://www.atlassian.com/git/tutorials/rewriting-history","description":"Rewriting history"},{"url":"https://blog.ostermiller.org/removing-and-purging-files-from-git-history/","description":"Removing and purging files from git history"},{"url":"https://www.atlassian.com/es/git/tutorials/comparing-workflows/feature-branch-workflow","description":"Git Feature Branch Workflow"},{"url":"https://explainshell.com/explain?cmd=git+log+--all+--graph+--decorate+--oneline+--simplify-by-decoration","description":"Explain shell: About git log --all --graph --decorate --oneline --simplify-by-decoration"},{"url":"https://davidinformatico.com/apuntes-git/","description":"David Poza: Mis apuntes de git"},{"url":"https://www.git-tower.com/learn/git/faq/change-author-name-email/","description":"How can I change the author name/email of a commit?"},{"url":"https://www.runroom.com/realworld/git-stash","description":"El comando stash para cambios rápidos en un proyecto"},{"url":"https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase","description":"Rewriting history: git rebase"},{"url":"https://www.runroom.com/realworld/comandos-de-git-rebase","description":"Comandos de Git: Rebase"},{"url":"https://www.atlassian.com/git/tutorials/merging-vs-rebasing","description":"Merging vs. Rebasing"},{"url":"https://platzi.com/clases/1557-git-github/19988-git-reset-y-reflog-usese-en-caso-de-emergencia/","description":"Platzi: Git reset y reflog: úsese en caso de emergencia"},{"url":"https://riptutorial.com/ebook/git","description":"Learning Git eBook (PDF)"},{"url":"https://www.freecodecamp.org/news/git-cheat-sheet/","description":"Git Cheat Sheet – 50 Git Commands You Should Know"}]')},7714:function(e,t,o){},"7e6f":function(e,t,o){},"834f":function(e,t,o){},8430:function(e,t,o){},"8b84":function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"filter-nav",class:{"is-open":e.isOpen}},[t("div",{directives:[{name:"closable",rawName:"v-closable",value:{exclude:["buttonFilter"],handler:"closeFilter"},expression:"{\n\t\t\texclude: ['buttonFilter'],\n\t\t\thandler: 'closeFilter',\n\t\t}"}],staticClass:"filter-nav__inner"},[t("button",{ref:"buttonFilter",staticClass:"filter-nav__button",on:{click:e.openCloseFilter}},[t("span",{staticClass:"bg"},[t("svg",{attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 366 730"}},[t("path",{attrs:{d:"M317.638,0V44.353c0,52.1-32.216,89.512-86.9,101.005a151.174,151.174,0,0,1-22.577,2.893C70.024,156.038.623,258.217,0,360.818H0v0H0C.623,463.424,70.024,565.6,208.157,573.39a151.043,151.043,0,0,1,22.577,2.893c54.688,11.493,86.9,48.9,86.9,101.005V730H366V0Z"}})])]),t("i",{staticClass:"icon"},[t("font-awesome-icon",{attrs:{icon:["fas","filter"]}})],1)]),t("div",{staticClass:"filter-nav__content"},[t("h1",{staticClass:"filter-nav__title"},[e._v(" Filter ")]),t("div",{staticClass:"filter-nav__type"},[t("h2",{staticClass:"filter-nav__subtitle"},[e._v(" Languages ")]),t("div",{staticClass:"filter-nav__subcontent"},[t("UILanguages")],1)])])])])},i=[],r=(o("d3b7"),o("0643"),o("4e3e"),o("159b"),o("2b0e")),n=function(){var e=this,t=e._self._c;return t("div",{staticClass:"list-buttons"},e._l(e.languages,(function(o){return t("UIButton",{key:o.locale,class:[o.locale==e.$i18n.locale?"button--bg-color-1":"button--bg-color-2-light"],on:{"emit-click":function(t){return e.changeLanguage(o.locale)}}},[e._v(" "+e._s(o.title)+" ")])})),1)},s=[],c=o("d3a4"),l=function(){var e=this,t=e._self._c;return t(e.checkTag,{tag:"component",staticClass:"button",attrs:{href:e.href,value:e.value},on:{click:e.buttonClick}},[e._t("default")],2)},d=[],m={name:"UIButton",props:{href:{type:String,default:null},to:{type:String,default:null},value:{type:String,default:null}},computed:{checkTag:function(){return this.href?"a":this.value?"input":"button"}},methods:{buttonClick:function(){this.$emit("emit-click")}}},u=m,h=(o("92f5"),o("2877")),p=Object(h["a"])(u,l,d,!1,null,"b8d62bb4",null),g=p.exports,f={name:"UILanguages",components:{UIButton:g},computed:{languages:function(){return[{locale:"es",title:this.$t("language.spanish")},{locale:"en",title:this.$t("language.english")}]}},methods:{changeLanguage:function(e){c["a"].locale=e}}},b=f,w=(o("fbd6"),Object(h["a"])(b,n,s,!1,null,"29e61ddf",null)),y=w.exports,v=null;r["a"].directive("closable",{bind:function(e,t,o){v=function(a){a.stopPropagation();var i=t.value,r=i.handler,n=i.exclude,s=!1;n.forEach((function(e){if(!s){var t=o.context.$refs[e];"undefined"!==typeof t&&(s=t.contains(a.target))}})),e.contains(a.target)||s||o.context[r]()},document.addEventListener("click",v),document.addEventListener("touchstart",v)},unbind:function(){document.removeEventListener("click",v),document.removeEventListener("touchstart",v)}});var E={name:"UIFilterNav",components:{UILanguages:y},data:function(){return{isOpen:!1}},watch:{isOpen:function(){document.body.style.overflow=this.isOpen?"hidden":""}},methods:{openCloseFilter:function(){this.isOpen=!this.isOpen},closeFilter:function(){this.isOpen=!1}}},_=E,A=(o("1c33"),Object(h["a"])(_,a,i,!1,null,"0c7dbd87",null));t["a"]=A.exports},"8bf6":function(e,t,o){},"8c9b":function(e,t,o){"use strict";o("7e6f")},"8f53":function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"page-content"},[t("div",{staticClass:"page-content__inner"},[t("FilterNav"),t("CommandList",{attrs:{"command-list":e.getCommandList}})],1)])},i=[],r=o("8b84"),n=o("46e2"),s={name:"CommandsGitFlow",components:{FilterNav:r["a"],CommandList:n["a"]},computed:{getCommandList:function(){return this.$t("commandList.gitFlow")}}},c=s,l=o("2877"),d=Object(l["a"])(c,a,i,!1,null,"96dd5bc4",null);t["a"]=d.exports},9078:function(e,t,o){"use strict";o("e8df")},"92f5":function(e,t,o){"use strict";o("beb1")},9388:function(e,t,o){"use strict";o("4a9d")},"94fd":function(e,t,o){},a0f9:function(e,t,o){"use strict";o("cf6b")},a18c:function(e,t,o){"use strict";(function(e){var a=o("c7eb"),i=o("1da1"),r=(o("7db0"),o("a630"),o("d81d"),o("fb6a"),o("b64b"),o("d3b7"),o("3ca3"),o("0643"),o("fffc"),o("4e3e"),o("a573"),o("9a9a"),o("159b"),o("2b0e")),n=o("8c4f"),s=o("bb51"),c=o("4083"),l=o("8f53"),d=o("d50e");r["a"].use(n["a"]);var m=[{path:"",name:"home",component:s["a"],meta:{title:"Home",metaTags:[{name:"description",content:"The home page of GitBible app."}]}},{path:"/command-git",name:"command-git",component:c["a"],meta:{title:"Git commands",metaTags:[{name:"description",content:"List of Git commands of GitBible app."}]}},{path:"/command-git-flow",name:"command-git-flow",component:l["a"],meta:{title:"Git Flow commands",metaTags:[{name:"description",content:"List of Git Flow commands of GitBible app."}]}},{path:"/bibliografy",name:"bibliografy",component:d["a"],meta:{title:"Bibliografy",metaTags:[{name:"description",content:"Bibliography of GitBible app."}]}},{path:"*",redirect:"/",component:s["a"],meta:{title:"Home",metaTags:[{name:"description",content:"The home page of GitBible app."}]}}];function u(e){var t=document.querySelector(e.hash),o=null===t||void 0===t?void 0:t.getAttribute("data-index");return t&&"1"===o?{selector:e.hash,offset:{y:400},behavior:"smooth"}:"0"!==o&&{selector:e.hash,offset:{y:200},behavior:"smooth"}}function h(e,t){return p.apply(this,arguments)}function p(){return p=Object(i["a"])(Object(a["a"])().mark((function e(t,o){var i,r;return Object(a["a"])().wrap((function(e){while(1)switch(e.prev=e.next){case 0:return i={x:0,y:0},r=o.matched.some((function(e){return e.meta.scrollToTop}))?i:{},e.next=4,new Promise((function(e){return t.$root.$once("triggerScroll",e)}));case 4:return e.abrupt("return",r);case 5:case"end":return e.stop()}}),e)}))),p.apply(this,arguments)}var g=function(e,t,o){return o||(e.hash?u(e):h(this.app,e))},f=new n["a"]({mode:"history",base:e,routes:m,scrollBehavior:g});f.beforeEach((function(e,t,o){var a=e.matched.slice().reverse().find((function(e){return e.meta&&e.meta.title})),i=e.matched.slice().reverse().find((function(e){return e.meta&&e.meta.metaTags}));return t.matched.slice().reverse().find((function(e){return e.meta&&e.meta.metaTags})),a&&(document.title="".concat(a.meta.title," | GitBible")||!1),Array.from(document.querySelectorAll("[data-vue-router-controlled]")).map((function(e){return e.parentNode.removeChild(e)})),i?(i.meta.metaTags.map((function(e){var t=document.createElement("meta");return Object.keys(e).forEach((function(o){t.setAttribute(o,e[o])})),t.setAttribute("data-vue-router-controlled",""),t})).forEach((function(e){return document.head.appendChild(e)})),o()):o()})),t["a"]=f}).call(this,"/")},a7f6:function(e,t,o){},acaa:function(e,t,o){"use strict";o("b143")},b0db:function(e,t,o){},b143:function(e,t,o){},bb51:function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"page-content"},[t("div",{staticClass:"page-content__inner"},[t("UILogo",{attrs:{theme:"logo--home"}}),t("UISearch")],1)])},i=[],r=o("07e6"),n=(o("99af"),o("b0c0"),function(){var e=this,t=e._self._c;return t("div",{staticClass:"search"},[t("form",{staticClass:"search-form",on:{submit:function(e){e.preventDefault()}}},[t("div",{staticClass:"search-form__field"},[t("input",{directives:[{name:"model",rawName:"v-model",value:e.searchText,expression:"searchText"}],staticClass:"search-form__input",attrs:{id:"searchField",type:"text",placeholder:"Search command"},domProps:{value:e.searchText},on:{change:e.checkScrollVertical,input:function(t){t.target.composing||(e.searchText=t.target.value)}}}),t("i",{staticClass:"search-form__icon icon icon-search"})])]),t("div",{staticClass:"search-results is-scroll is-scroll-start"},[t("div",{staticClass:"search-results__inner",attrs:{id:"searchResultsInner"},on:{scroll:e.checkScrollVertical}},[t("ul",{staticClass:"search-results__list"},e._l(e.filteredList,(function(o){return t("li",{key:o.id,staticClass:"search-results__item",attrs:{id:o.name,"data-index":o.id}},[t("router-link",{staticClass:"search-results__link",attrs:{to:"/".concat(o.url,"/#").concat(o.name)}},[t("span",{staticClass:"search-results__text text-ellipsis"},[e._v(" "+e._s(o.title)+" ")])])],1)})),0)])])])}),s=[],c=(o("4de4"),o("caad"),o("d3b7"),o("2532"),o("0643"),o("2382"),{name:"UISearch",data:function(){return{commandList:[],searchText:""}},computed:{filteredList:function(){var e=this;return this.commandList.filter((function(t){return t.title.toLowerCase().includes(e.searchText.toLowerCase())}))}},created:function(){var e=this.$t("commandList.git").filter((function(e){return""!==e.name&&""!==e.title})),t=this.$t("commandList.gitFlow").filter((function(e){return""!==e.name&&""!==e.title}));this.commandList=e.concat(t)},methods:{toggleScrollClass:function(e,t,o){o?e.classList.add(t):e.classList.remove(t)},checkScrollVertical:function(){var e=document.getElementById("searchResultsInner"),t=e.parentNode,o=e.scrollTop,a=e.scrollHeight,i=e.offsetHeight,r=0===o,n=a-o===i;this.toggleScrollClass(t,"is-scroll-start",r),this.toggleScrollClass(t,"is-scroll-end",n)}}}),l=c,d=(o("8c9b"),o("2877")),m=Object(d["a"])(l,n,s,!1,null,"f9b7a9ac",null),u=m.exports,h={name:"Home",components:{UILogo:r["a"],UISearch:u},mounted:function(){document.querySelector(".page-header").style.boxShadow="none"}},p=h,g=(o("acaa"),Object(d["a"])(p,a,i,!1,null,"4fc2d974",null));t["a"]=g.exports},beb1:function(e,t,o){},c89c:function(e,t,o){"use strict";o("3339")},cf6b:function(e,t,o){},d3a4:function(e,t,o){"use strict";o.d(t,"a",(function(){return c}));var a=o("2b0e"),i=o("a925"),r=o("4bae"),n=o("6b9f");a["a"].use(i["a"]);var s={es:{language:{spanish:"Español",english:"Inglés"},commandList:n},en:{language:{spanish:"Spanish",english:"English"},commandList:r}},c=new i["a"]({locale:"en",fallbackLocale:"es",messages:s})},d50e:function(e,t,o){"use strict";var a=function(){var e=this,t=e._self._c;return t("div",{staticClass:"page-content"},[t("div",{staticClass:"page-content__inner"},[t("ReferenceList")],1)])},i=[],r=function(){var e=this,t=e._self._c;return t("ul",{staticClass:"reference-list"},e._l(e.referenceList,(function(e,o){return t("li",{key:"reference-".concat(o),staticClass:"reference-list__item",attrs:{"data-index":o}},[t("ReferenceItem",{attrs:{"reference-item":e}})],1)})),0)},n=[],s=o("6c7e"),c=(o("a4d3"),o("e01a"),function(){var e=this,t=e._self._c;return t("div",{staticClass:"reference-item"},[t("a",{staticClass:"reference-item__link",attrs:{href:e.referenceItem.url,target:"_blank"}},[t("p",{staticClass:"reference-item__description"},[e._v(" "+e._s(e.referenceItem.description)+" ")]),t("p",{staticClass:"reference-item__url"},[t("i",{staticClass:"reference-item__url-icon"},[t("font-awesome-icon",{attrs:{icon:["fas","link"]}})],1),t("span",{staticClass:"reference-item__url-text text-ellipsis"},[e._v(" "+e._s(e.referenceItem.url)+" ")])])])])}),l=[],d={name:"ReferenceItem",props:{referenceItem:{type:Object,required:!0}}},m=d,u=(o("9078"),o("2877")),h=Object(u["a"])(m,c,l,!1,null,"df072600",null),p=h.exports,g={name:"ReferenceList",components:{ReferenceItem:p},data:function(){return{referenceList:[]}},created:function(){this.referenceList=s}},f=g,b=(o("128a"),Object(u["a"])(f,r,n,!1,null,"281a3bd4",null)),w=b.exports,y={name:"Bibliografy",components:{ReferenceList:w}},v=y,E=Object(u["a"])(v,a,i,!1,null,"62ea9447",null);t["a"]=E.exports},d6d7:function(e,t,o){"use strict";o("94fd")},d9fd:function(e,t,o){},e0a1:function(e,t,o){"use strict";o("8430")},e8df:function(e,t,o){},f00a:function(e,t,o){"use strict";o("7714")},fb93:function(e,t,o){"use strict";o("d9fd")},fbd6:function(e,t,o){"use strict";o("a7f6")}});
//# sourceMappingURL=app.dc6b42fc.js.map